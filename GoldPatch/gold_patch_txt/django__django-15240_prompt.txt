# 修复代码生成提示词（实例ID：django__django-15240）
## 代码仓库
django/django

## 原始问题描述
Delete nonexistent migrations from django_migrations table
Description
	
Django adds a django_migrations table to the database which list all of the migrations that have been applied (and when).
With the introduction of squashmigrations, it is possible for this table to contain a lot of old migrations that no longer exist. This can be problematic if naming duplication occurs:
Example:
I have an app with:
my_app/migrations/
0001_initial.py
0002_blah.py
0003_blah.py
I squash and delete replaced migrations:
my_app/migrations/
0001_initial_squashed_0003_blah.py
I create a new migration and use poor naming:
my_app/migrations/
0001_initial_squashed_0003_blah.py
0002_blah.py
My new migration never runs because the django_migrations table thinks it has already been applied.
I propose truncation of the django_migrations table so that it includes only migrations that actually exist in the django project. This could be done automatically (when executor runs, or inside the migrate mcommand). Or have its own mcommand that requires it be run manually. I prefer the automatic approach though.
Pros:
Cleans up old data that just bloats the database.
Protects users from the trap mentioned above where a new migration is created with the same name as one that was applied in the past.
Cons:
A loss of historical information.
Note:
Need to be careful with implementation to avoid a possible new trap if a user squashes migrations and then proceeds to delete the replaced migrations before running the squashed migrations on their database -> django will think squashed migrations haven't been applied and will attempt to reapply them. This can be remedied simply by not removing migrations mentioned in replaces lists of other migrations from django_migrations (ie. we'd consider replaced migrations as still existing, even if their actual files have already been removed).


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py
--- a/tests/migrations/test_commands.py
+++ b/tests/migrations/test_commands.py
@@ -1043,6 +1043,92 @@ class Meta():
             call_command('migrate', 'migrated_app', 'zero', verbosity=0)
             call_command('migrate', 'migrated_unapplied_app', 'zero', verbosity=0)
 
+    @override_settings(MIGRATION_MODULES={
+        'migrations': 'migrations.test_migrations_squashed_no_replaces',
+    })
+    def test_migrate_prune(self):
+        """
+        With prune=True, references to migration files deleted from the
+        migrations module (such as after being squashed) are removed from the
+        django_migrations table.
+        """
+        recorder = MigrationRecorder(connection)
+        recorder.record_applied('migrations', '0001_initial')
+        recorder.record_applied('migrations', '0002_second')
+        recorder.record_applied('migrations', '0001_squashed_0002')
+        out = io.StringIO()
+        try:
+            call_command('migrate', 'migrations', prune=True, stdout=out, no_color=True)
+            self.assertEqual(
+                out.getvalue(),
+                'Pruning migrations:\n'
+                '  Pruning migrations.0001_initial OK\n'
+                '  Pruning migrations.0002_second OK\n',
+            )
+            applied_migrations = [
+                migration
+                for migration in recorder.applied_migrations()
+                if migration[0] == 'migrations'
+            ]
+            self.assertEqual(applied_migrations, [('migrations', '0001_squashed_0002')])
+        finally:
+            recorder.record_unapplied('migrations', '0001_initial')
+            recorder.record_unapplied('migrations', '0001_second')
+            recorder.record_unapplied('migrations', '0001_squashed_0002')
+
+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})
+    def test_prune_deleted_squashed_migrations_in_replaces(self):
+        out = io.StringIO()
+        with self.temporary_migration_module(
+            module='migrations.test_migrations_squashed'
+        ) as migration_dir:
+            try:
+                call_command('migrate', 'migrations', verbosity=0)
+                # Delete the replaced migrations.
+                os.remove(os.path.join(migration_dir, '0001_initial.py'))
+                os.remove(os.path.join(migration_dir, '0002_second.py'))
+                # --prune cannot be used before removing the "replaces"
+                # attribute.
+                call_command(
+                    'migrate', 'migrations', prune=True, stdout=out, no_color=True,
+                )
+                self.assertEqual(
+                    out.getvalue(),
+                    "Pruning migrations:\n"
+                    "  Cannot use --prune because the following squashed "
+                    "migrations have their 'replaces' attributes and may not "
+                    "be recorded as applied:\n"
+                    "    migrations.0001_squashed_0002\n"
+                    "  Re-run 'manage.py migrate' if they are not marked as "
+                    "applied, and remove 'replaces' attributes in their "
+                    "Migration classes.\n"
+                )
+            finally:
+                # Unmigrate everything.
+                call_command('migrate', 'migrations', 'zero', verbosity=0)
+
+    @override_settings(
+        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'}
+    )
+    def test_prune_no_migrations_to_prune(self):
+        out = io.StringIO()
+        call_command('migrate', 'migrations', prune=True, stdout=out, no_color=True)
+        self.assertEqual(
+            out.getvalue(),
+            'Pruning migrations:\n'
+            '  No migrations to prune.\n',
+        )
+        out = io.StringIO()
+        call_command(
+            'migrate', 'migrations', prune=True, stdout=out, no_color=True, verbosity=0,
+        )
+        self.assertEqual(out.getvalue(), '')
+
+    def test_prune_no_app_label(self):
+        msg = 'Migrations can be pruned only when an app is specified.'
+        with self.assertRaisesMessage(CommandError, msg):
+            call_command('migrate', prune=True)
+
 
 class MakeMigrationsTests(MigrationTestBase):
     """
diff --git a/tests/migrations/test_migrations_squashed_no_replaces/0001_squashed_0002.py b/tests/migrations/test_migrations_squashed_no_replaces/0001_squashed_0002.py
new file mode 100644
--- /dev/null
+++ b/tests/migrations/test_migrations_squashed_no_replaces/0001_squashed_0002.py
@@ -0,0 +1,21 @@
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    operations = [
+        migrations.CreateModel(
+            "Author",
+            [
+                ("id", models.AutoField(primary_key=True)),
+                ("name", models.CharField(max_length=255)),
+            ],
+        ),
+        migrations.CreateModel(
+            "Book",
+            [
+                ("id", models.AutoField(primary_key=True)),
+                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
+            ],
+        ),
+    ]
diff --git a/tests/migrations/test_migrations_squashed_no_replaces/__init__.py b/tests/migrations/test_migrations_squashed_no_replaces/__init__.py
new file mode 100644