# 修复代码生成提示词（实例ID：astropy__astropy-14253）
## 代码仓库
astropy/astropy

## 原始问题描述
When should `info` be linked to a new object?
Mostly for @taldcroft - I noticed that in `Quantity` the way we have set up `__array_finalize__`, `info` is passed on not just for views (where it should be), but also for copies (implicitly in arithmetic operations, etc.). Which ones are reasonable?  Just thinking about whether, e.g., `info.name` should be propagated, I'd think:
- Surely for
  - views & reshapes: `q[...]`, `q.squeeze`, etc.
  - insertions: `q.insert(...)`
- Probably for
  - selection of scalars: `q[0]` or in `for q1 in q:` (for columns this returns a scalar without `info`)
  - copies: `q.copy()` and equivalents
  - equivalent unit changes: `q.to(...)`, `q.si`, `q.decompose()`, etc.
- Probably not for
  - operations `q3 = q1 + q2`
  - real unit changes `q * unit` (including in-place??; `q /= u.m`)

What do you think?

p.s. Currently, all of the above happen, in part because I use `__array_finalize__` in `Quantity._new_view`, something which I don't think we had really considered when we made the change in `__array_finalize__`. But that also means that in principle it may not too hard to fairly finely define the behaviour.



## 参考黄金补丁（正确的修复方案）
diff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py
--- a/astropy/units/tests/test_quantity.py
+++ b/astropy/units/tests/test_quantity.py
@@ -397,6 +397,16 @@ def test_multiplication(self):
         assert new_quantity.value == 171.3
         assert new_quantity.unit == u.meter
 
+        # Multiple with a unit.
+        new_quantity = self.q1 * u.s
+        assert new_quantity.value == 11.42
+        assert new_quantity.unit == u.Unit("m s")
+
+        # Reverse multiple with a unit.
+        new_quantity = u.s * self.q1
+        assert new_quantity.value == 11.42
+        assert new_quantity.unit == u.Unit("m s")
+
     def test_division(self):
         # Take units from left object, q1
         new_quantity = self.q1 / self.q2
@@ -424,6 +434,16 @@ def test_division(self):
         assert new_quantity.value == 1.0
         assert new_quantity.unit == u.Unit("1/m")
 
+        # Divide by a unit.
+        new_quantity = self.q1 / u.s
+        assert new_quantity.value == 11.42
+        assert new_quantity.unit == u.Unit("m/s")
+
+        # Divide into a unit.
+        new_quantity = u.s / self.q1
+        assert new_quantity.value == 1 / 11.42
+        assert new_quantity.unit == u.Unit("s/m")
+
     def test_commutativity(self):
         """Regression test for issue #587."""
 
diff --git a/astropy/units/tests/test_quantity_info.py b/astropy/units/tests/test_quantity_info.py
new file mode 100644
--- /dev/null
+++ b/astropy/units/tests/test_quantity_info.py
@@ -0,0 +1,121 @@
+# Licensed under a 3-clause BSD style license - see LICENSE.rst
+"""Test the propagation of info on Quantity during operations."""
+
+import copy
+
+import numpy as np
+
+from astropy import units as u
+
+
+def assert_info_equal(a, b, ignore=set()):
+    a_info = a.info
+    b_info = b.info
+    for attr in (a_info.attr_names | b_info.attr_names) - ignore:
+        if attr == "unit":
+            assert a_info.unit.is_equivalent(b_info.unit)
+        else:
+            assert getattr(a_info, attr, None) == getattr(b_info, attr, None)
+
+
+def assert_no_info(a):
+    assert "info" not in a.__dict__
+
+
+class TestQuantityInfo:
+    @classmethod
+    def setup_class(self):
+        self.q = u.Quantity(np.arange(1.0, 5.0), "m/s")
+        self.q.info.name = "v"
+        self.q.info.description = "air speed of a african swallow"
+
+    def test_copy(self):
+        q_copy1 = self.q.copy()
+        assert_info_equal(q_copy1, self.q)
+        q_copy2 = copy.copy(self.q)
+        assert_info_equal(q_copy2, self.q)
+        q_copy3 = copy.deepcopy(self.q)
+        assert_info_equal(q_copy3, self.q)
+
+    def test_slice(self):
+        q_slice = self.q[1:3]
+        assert_info_equal(q_slice, self.q)
+        q_take = self.q.take([0, 1])
+        assert_info_equal(q_take, self.q)
+
+    def test_item(self):
+        # Scalars do not get info set (like for Column); TODO: is this OK?
+        q1 = self.q[1]
+        assert_no_info(q1)
+        q_item = self.q.item(1)
+        assert_no_info(q_item)
+
+    def test_iter(self):
+        # Scalars do not get info set.
+        for q in self.q:
+            assert_no_info(q)
+        for q in iter(self.q):
+            assert_no_info(q)
+
+    def test_change_to_equivalent_unit(self):
+        q1 = self.q.to(u.km / u.hr)
+        assert_info_equal(q1, self.q)
+        q2 = self.q.si
+        assert_info_equal(q2, self.q)
+        q3 = self.q.cgs
+        assert_info_equal(q3, self.q)
+        q4 = self.q.decompose()
+        assert_info_equal(q4, self.q)
+
+    def test_reshape(self):
+        q = self.q.reshape(-1, 1, 2)
+        assert_info_equal(q, self.q)
+        q2 = q.squeeze()
+        assert_info_equal(q2, self.q)
+
+    def test_insert(self):
+        q = self.q.copy()
+        q.insert(1, 1 * u.cm / u.hr)
+        assert_info_equal(q, self.q)
+
+    def test_unary_op(self):
+        q = -self.q
+        assert_no_info(q)
+
+    def test_binary_op(self):
+        q = self.q + self.q
+        assert_no_info(q)
+
+    def test_unit_change(self):
+        q = self.q * u.s
+        assert_no_info(q)
+        q2 = u.s / self.q
+        assert_no_info(q)
+
+    def test_inplace_unit_change(self):
+        # Not sure if it is logical to keep info here!
+        q = self.q.copy()
+        q *= u.s
+        assert_info_equal(q, self.q, ignore={"unit"})
+
+
+class TestStructuredQuantity:
+    @classmethod
+    def setup_class(self):
+        value = np.array([(1.0, 2.0), (3.0, 4.0)], dtype=[("p", "f8"), ("v", "f8")])
+        self.q = u.Quantity(value, "m, m/s")
+        self.q.info.name = "pv"
+        self.q.info.description = "Location and speed"
+
+    def test_keying(self):
+        q_p = self.q["p"]
+        assert_no_info(q_p)
+
+    def test_slicing(self):
+        q = self.q[:1]
+        assert_info_equal(q, self.q)
+
+    def test_item(self):
+        # Scalars do not get info set.
+        q = self.q[1]
+        assert_no_info(q)