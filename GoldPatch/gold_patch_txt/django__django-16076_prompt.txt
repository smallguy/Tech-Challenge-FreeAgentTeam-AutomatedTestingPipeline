# 修复代码生成提示词（实例ID：django__django-16076）
## 代码仓库
django/django

## 原始问题描述
Registering lookups on relation fields should be supported.
Description
	 
		(last modified by Thomas)
	 
Hello,
I have a model, let's call it Parent, with a field called object_id. I have another model, let's call it Child, which has a ForeignKey field called parent_object[_id] pointing to Parent.object_id. I need to do a lookup on Child where the FK starts with a certain character (it's a normalized value so, in the context of my app, it makes sense... also, I didn't design this schema and changing it is not a possibility ATM).
The problem is that if I do:
qs = Child.objects.filter(parent_object_id__startswith='c')
I get:
django.core.exceptions.FieldError: Related Field got invalid lookup: startswith
The only way I could make it work is:
qs = Child.objects.filter(parent_object__object_id__startswith='c')
but it forces a join between the table and the view and that's a no-no in my case (way too costly).
Here's the MCVE (tested on Python 3.9 + Django 4.0.7 and Python 3.10 + Django 4.1.1):
import django
django.setup()
from django.db import models
class Parent(models.Model):
	class Meta:
		app_label = 'test'
	object_id = models.CharField('Object ID', max_length=20, unique=True)
class Child(models.Model):
	class Meta:
		app_label = 'test'
	parent_object = models.ForeignKey(
		Parent, to_field='object_id', related_name='%(class)s_set', on_delete=models.CASCADE
	)
if __name__ == '__main__':
	qs = Child.objects.filter(parent_object_id__startswith='c') # fails with `FieldError: Related Field got invalid lookup: startswith`
	qs = Child.objects.filter(parent_object__object_id__startswith='c') # works but forces a costly join
And the error:
Traceback (most recent call last):
 File "/opt/src/orm_test.py", line 26, in <module>
	qs = Child.objects.filter(parent_object_id__startswith='c')
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/manager.py", line 85, in manager_method
	return getattr(self.get_queryset(), name)(*args, **kwargs)
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/query.py", line 1420, in filter
	return self._filter_or_exclude(False, args, kwargs)
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/query.py", line 1438, in _filter_or_exclude
	clone._filter_or_exclude_inplace(negate, args, kwargs)
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/query.py", line 1445, in _filter_or_exclude_inplace
	self._query.add_q(Q(*args, **kwargs))
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/sql/query.py", line 1532, in add_q
	clause, _ = self._add_q(q_object, self.used_aliases)
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/sql/query.py", line 1562, in _add_q
	child_clause, needed_inner = self.build_filter(
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/sql/query.py", line 1478, in build_filter
	condition = self.build_lookup(lookups, col, value)
 File "/opt/src/venv/lib/python3.10/site-packages/django/db/models/sql/query.py", line 1292, in build_lookup
	raise FieldError(
django.core.exceptions.FieldError: Related Field got invalid lookup: startswith
Thanks for your help,
Regards,


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py
--- a/tests/lookup/tests.py
+++ b/tests/lookup/tests.py
@@ -786,10 +786,16 @@ def test_unsupported_lookups(self):
 
     def test_relation_nested_lookup_error(self):
         # An invalid nested lookup on a related field raises a useful error.
-        msg = "Related Field got invalid lookup: editor"
+        msg = (
+            "Unsupported lookup 'editor' for ForeignKey or join on the field not "
+            "permitted."
+        )
         with self.assertRaisesMessage(FieldError, msg):
             Article.objects.filter(author__editor__name="James")
-        msg = "Related Field got invalid lookup: foo"
+        msg = (
+            "Unsupported lookup 'foo' for ForeignKey or join on the field not "
+            "permitted."
+        )
         with self.assertRaisesMessage(FieldError, msg):
             Tag.objects.filter(articles__foo="bar")
 
diff --git a/tests/queries/models.py b/tests/queries/models.py
--- a/tests/queries/models.py
+++ b/tests/queries/models.py
@@ -1,6 +1,8 @@
 """
 Various complex queries that have been problematic in the past.
 """
+import datetime
+
 from django.db import models
 from django.db.models.functions import Now
 
@@ -64,7 +66,7 @@ def __str__(self):
 
 
 class DateTimePK(models.Model):
-    date = models.DateTimeField(primary_key=True, auto_now_add=True)
+    date = models.DateTimeField(primary_key=True, default=datetime.datetime.now)
 
 
 class ExtraInfo(models.Model):
diff --git a/tests/queries/tests.py b/tests/queries/tests.py
--- a/tests/queries/tests.py
+++ b/tests/queries/tests.py
@@ -7,12 +7,13 @@
 
 from django.core.exceptions import EmptyResultSet, FieldError
 from django.db import DEFAULT_DB_ALIAS, connection
-from django.db.models import Count, Exists, F, Max, OuterRef, Q
+from django.db.models import CharField, Count, Exists, F, Max, OuterRef, Q
 from django.db.models.expressions import RawSQL
+from django.db.models.functions import ExtractYear, Length, LTrim
 from django.db.models.sql.constants import LOUTER
 from django.db.models.sql.where import AND, OR, NothingNode, WhereNode
 from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature
-from django.test.utils import CaptureQueriesContext, ignore_warnings
+from django.test.utils import CaptureQueriesContext, ignore_warnings, register_lookup
 from django.utils.deprecation import RemovedInDjango50Warning
 
 from .models import (
@@ -391,6 +392,33 @@ def test_order_by_join_unref(self):
         qs = qs.order_by("id")
         self.assertNotIn("OUTER JOIN", str(qs.query))
 
+    def test_filter_by_related_field_transform(self):
+        extra_old = ExtraInfo.objects.create(
+            info="extra 12",
+            date=DateTimePK.objects.create(date=datetime.datetime(2020, 12, 10)),
+        )
+        ExtraInfo.objects.create(info="extra 11", date=DateTimePK.objects.create())
+        a5 = Author.objects.create(name="a5", num=5005, extra=extra_old)
+
+        fk_field = ExtraInfo._meta.get_field("date")
+        with register_lookup(fk_field, ExtractYear):
+            self.assertSequenceEqual(
+                ExtraInfo.objects.filter(date__year=2020),
+                [extra_old],
+            )
+            self.assertSequenceEqual(
+                Author.objects.filter(extra__date__year=2020), [a5]
+            )
+
+    def test_filter_by_related_field_nested_transforms(self):
+        extra = ExtraInfo.objects.create(info=" extra")
+        a5 = Author.objects.create(name="a5", num=5005, extra=extra)
+        info_field = ExtraInfo._meta.get_field("info")
+        with register_lookup(info_field, Length), register_lookup(CharField, LTrim):
+            self.assertSequenceEqual(
+                Author.objects.filter(extra__info__ltrim__length=5), [a5]
+            )
+
     def test_get_clears_ordering(self):
         """
         get() should clear ordering for optimization purposes.