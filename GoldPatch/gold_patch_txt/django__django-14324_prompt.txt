# 修复代码生成提示词（实例ID：django__django-14324）
## 代码仓库
django/django

## 原始问题描述
Migration autodetector changes related_name for self-referential ManyToManyField.
Description
	
Migration autodetector no longer adds a model name to the related_name attribute for self-referential ManyToManyField, e.g. for a field
class MyModel2(models.Model):
	field_3 = models.ManyToManyField('self')
it creates a migration with related_name='field_3_rel_+' instead of related_name='_mymodel2_field_3_+'.
Regression in aa4acc164d1247c0de515c959f7b09648b57dc42 (see #29899).


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/field_deconstruction/tests.py b/tests/field_deconstruction/tests.py
--- a/tests/field_deconstruction/tests.py
+++ b/tests/field_deconstruction/tests.py
@@ -432,6 +432,34 @@ def test_many_to_many_field_swapped(self):
         self.assertEqual(kwargs, {"to": "auth.Permission"})
         self.assertEqual(kwargs['to'].setting_name, "AUTH_USER_MODEL")
 
+    def test_many_to_many_field_related_name(self):
+        class MyModel(models.Model):
+            flag = models.BooleanField(default=True)
+            m2m = models.ManyToManyField('self')
+            m2m_related_name = models.ManyToManyField(
+                'self',
+                related_name='custom_name',
+                related_query_name='custom_query_name',
+                limit_choices_to={'flag': True},
+            )
+
+        name, path, args, kwargs = MyModel.m2m.field.deconstruct()
+        self.assertEqual(path, 'django.db.models.ManyToManyField')
+        self.assertEqual(args, [])
+        # deconstruct() should not include attributes which were not passed to
+        # the field during initialization.
+        self.assertEqual(kwargs, {'to': 'field_deconstruction.MyModel'})
+        # Passed attributes.
+        name, path, args, kwargs = MyModel.m2m_related_name.field.deconstruct()
+        self.assertEqual(path, 'django.db.models.ManyToManyField')
+        self.assertEqual(args, [])
+        self.assertEqual(kwargs, {
+            'to': 'field_deconstruction.MyModel',
+            'related_name': 'custom_name',
+            'related_query_name': 'custom_query_name',
+            'limit_choices_to': {'flag': True},
+        })
+
     def test_positive_integer_field(self):
         field = models.PositiveIntegerField()
         name, path, args, kwargs = field.deconstruct()
diff --git a/tests/schema/fields.py b/tests/schema/fields.py
--- a/tests/schema/fields.py
+++ b/tests/schema/fields.py
@@ -34,7 +34,12 @@ def __init__(self, to, db_constraint=True, swappable=True, related_name=None, re
         self.db_table = db_table
         if kwargs['rel'].through is not None:
             assert self.db_table is None, "Cannot specify a db_table if an intermediary model is used."
-        super().__init__(**kwargs)
+        super().__init__(
+            related_name=related_name,
+            related_query_name=related_query_name,
+            limit_choices_to=limit_choices_to,
+            **kwargs,
+        )
 
     def contribute_to_class(self, cls, name, **kwargs):
         if self.remote_field.symmetrical and (