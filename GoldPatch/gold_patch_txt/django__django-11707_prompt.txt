# 修复代码生成提示词（实例ID：django__django-11707）
## 代码仓库
django/django

## 原始问题描述
Pickling a QuerySet evaluates the querysets given to Subquery in annotate.
Description
	
I wrote a test case for tests/queryset_pickle/tests.py modeled after the test from bug #27499 which is very similar.
	def test_pickle_subquery_queryset_not_evaluated(self):
		"""
		Verifies that querysets passed into Subquery expressions
		are not evaluated when pickled
		"""
		groups = Group.objects.annotate(
			has_event=models.Exists(Event.objects.filter(group_id=models.OuterRef('id')))
		)
		with self.assertNumQueries(0):
			pickle.loads(pickle.dumps(groups.query))
The Subquery class (which is the base for Exists) only stores the underlying query object and throws the QuerySet away (as of this ​commit, although I don't think it worked before that). So in theory it shouldn't be pickling the QuerySet.
However, the QuerySet is still stored on the instance within the _constructor_args attribute added by the @deconstructible decorator on the BaseExpression base class. So when the inner query object gets pickled, so does the QuerySet, which attempts to evaluate it. In this case, it gets the error "ValueError: This queryset contains a reference to an outer query and may only be used in a subquery." since the inner queryset is being evaluated independently when called from pickle: it calls QuerySet.__getstate__().
I'm not sure what the best solution is here. I made a patch that adds the following override to __getstate__ to the SubQuery class, which fixes the problem and passes all other Django tests on my machine. I'll submit a PR shortly, but welcome any better approaches since I'm not sure what else that may effect.
class Subquery(Expression):
	...
	def __getstate__(self):
		obj_dict = super().__getstate__()
		obj_dict.pop('_constructor_args', None)
		return obj_dict


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py
--- a/tests/queryset_pickle/tests.py
+++ b/tests/queryset_pickle/tests.py
@@ -172,6 +172,41 @@ def test_pickle_prefetch_related_with_m2m_and_objects_deletion(self):
         m2ms = pickle.loads(pickle.dumps(m2ms))
         self.assertSequenceEqual(m2ms, [m2m])
 
+    def test_pickle_exists_queryset_still_usable(self):
+        group = Group.objects.create(name='group')
+        Event.objects.create(title='event', group=group)
+        groups = Group.objects.annotate(
+            has_event=models.Exists(
+                Event.objects.filter(group_id=models.OuterRef('id')),
+            ),
+        )
+        groups2 = pickle.loads(pickle.dumps(groups))
+        self.assertSequenceEqual(groups2.filter(has_event=True), [group])
+
+    def test_pickle_exists_queryset_not_evaluated(self):
+        group = Group.objects.create(name='group')
+        Event.objects.create(title='event', group=group)
+        groups = Group.objects.annotate(
+            has_event=models.Exists(
+                Event.objects.filter(group_id=models.OuterRef('id')),
+            ),
+        )
+        list(groups)  # evaluate QuerySet.
+        with self.assertNumQueries(0):
+            self.assert_pickles(groups)
+
+    def test_pickle_subquery_queryset_not_evaluated(self):
+        group = Group.objects.create(name='group')
+        Event.objects.create(title='event', group=group)
+        groups = Group.objects.annotate(
+            event_title=models.Subquery(
+                Event.objects.filter(group_id=models.OuterRef('id')).values('title'),
+            ),
+        )
+        list(groups)  # evaluate QuerySet.
+        with self.assertNumQueries(0):
+            self.assert_pickles(groups)
+
     def test_annotation_with_callable_default(self):
         # Happening.when has a callable default of datetime.datetime.now.
         qs = Happening.objects.annotate(latest_time=models.Max('when'))