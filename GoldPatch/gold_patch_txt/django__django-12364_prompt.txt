# 修复代码生成提示词（实例ID：django__django-12364）
## 代码仓库
django/django

## 原始问题描述
Detection of existing total ordering in admin changelist should take into account UniqueConstraints without conditions.
Description
	
I've been fiddling with db indexes lately to improve the performance of an admin view.
Eventually I found this PR ​https://github.com/django/django/pull/10692 which ensures the records displayed by ChangeList are deterministically ordered.
Among other things, the code looks for the presence of a unique_together attribute on the Meta class of the model to determine if the model is already totally ordered.
I think that _get_deterministic_ordering() should check for the presence of UniqueConstraints as well, which currently aren’t considered by the discovery algorithm.
I noticed the docs currently advise against using unique_together in favor of UniqueConstraint, suggesting the former may be deprecated in the future, so this fix would change that part of the code accordingly.
I'm willing to submit a PR for this.
Cheers,
Fabio


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py
--- a/tests/admin_changelist/tests.py
+++ b/tests/admin_changelist/tests.py
@@ -1039,10 +1039,6 @@ def get_queryset(self, request):
             (['field', '-other_field'], ['field', '-other_field']),
             # Composite unique nullable.
             (['-field', 'null_field'], ['-field', 'null_field', '-pk']),
-            # Composite unique nullable.
-            (['-field', 'null_field'], ['-field', 'null_field', '-pk']),
-            # Composite unique nullable.
-            (['-field', 'null_field'], ['-field', 'null_field', '-pk']),
             # Composite unique and nullable.
             (['-field', 'null_field', 'other_field'], ['-field', 'null_field', 'other_field']),
             # Composite unique attnames.
@@ -1062,6 +1058,98 @@ def get_queryset(self, request):
             with self.subTest(ordering=ordering):
                 self.assertEqual(change_list._get_deterministic_ordering(ordering), expected)
 
+    @isolate_apps('admin_changelist')
+    def test_total_ordering_optimization_meta_constraints(self):
+        class Related(models.Model):
+            unique_field = models.BooleanField(unique=True)
+
+            class Meta:
+                ordering = ('unique_field',)
+
+        class Model(models.Model):
+            field_1 = models.BooleanField()
+            field_2 = models.BooleanField()
+            field_3 = models.BooleanField()
+            field_4 = models.BooleanField()
+            field_5 = models.BooleanField()
+            field_6 = models.BooleanField()
+            nullable_1 = models.BooleanField(null=True)
+            nullable_2 = models.BooleanField(null=True)
+            related_1 = models.ForeignKey(Related, models.CASCADE)
+            related_2 = models.ForeignKey(Related, models.CASCADE)
+            related_3 = models.ForeignKey(Related, models.CASCADE)
+            related_4 = models.ForeignKey(Related, models.CASCADE)
+
+            class Meta:
+                constraints = [
+                    *[
+                        models.UniqueConstraint(fields=fields, name=''.join(fields))
+                        for fields in (
+                            ['field_1'],
+                            ['nullable_1'],
+                            ['related_1'],
+                            ['related_2_id'],
+                            ['field_2', 'field_3'],
+                            ['field_2', 'nullable_2'],
+                            ['field_2', 'related_3'],
+                            ['field_3', 'related_4_id'],
+                        )
+                    ],
+                    models.CheckConstraint(check=models.Q(id__gt=0), name='foo'),
+                    models.UniqueConstraint(
+                        fields=['field_5'],
+                        condition=models.Q(id__gt=10),
+                        name='total_ordering_1',
+                    ),
+                    models.UniqueConstraint(
+                        fields=['field_6'],
+                        condition=models.Q(),
+                        name='total_ordering',
+                    ),
+                ]
+
+        class ModelAdmin(admin.ModelAdmin):
+            def get_queryset(self, request):
+                return Model.objects.none()
+
+        request = self._mocked_authenticated_request('/', self.superuser)
+        site = admin.AdminSite(name='admin')
+        model_admin = ModelAdmin(Model, site)
+        change_list = model_admin.get_changelist_instance(request)
+        tests = (
+            # Unique non-nullable field.
+            (['field_1'], ['field_1']),
+            # Unique nullable field.
+            (['nullable_1'], ['nullable_1', '-pk']),
+            # Related attname unique.
+            (['related_1_id'], ['related_1_id']),
+            (['related_2_id'], ['related_2_id']),
+            # Related ordering introspection is not implemented.
+            (['related_1'], ['related_1', '-pk']),
+            # Composite unique.
+            (['-field_2', 'field_3'], ['-field_2', 'field_3']),
+            # Composite unique nullable.
+            (['field_2', '-nullable_2'], ['field_2', '-nullable_2', '-pk']),
+            # Composite unique and nullable.
+            (
+                ['field_2', '-nullable_2', 'field_3'],
+                ['field_2', '-nullable_2', 'field_3'],
+            ),
+            # Composite field and related field name.
+            (['field_2', '-related_3'], ['field_2', '-related_3', '-pk']),
+            (['field_3', 'related_4'], ['field_3', 'related_4', '-pk']),
+            # Composite field and related field attname.
+            (['field_2', 'related_3_id'], ['field_2', 'related_3_id']),
+            (['field_3', '-related_4_id'], ['field_3', '-related_4_id']),
+            # Partial unique constraint is ignored.
+            (['field_5'], ['field_5', '-pk']),
+            # Unique constraint with an empty condition.
+            (['field_6'], ['field_6']),
+        )
+        for ordering, expected in tests:
+            with self.subTest(ordering=ordering):
+                self.assertEqual(change_list._get_deterministic_ordering(ordering), expected)
+
     def test_dynamic_list_filter(self):
         """
         Regression tests for ticket #17646: dynamic list_filter support.