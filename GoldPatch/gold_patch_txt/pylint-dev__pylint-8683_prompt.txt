# 修复代码生成提示词（实例ID：pylint-dev__pylint-8683）
## 代码仓库
pylint-dev/pylint

## 原始问题描述
fail/warn on using parallel execution with custom plugins
According to documentation:
http://pylint.pycqa.org/en/latest/user_guide/run.html#parallel-execution

> There are some limitations in running checks in parallel in the current implementation. It is not possible to use custom plugins (i.e. --load-plugins option)...

Actually, it is possible but silently broken.
`If this is still by design` then Pylint should inform a user about it in such cases.
As for now, I could run:
```
pylint -j 10 --load-plugins plugin_foo bar.py
```
without any warning or error.
Unfortunately, linting results are not the same as a single process linting, but Pylint silently pass. So, results are not predictable.

Proposal: emit a warning or better explicitly fail on using parallel execution with custom Pylint plugins, because people usually don't read the documentation while things works.




## 参考黄金补丁（正确的修复方案）
diff --git a/tests/test_check_parallel.py b/tests/test_check_parallel.py
--- a/tests/test_check_parallel.py
+++ b/tests/test_check_parallel.py
@@ -14,10 +14,11 @@
 from concurrent.futures import ProcessPoolExecutor
 from concurrent.futures.process import BrokenProcessPool
 from pickle import PickleError
+from typing import TYPE_CHECKING
+from unittest.mock import patch
 
 import dill
 import pytest
-from astroid import nodes
 
 import pylint.interfaces
 import pylint.lint.parallel
@@ -30,6 +31,9 @@
 from pylint.typing import FileItem
 from pylint.utils import LinterStats, ModuleStats
 
+if TYPE_CHECKING:
+    from astroid import nodes
+
 
 def _gen_file_data(idx: int = 0) -> FileItem:
     """Generates a file to use as a stream."""
@@ -182,6 +186,17 @@ def test_worker_initialize_with_package_paths(self) -> None:
             )
             assert "fake-path" in sys.path
 
+    def test_worker_initialize_reregisters_custom_plugins(self) -> None:
+        linter = PyLinter(reporter=Reporter())
+        linter.load_plugin_modules(["pylint.extensions.private_import"])
+
+        pickled = dill.dumps(linter)
+        with patch(
+            "pylint.extensions.private_import.register", side_effect=AssertionError
+        ):
+            with pytest.raises(AssertionError):
+                worker_initialize(linter=pickled)
+
     @pytest.mark.needs_two_cores
     def test_worker_initialize_pickling(self) -> None:
         """Test that we can pickle objects that standard pickling in multiprocessing can't.