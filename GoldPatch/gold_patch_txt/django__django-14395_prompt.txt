# 修复代码生成提示词（实例ID：django__django-14395）
## 代码仓库
django/django

## 原始问题描述
CacheHandler initialize unused caches.
Description
	
After the commit: ​https://github.com/django/django/commit/98e05ccde440cc9b768952cc10bc8285f4924e1f 
logic of the method "all" from CacheHandler class was changed. 
Before: 
	def all(self):
		return getattr(self._caches, 'caches', {}).values()
This method returned connections that were created in __getitem__
Now:
	def all(self):
		return [self[alias] for alias in self]
Connections return for all "CACHES" from settings.py (in case of absence - they are forcibly created in self[alias])
Which version of this method seems to be right? 
In my case this unnecessary mass initialization of custom diskcache-classes leads to io-lags.
Snippet that helped me:
import django.core.cache
def cache_getitem(self, alias, exists_only=False):
	try:
		return getattr(self._connections, alias)
	except AttributeError:
		if alias not in self.settings:
			raise self.exception_class(f"The connection '{alias}' doesn't exist.")
		if exists_only:
			return
	conn = self.create_connection(alias)
	setattr(self._connections, alias, conn)
	return conn
def cache_all(self):
	connections = [self.__getitem__(alias, exists_only=True) for alias in self]
	return [conn for conn in connections if conn is not None]
django.core.cache.CacheHandler.all = cache_all
django.core.cache.CacheHandler.__getitem__ = cache_getitem


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/cache/tests.py b/tests/cache/tests.py
--- a/tests/cache/tests.py
+++ b/tests/cache/tests.py
@@ -1723,6 +1723,19 @@ def test_close(self):
         signals.request_finished.send(self.__class__)
         self.assertTrue(cache.closed)
 
+    def test_close_only_initialized(self):
+        with self.settings(CACHES={
+            'cache_1': {
+                'BACKEND': 'cache.closeable_cache.CacheClass',
+            },
+            'cache_2': {
+                'BACKEND': 'cache.closeable_cache.CacheClass',
+            },
+        }):
+            self.assertEqual(caches.all(initialized_only=True), [])
+            signals.request_finished.send(self.__class__)
+            self.assertEqual(caches.all(initialized_only=True), [])
+
 
 DEFAULT_MEMORY_CACHES_SETTINGS = {
     'default': {
@@ -2625,3 +2638,20 @@ def test_nonexistent_backend(self):
         )
         with self.assertRaisesMessage(InvalidCacheBackendError, msg):
             test_caches['invalid_backend']
+
+    def test_all(self):
+        test_caches = CacheHandler({
+            'cache_1': {
+                'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
+            },
+            'cache_2': {
+                'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
+            },
+        })
+        self.assertEqual(test_caches.all(initialized_only=True), [])
+        cache_1 = test_caches['cache_1']
+        self.assertEqual(test_caches.all(initialized_only=True), [cache_1])
+        self.assertEqual(len(test_caches.all()), 2)
+        # .all() initializes all caches.
+        self.assertEqual(len(test_caches.all(initialized_only=True)), 2)
+        self.assertEqual(test_caches.all(), test_caches.all(initialized_only=True))