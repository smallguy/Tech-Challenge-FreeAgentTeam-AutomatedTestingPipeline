# 修复代码生成提示词（实例ID：scikit-learn__scikit-learn-14464）
## 代码仓库
scikit-learn/scikit-learn

## 原始问题描述
Cloning custom transform replaces values in __init__ dictionary
<!--
If your issue is a usage question, submit it here instead:
- StackOverflow with the scikit-learn tag: https://stackoverflow.com/questions/tagged/scikit-learn
- Mailing List: https://mail.python.org/mailman/listinfo/scikit-learn
For more information, see User Questions: http://scikit-learn.org/stable/support.html#user-questions
-->

<!-- Instructions For Filing a Bug: https://github.com/scikit-learn/scikit-learn/blob/master/CONTRIBUTING.md#filing-bugs -->

#### Description
<!-- Example: Joblib Error thrown when calling fit on LatentDirichletAllocation with evaluate_every > 0-->
Let us say we have a custom transform `A` that has some arguments. When the `A` is instantiated, these arguments are set in the init. 

When we clone `A` (as happens in `cross_val_score`, for example), the arguments get copied successfully. 

However, if the arguments are sent to a structure such as a dictionary, the clone replaces them with None.  

In cases where None does not cause errors, this creates a silent error, as the cloned version of `A` will run, producing different results from its original version (which is how I ran into this problem in the first place). 

Fully replicable example follows. 

#### Steps/Code to Reproduce
```
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.base import clone


class MyTransformA(BaseEstimator, TransformerMixin):
    
    def __init__(self, n_cols_to_keep):
        self.cols_to_keep_dict = {'n_cols': n_cols_to_keep}  
    
    def fit(self, X, *_):
        return self 
        
    def transform(self, X, *_):
        return X
    
    
class MyTransformB(BaseEstimator, TransformerMixin):

    def __init__(self, n_cols_to_keep):
        self.n_cols_to_keep = n_cols_to_keep  # <--- this time we save the input immediately 
        self.cols_to_keep_dict = {'n_cols': self.n_cols_to_keep}  
    
    def fit(self, X, *_):
        return self 
        
    def transform(self, X, *_):
        return X

my_transform_a = MyTransformA(n_cols_to_keep=5)
my_transform_a_clone = clone(my_transform_a)

my_transform_b = MyTransformB(n_cols_to_keep=5)
my_transform_b_clone = clone(my_transform_b)

print('Using MyTransformA:')
print('  my_transform_a.cols_to_keep_dict:        %s' % str(my_transform_a.cols_to_keep_dict))
print('  my_transform_a_clone.cols_to_keep_dict:  %s  <------ ?' % str(my_transform_a_clone.cols_to_keep_dict))

print('\nUsing MyTransformB:')
print('  my_transform_b.cols_to_keep_dict:        %s' % str(my_transform_b.cols_to_keep_dict))
print('  my_transform_b_clone.cols_to_keep_dict): %s' % str(my_transform_b_clone.cols_to_keep_dict))
```
#### Expected Results
```
Using MyTransformA:
  my_transform_a.cols_to_keep_dict:        ('n_cols', 5)
  my_transform_a_clone.cols_to_keep_dict:  ('n_cols', 5)  <------ Does not happen

Using MyTransformB:
  my_transform_b.cols_to_keep_dict:        {'n_cols': 5}
  my_transform_b_clone.cols_to_keep_dict): {'n_cols': 5}
```
#### Actual Results
```
Using MyTransformA:
  my_transform_a.cols_to_keep_dict:        ('n_cols', 5)
  my_transform_a_clone.cols_to_keep_dict:  ('n_cols', None)  <------ ?

Using MyTransformB:
  my_transform_b.cols_to_keep_dict:        {'n_cols': 5}
  my_transform_b_clone.cols_to_keep_dict): {'n_cols': 5}
```

#### Versions
```
System:
    python: 3.7.3 (default, Mar 27 2019, 16:54:48)  [Clang 4.0.1 (tags/RELEASE_401/final)]
executable: /anaconda3/bin/python
   machine: Darwin-18.6.0-x86_64-i386-64bit

BLAS:
    macros: SCIPY_MKL_H=None, HAVE_CBLAS=None
  lib_dirs: /anaconda3/lib
cblas_libs: mkl_rt, pthread

Python deps:
       pip: 19.0.3
setuptools: 40.8.0
   sklearn: 0.20.3
     numpy: 1.16.2
     scipy: 1.2.1
    Cython: 0.29.6
    pandas: 0.24.2
Python 3.7.3 (default, Mar 27 2019, 16:54:48) 
[Clang 4.0.1 (tags/RELEASE_401/final)]
NumPy 1.16.2
SciPy 1.2.1
Scikit-Learn 0.20.3
```

<!-- Thanks for contributing! -->



## 参考黄金补丁（正确的修复方案）
diff --git a/sklearn/gaussian_process/tests/test_kernels.py b/sklearn/gaussian_process/tests/test_kernels.py
--- a/sklearn/gaussian_process/tests/test_kernels.py
+++ b/sklearn/gaussian_process/tests/test_kernels.py
@@ -14,7 +14,7 @@
 from sklearn.gaussian_process.kernels \
     import (RBF, Matern, RationalQuadratic, ExpSineSquared, DotProduct,
             ConstantKernel, WhiteKernel, PairwiseKernel, KernelOperator,
-            Exponentiation)
+            Exponentiation, Kernel)
 from sklearn.base import clone
 
 from sklearn.utils.testing import (assert_almost_equal,
@@ -323,3 +323,24 @@ def test_repr_kernels(kernel):
     # Smoke-test for repr in kernels.
 
     repr(kernel)
+
+
+def test_warns_on_get_params_non_attribute():
+    class MyKernel(Kernel):
+        def __init__(self, param=5):
+            pass
+
+        def __call__(self, X, Y=None, eval_gradient=False):
+            return X
+
+        def diag(self, X):
+            return np.ones(X.shape[0])
+
+        def is_stationary(self):
+            return False
+
+    est = MyKernel()
+    with pytest.warns(FutureWarning, match='AttributeError'):
+        params = est.get_params()
+
+    assert params['param'] is None
diff --git a/sklearn/tests/test_base.py b/sklearn/tests/test_base.py
--- a/sklearn/tests/test_base.py
+++ b/sklearn/tests/test_base.py
@@ -505,3 +505,18 @@ def test_regressormixin_score_multioutput():
            "built-in scorer 'r2' uses "
            "multioutput='uniform_average').")
     assert_warns_message(FutureWarning, msg, reg.score, X, y)
+
+
+def test_warns_on_get_params_non_attribute():
+    class MyEstimator(BaseEstimator):
+        def __init__(self, param=5):
+            pass
+
+        def fit(self, X, y=None):
+            return self
+
+    est = MyEstimator()
+    with pytest.warns(FutureWarning, match='AttributeError'):
+        params = est.get_params()
+
+    assert params['param'] is None