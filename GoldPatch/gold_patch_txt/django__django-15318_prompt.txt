# 修复代码生成提示词（实例ID：django__django-15318）
## 代码仓库
django/django

## 原始问题描述
Unify reverse foreign key and m2m unsaved model querying
Description
	
Currently when querying unsaved reverse relations the behavior differs.
Using model:
class Foo(models.Model):
	fk = models.ForeignKey('self', related_name='fk_rev')
	m2m = models.ManyToManyField('self')
and test case:
print(Foo().fk_rev.all())
print(Foo().m2m.all())
We get [] from the first filter, but an error
ValueError: "<Foo: Foo object>" needs to have a value for field "from_foo" before this many-to-many relationship can be used.
from the second filter.
So, m2m fields can't be filtered if the object isn't saved, but reverse fk fields can be filtered.
There is a (slightly stale) patch for #17541 which makes fk fields and m2m fields work consistently. The changes in behavior are:
* Nullable many-to-many and foreign key relations will return an empty
 queryset when the relation field is null. For many-to-many this was
 previously an error (no change for foreign keys).
* Trying to add objects to a foreign key relation when the relation field
 is null is now an error (no change for m2m).
* Trying to use a relation of any kind when the object isn't saved is now
 an error (no change for m2m).
I think we can squeeze these changes in as bug-fixes. These are slight backwards compatibility changes, but to me it seems that almost always the changes will be visible only in code that isn't working as intended. If these are seen as something likely breaking working code, then I don't see any way to make the APIs consistent.
The #17541 patch is available from: ​https://github.com/akaariai/django/compare/ticket_17541


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py
--- a/tests/many_to_one/tests.py
+++ b/tests/many_to_one/tests.py
@@ -738,14 +738,16 @@ def test_fk_instantiation_outside_model(self):
         self.assertEqual("id", cat.remote_field.get_related_field().name)
 
     def test_relation_unsaved(self):
-        # The <field>_set manager does not join on Null value fields (#17541)
         Third.objects.create(name="Third 1")
         Third.objects.create(name="Third 2")
         th = Third(name="testing")
-        # The object isn't saved and thus the relation field is null - we won't even
-        # execute a query in this case.
-        with self.assertNumQueries(0):
-            self.assertEqual(th.child_set.count(), 0)
+        # The object isn't saved and the relation cannot be used.
+        msg = (
+            "'Third' instance needs to have a primary key value before this "
+            "relationship can be used."
+        )
+        with self.assertRaisesMessage(ValueError, msg):
+            th.child_set.count()
         th.save()
         # Now the model is saved, so we will need to execute a query.
         with self.assertNumQueries(1):
diff --git a/tests/many_to_one_null/tests.py b/tests/many_to_one_null/tests.py
--- a/tests/many_to_one_null/tests.py
+++ b/tests/many_to_one_null/tests.py
@@ -146,3 +146,36 @@ def test_related_null_to_field(self):
         self.assertIs(d1.car, None)
         with self.assertNumQueries(0):
             self.assertEqual(list(c1.drivers.all()), [])
+
+    def test_unsaved(self):
+        msg = (
+            "'Car' instance needs to have a primary key value before this relationship "
+            "can be used."
+        )
+        with self.assertRaisesMessage(ValueError, msg):
+            Car(make="Ford").drivers.all()
+
+    def test_related_null_to_field_related_managers(self):
+        car = Car.objects.create(make=None)
+        driver = Driver.objects.create()
+        msg = (
+            f'"{car!r}" needs to have a value for field "make" before this '
+            f"relationship can be used."
+        )
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.add(driver)
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.create()
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.get_or_create()
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.update_or_create()
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.remove(driver)
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.clear()
+        with self.assertRaisesMessage(ValueError, msg):
+            car.drivers.set([driver])
+
+        with self.assertNumQueries(0):
+            self.assertEqual(car.drivers.count(), 0)
diff --git a/tests/null_queries/tests.py b/tests/null_queries/tests.py
--- a/tests/null_queries/tests.py
+++ b/tests/null_queries/tests.py
@@ -44,9 +44,14 @@ def test_none_as_null(self):
         with self.assertRaisesMessage(ValueError, "Cannot use None as a query value"):
             Choice.objects.filter(id__gt=None)
 
-        # Related managers use __exact=None implicitly if the object hasn't been saved.
-        p2 = Poll(question="How?")
-        self.assertEqual(repr(p2.choice_set.all()), "<QuerySet []>")
+    def test_unsaved(self):
+        poll = Poll(question="How?")
+        msg = (
+            "'Poll' instance needs to have a primary key value before this "
+            "relationship can be used."
+        )
+        with self.assertRaisesMessage(ValueError, msg):
+            poll.choice_set.all()
 
     def test_reverse_relations(self):
         """