# 修复代码生成提示词（实例ID：django__django-14495）
## 代码仓库
django/django

## 原始问题描述
KeyError when trying to migrate backward to a replaced migration
Description
	
Django exhibits some internal confusion regarding whether replaced migrations exist or not. Consider this simple app with two migrations and squashed migration replacing both:
$ ls testproj/migrations/
0001_initial.py 0001_squashed_0002_thing_age.py 0002_thing_age.py __init__.py
When it comes to disambiguating input, Django seems to believe that the replaced migrations still need to be considered:
$ ./manage.py migrate testproj 0001
CommandError: More than one migration matches '0001' in app 'testproj'. Please be more specific.
But if you actually try to disambiguate and specify one of the replaced migrations, Django no longer thinks it exists (and isn't very graceful about telling you so):
$ ./manage.py migrate testproj 0001_initial
Traceback (most recent call last):
 File "./manage.py", line 10, in <module>
	execute_from_command_line(sys.argv)
 File "/home/carljm/projects/django/django/django/django/core/management/__init__.py", line 330, in execute_from_command_line
	utility.execute()
 File "/home/carljm/projects/django/django/django/django/core/management/__init__.py", line 322, in execute
	self.fetch_command(subcommand).run_from_argv(self.argv)
 File "/home/carljm/projects/django/django/django/django/core/management/base.py", line 347, in run_from_argv
	self.execute(*args, **cmd_options)
 File "/home/carljm/projects/django/django/django/django/core/management/base.py", line 398, in execute
	output = self.handle(*args, **options)
 File "/home/carljm/projects/django/django/django/django/core/management/commands/migrate.py", line 135, in handle
	plan = executor.migration_plan(targets)
 File "/home/carljm/projects/django/django/django/django/db/migrations/executor.py", line 50, in migration_plan
	self.loader.graph.node_map[target].children
KeyError: ('testproj', '0001_initial')
There could be several different approaches to fixing this, but my feeling is that Django shouldn't prevent you from migrating to a replaced migration. If a migration still exists on disk, even if it's been squashed and you've fully migrated the squashed set, you should be able to migrate back to a state within the squashed set. It seems like there might be production rollback cases where that could be important, and I don't see in principle why it shouldn't be possible.
If that turns out to be impractical, then I think Django oughtn't bother you about resolving ambiguities with migration names it won't let you migrate to anyway. And the "nonexistent" error for this case should be nicer than a raw KeyError. (In Django 1.7 the error was "ValueError: Node ('testproj17', '0001_initial') not a valid node", which is perhaps a bit better, but not much.)


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py
--- a/tests/migrations/test_commands.py
+++ b/tests/migrations/test_commands.py
@@ -980,6 +980,19 @@ def test_migrate_partially_applied_squashed_migration(self):
                 # Unmigrate everything.
                 call_command('migrate', 'migrations', 'zero', verbosity=0)
 
+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})
+    def test_migrate_backward_to_squashed_migration(self):
+        try:
+            call_command('migrate', 'migrations', '0001_squashed_0002', verbosity=0)
+            self.assertTableExists('migrations_author')
+            self.assertTableExists('migrations_book')
+            call_command('migrate', 'migrations', '0001_initial', verbosity=0)
+            self.assertTableExists('migrations_author')
+            self.assertTableNotExists('migrations_book')
+        finally:
+            # Unmigrate everything.
+            call_command('migrate', 'migrations', 'zero', verbosity=0)
+
     @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
     def test_migrate_inconsistent_history(self):
         """
diff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py
--- a/tests/migrations/test_executor.py
+++ b/tests/migrations/test_executor.py
@@ -104,6 +104,29 @@ def test_run_with_squashed(self):
         self.assertTableNotExists("migrations_author")
         self.assertTableNotExists("migrations_book")
 
+    @override_settings(
+        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'},
+    )
+    def test_migrate_backward_to_squashed_migration(self):
+        executor = MigrationExecutor(connection)
+        try:
+            self.assertTableNotExists('migrations_author')
+            self.assertTableNotExists('migrations_book')
+            executor.migrate([('migrations', '0001_squashed_0002')])
+            self.assertTableExists('migrations_author')
+            self.assertTableExists('migrations_book')
+            executor.loader.build_graph()
+            # Migrate backward to a squashed migration.
+            executor.migrate([('migrations', '0001_initial')])
+            self.assertTableExists('migrations_author')
+            self.assertTableNotExists('migrations_book')
+        finally:
+            # Unmigrate everything.
+            executor = MigrationExecutor(connection)
+            executor.migrate([('migrations', None)])
+            self.assertTableNotExists('migrations_author')
+            self.assertTableNotExists('migrations_book')
+
     @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_non_atomic"})
     def test_non_atomic_migration(self):
         """
@@ -733,6 +756,7 @@ class FakeLoader:
     def __init__(self, graph, applied):
         self.graph = graph
         self.applied_migrations = applied
+        self.replace_migrations = True
 
 
 class FakeMigration:
diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py
--- a/tests/migrations/test_loader.py
+++ b/tests/migrations/test_loader.py
@@ -485,6 +485,27 @@ def test_loading_squashed_ref_squashed(self):
         }
         self.assertEqual(plan, expected_plan)
 
+        # Load with nothing applied and migrate to a replaced migration.
+        # Not possible if loader.replace_migrations is True (default).
+        loader.build_graph()
+        msg = "Node ('app1', '3_auto') not a valid node"
+        with self.assertRaisesMessage(NodeNotFoundError, msg):
+            loader.graph.forwards_plan(('app1', '3_auto'))
+        # Possible if loader.replace_migrations is False.
+        loader.replace_migrations = False
+        loader.build_graph()
+        plan = set(loader.graph.forwards_plan(('app1', '3_auto')))
+        plan = plan - loader.applied_migrations.keys()
+        expected_plan = {
+            ('app1', '1_auto'),
+            ('app2', '1_auto'),
+            ('app2', '2_auto'),
+            ('app1', '2_auto'),
+            ('app1', '3_auto'),
+        }
+        self.assertEqual(plan, expected_plan)
+        loader.replace_migrations = True
+
         # Fake-apply a few from app1: unsquashes migration in app1.
         self.record_applied(recorder, 'app1', '1_auto')
         self.record_applied(recorder, 'app1', '2_auto')