# 修复代码生成提示词（实例ID：django__django-13484）
## 代码仓库
django/django

## 原始问题描述
Queryset crashes when recreated from a pickled query with FilteredRelation used in aggregation.
Description
	
I am pickling query objects (queryset.query) for later re-evaluation as per ​https://docs.djangoproject.com/en/2.2/ref/models/querysets/#pickling-querysets. However, when I tried to rerun a query that contains a FilteredRelation inside a filter, I get an psycopg2.errors.UndefinedTable: missing FROM-clause entry for table "t3" error.
I created a minimum reproducible example.
models.py
from django.db import models
class Publication(models.Model):
	title = models.CharField(max_length=64)
class Session(models.Model):
	TYPE_CHOICES = (('A', 'A'), ('B', 'B'))
	publication = models.ForeignKey(Publication, on_delete=models.CASCADE)
	session_type = models.CharField(choices=TYPE_CHOICES, default='A', max_length=1)
	place = models.CharField(max_length=16)
	value = models.PositiveIntegerField(default=1)
The actual code to cause the crash:
import pickle
from django.db.models import FilteredRelation, Q, Sum
from django_error.models import Publication, Session
p1 = Publication.objects.create(title='Foo')
p2 = Publication.objects.create(title='Bar')
Session.objects.create(publication=p1, session_type='A', place='X', value=1)
Session.objects.create(publication=p1, session_type='B', place='X', value=2)
Session.objects.create(publication=p2, session_type='A', place='X', value=4)
Session.objects.create(publication=p2, session_type='B', place='X', value=8)
Session.objects.create(publication=p1, session_type='A', place='Y', value=1)
Session.objects.create(publication=p1, session_type='B', place='Y', value=2)
Session.objects.create(publication=p2, session_type='A', place='Y', value=4)
Session.objects.create(publication=p2, session_type='B', place='Y', value=8)
qs = Publication.objects.all().annotate(
	relevant_sessions=FilteredRelation('session', condition=Q(session__session_type='A'))
).annotate(x=Sum('relevant_sessions__value'))
# just print it out to make sure the query works
print(list(qs))
qs2 = Publication.objects.all()
qs2.query = pickle.loads(pickle.dumps(qs.query))
# the following crashes with an error
#	 psycopg2.errors.UndefinedTable: missing FROM-clause entry for table "t3"
#	 LINE 1: ...n"."id" = relevant_sessions."publication_id" AND (T3."sessio...
print(list(qs2))
In the crashing query, there seems to be a difference in the table_map attribute - this is probably where the t3 table is coming from.
Please let me know if there is any more info required for hunting this down.
Cheers
Beda
p.s.- I also tried in Django 3.1 and the behavior is the same.
p.p.s.- just to make sure, I am not interested in ideas on how to rewrite the query - the above is a very simplified version of what I use, so it would probably not be applicable anyway.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py
--- a/tests/queryset_pickle/tests.py
+++ b/tests/queryset_pickle/tests.py
@@ -219,6 +219,40 @@ def test_pickle_subquery_queryset_not_evaluated(self):
         with self.assertNumQueries(0):
             self.assert_pickles(groups)
 
+    def test_pickle_filteredrelation(self):
+        group = Group.objects.create(name='group')
+        event_1 = Event.objects.create(title='Big event', group=group)
+        event_2 = Event.objects.create(title='Small event', group=group)
+        Happening.objects.bulk_create([
+            Happening(event=event_1, number1=5),
+            Happening(event=event_2, number1=3),
+        ])
+        groups = Group.objects.annotate(
+            big_events=models.FilteredRelation(
+                'event',
+                condition=models.Q(event__title__startswith='Big'),
+            ),
+        ).annotate(sum_number=models.Sum('big_events__happening__number1'))
+        groups_query = pickle.loads(pickle.dumps(groups.query))
+        groups = Group.objects.all()
+        groups.query = groups_query
+        self.assertEqual(groups.get().sum_number, 5)
+
+    def test_pickle_filteredrelation_m2m(self):
+        group = Group.objects.create(name='group')
+        m2mmodel = M2MModel.objects.create()
+        m2mmodel.groups.add(group)
+        groups = Group.objects.annotate(
+            first_m2mmodels=models.FilteredRelation(
+                'm2mmodel',
+                condition=models.Q(m2mmodel__pk__lt=10),
+            ),
+        ).annotate(count_groups=models.Count('first_m2mmodels__groups'))
+        groups_query = pickle.loads(pickle.dumps(groups.query))
+        groups = Group.objects.all()
+        groups.query = groups_query
+        self.assertEqual(groups.get().count_groups, 1)
+
     def test_annotation_with_callable_default(self):
         # Happening.when has a callable default of datetime.datetime.now.
         qs = Happening.objects.annotate(latest_time=models.Max('when'))