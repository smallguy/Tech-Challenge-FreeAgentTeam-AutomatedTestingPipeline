# 修复代码生成提示词（实例ID：django__django-16952）
## 代码仓库
django/django

## 原始问题描述
Creating objects with nested MTI crashes.
Description
	 
		(last modified by Mariusz Felisiak)
	 
Checking ​PR I noticed that creating objects with more complicated multi-table inheritance crashes. For example:
tests/model_inheritance/models.py
diff --git a/tests/model_inheritance/models.py b/tests/model_inheritance/models.py
index dc0e238f7e..d75df0d533 100644
					
					 a
				 
					
					 b
				 
 class ItalianRestaurant(Restaurant): 
106106    serves_gnocchi = models.BooleanField(default=False)
107107
108108
 109class ItalianRestaurantManyParents(ItalianRestaurant, Place):
 110    pass
 111
 112
109113class Supplier(Place):
110114    customers = models.ManyToManyField(Restaurant, related_name="provider")
111115
tests/model_inheritance/tests.py
diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py
index 4542e6c3cc..838d35b9d6 100644
					
					 a
				 
					
					 b
				 
 from .models import ( 
1414    GrandChild,
1515    GrandParent,
1616    ItalianRestaurant,
 17    ItalianRestaurantManyParents,
1718    MixinModel,
1819    Parent,
1920    ParkingLot,
…
…
 class ModelInheritanceTests(TestCase): 
149150        # accidentally found).
150151        self.assertSequenceEqual(s.titles.all(), [])
151152
 153    def test_create_diamond_mti_common_parents(self):
 154        with self.assertNumQueries(4):
 155            ItalianRestaurantManyParents.objects.create(
 156                name="Ristorante Miron",
 157                address="1234 W. Ash",
 158            )
 159
152160    def test_update_parent_filtering(self):
153161        """
154162        Updating a field of a model subclass doesn't issue an UPDATE
crashes with:
 File "/django/tests/model_inheritance/tests.py", line 155, in test_create_diamond_mti_common_parents
	ItalianRestaurantManyParents.objects.create(
 File "/django/django/db/models/manager.py", line 87, in manager_method
	return getattr(self.get_queryset(), name)(*args, **kwargs)
 File "/django/django/db/models/query.py", line 650, in create
	obj.save(force_insert=True, using=self.db)
 File "/django/django/db/models/base.py", line 814, in save
	self.save_base(
 File "/django/django/db/models/base.py", line 876, in save_base
	parent_inserted = self._save_parents(cls, using, update_fields)
 File "/django/django/db/models/base.py", line 928, in _save_parents
	setattr(self, field.attname, self._get_pk_val(parent._meta))
AttributeError: 'OneToOneField' object has no attribute 'attname'


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py
--- a/tests/invalid_models_tests/test_models.py
+++ b/tests/invalid_models_tests/test_models.py
@@ -1070,6 +1070,31 @@ class GrandChild(Child):
             ],
         )
 
+    def test_diamond_mti_common_parent(self):
+        class GrandParent(models.Model):
+            pass
+
+        class Parent(GrandParent):
+            pass
+
+        class Child(Parent):
+            pass
+
+        class MTICommonParentModel(Child, GrandParent):
+            pass
+
+        self.assertEqual(
+            MTICommonParentModel.check(),
+            [
+                Error(
+                    "The field 'grandparent_ptr' clashes with the field "
+                    "'grandparent_ptr' from model 'invalid_models_tests.parent'.",
+                    obj=MTICommonParentModel,
+                    id="models.E006",
+                )
+            ],
+        )
+
     def test_id_clash(self):
         class Target(models.Model):
             pass
diff --git a/tests/model_inheritance/models.py b/tests/model_inheritance/models.py
--- a/tests/model_inheritance/models.py
+++ b/tests/model_inheritance/models.py
@@ -106,6 +106,12 @@ class ItalianRestaurant(Restaurant):
     serves_gnocchi = models.BooleanField(default=False)
 
 
+class ItalianRestaurantCommonParent(ItalianRestaurant, Place):
+    place_ptr_two = models.OneToOneField(
+        Place, on_delete=models.CASCADE, parent_link=True
+    )
+
+
 class Supplier(Place):
     customers = models.ManyToManyField(Restaurant, related_name="provider")
 
diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py
--- a/tests/model_inheritance/tests.py
+++ b/tests/model_inheritance/tests.py
@@ -15,6 +15,7 @@
     GrandChild,
     GrandParent,
     ItalianRestaurant,
+    ItalianRestaurantCommonParent,
     MixinModel,
     Parent,
     ParkingLot,
@@ -158,6 +159,28 @@ def test_create_diamond_mti_default_pk(self):
         with self.assertNumQueries(4):
             common_child.save()
 
+    def test_create_diamond_mti_common_parent(self):
+        with self.assertNumQueries(4):
+            italian_restaurant_child = ItalianRestaurantCommonParent.objects.create(
+                name="Ristorante Miron",
+                address="1234 W. Ash",
+            )
+
+        self.assertEqual(
+            italian_restaurant_child.italianrestaurant_ptr.place_ptr,
+            italian_restaurant_child.place_ptr_two,
+        )
+        self.assertEqual(
+            italian_restaurant_child.italianrestaurant_ptr.restaurant_ptr,
+            italian_restaurant_child.restaurant_ptr,
+        )
+        self.assertEqual(
+            italian_restaurant_child.restaurant_ptr.place_ptr,
+            italian_restaurant_child.place_ptr_two,
+        )
+        self.assertEqual(italian_restaurant_child.name, "Ristorante Miron")
+        self.assertEqual(italian_restaurant_child.address, "1234 W. Ash")
+
     def test_update_parent_filtering(self):
         """
         Updating a field of a model subclass doesn't issue an UPDATE