# 修复代码生成提示词（实例ID：django__django-13553）
## 代码仓库
django/django

## 原始问题描述
QuerySet.order_by() crashes on union() queryset with a single non-empty query.
Description
	 
		(last modified by Hannes Ljungberg)
	 
I noticed this error while implementing a dynamic union like this:
union = reduce(
	lambda qs1, qs2: qs1.union(qs2),
	querysets,
	queryset.none(),
)
If len(querysets) == 1 it will result in a pretty weird query throwing a database error when both querysets are ordered, another example recreating this in the test suite:
qs1 = Number.objects.all().order_by(‘pk’)
qs2 = Number.objects.none().union(qs1).order_by(‘pk’)
Executing qs2 result in the following query:
(SELECT "queries_number"."id", "queries_number"."num", "queries_number"."other_num", "queries_number"."another_num" FROM "queries_number" ORDER BY "queries_number"."id" ASC) ORDER BY (1) ASC
Result in the following error on PostgresSQL:
psycopg2.errors.SyntaxError: multiple ORDER BY clauses not allowed
LINE 1: ...umber" ORDER BY "queries_number"."id" DESC) ORDER BY (1) ASC
And sqlite:
django.db.utils.DatabaseError: ORDER BY not allowed in subqueries of compound statements.
MySQL seems to accept this query but it's most likely not the query the user expects the be executed.
My proposal is to simply return the non-empty query and make the union a no-op set in this case.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -106,6 +106,11 @@ def test_union_with_empty_qs(self):
         self.assertEqual(len(qs2.union(qs2)), 0)
         self.assertEqual(len(qs3.union(qs3)), 0)
 
+    def test_empty_qs_union_with_ordered_qs(self):
+        qs1 = Number.objects.all().order_by('num')
+        qs2 = Number.objects.none().union(qs1).order_by('num')
+        self.assertEqual(list(qs1), list(qs2))
+
     def test_limits(self):
         qs1 = Number.objects.all()
         qs2 = Number.objects.all()