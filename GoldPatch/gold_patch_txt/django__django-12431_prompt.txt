# 修复代码生成提示词（实例ID：django__django-12431）
## 代码仓库
django/django

## 原始问题描述
FileResponse with temporary file closing connection.
Description
	 
		(last modified by Oskar Persson)
	 
I think I might've found a regression in #30565. When I run the following tests (in their defined order) against Postgres I get the error below.
import tempfile
from django.contrib.auth import get_user_model
from django.http import FileResponse
from django.test import TestCase
User = get_user_model()
class MyTests(TestCase):
	def setUp(self):
		self.user = User.objects.create(username='user')
	def test_first(self):
		with tempfile.TemporaryFile() as f:
			return FileResponse(f)
	def test_second(self):
		pass
Running tests...
----------------------------------------------------------------------
.E
======================================================================
ERROR [0.003s]: test_second (responses.test_fileresponse.MyTests)
----------------------------------------------------------------------
Traceback (most recent call last):
 File "/tests/django/django/db/backends/base/base.py", line 238, in _cursor
	return self._prepare_cursor(self.create_cursor(name))
 File "/tests/django/django/utils/asyncio.py", line 26, in inner
	return func(*args, **kwargs)
 File "/tests/django/django/db/backends/postgresql/base.py", line 231, in create_cursor
	cursor = self.connection.cursor()
psycopg2.InterfaceError: connection already closed
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
 File "/tests/django/tests/responses/test_fileresponse.py", line 19, in setUp
	self.user = User.objects.create(username='user')
 File "/tests/django/django/db/models/manager.py", line 82, in manager_method
	return getattr(self.get_queryset(), name)(*args, **kwargs)
 File "/tests/django/django/db/models/query.py", line 433, in create
	obj.save(force_insert=True, using=self.db)
 File "/tests/django/django/contrib/auth/base_user.py", line 66, in save
	super().save(*args, **kwargs)
 File "/tests/django/django/db/models/base.py", line 746, in save
	force_update=force_update, update_fields=update_fields)
 File "/tests/django/django/db/models/base.py", line 784, in save_base
	force_update, using, update_fields,
 File "/tests/django/django/db/models/base.py", line 887, in _save_table
	results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
 File "/tests/django/django/db/models/base.py", line 926, in _do_insert
	using=using, raw=raw,
 File "/tests/django/django/db/models/manager.py", line 82, in manager_method
	return getattr(self.get_queryset(), name)(*args, **kwargs)
 File "/tests/django/django/db/models/query.py", line 1204, in _insert
	return query.get_compiler(using=using).execute_sql(returning_fields)
 File "/tests/django/django/db/models/sql/compiler.py", line 1382, in execute_sql
	with self.connection.cursor() as cursor:
 File "/tests/django/django/utils/asyncio.py", line 26, in inner
	return func(*args, **kwargs)
 File "/tests/django/django/db/backends/base/base.py", line 260, in cursor
	return self._cursor()
 File "/tests/django/django/db/backends/base/base.py", line 238, in _cursor
	return self._prepare_cursor(self.create_cursor(name))
 File "/tests/django/django/db/utils.py", line 90, in __exit__
	raise dj_exc_value.with_traceback(traceback) from exc_value
 File "/tests/django/django/db/backends/base/base.py", line 238, in _cursor
	return self._prepare_cursor(self.create_cursor(name))
 File "/tests/django/django/utils/asyncio.py", line 26, in inner
	return func(*args, **kwargs)
 File "/tests/django/django/db/backends/postgresql/base.py", line 231, in create_cursor
	cursor = self.connection.cursor()
django.db.utils.InterfaceError: connection already closed


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/builtin_server/tests.py b/tests/builtin_server/tests.py
--- a/tests/builtin_server/tests.py
+++ b/tests/builtin_server/tests.py
@@ -4,6 +4,11 @@
 from unittest import TestCase
 from wsgiref import simple_server
 
+from django.core.servers.basehttp import get_internal_wsgi_application
+from django.test import RequestFactory, override_settings
+
+from .views import FILE_RESPONSE_HOLDER
+
 # If data is too large, socket will choke, so write chunks no larger than 32MB
 # at a time. The rationale behind the 32MB can be found in #5596#comment:4.
 MAX_SOCKET_CHUNK_SIZE = 32 * 1024 * 1024  # 32 MB
@@ -89,6 +94,27 @@ def test_file_wrapper_no_sendfile(self):
         self.assertEqual(handler.stdout.getvalue().splitlines()[-1], b'Hello World!')
         self.assertEqual(handler.stderr.getvalue(), b'')
 
+    @override_settings(ROOT_URLCONF='builtin_server.urls')
+    def test_file_response_closing(self):
+        """
+        View returning a FileResponse properly closes the file and http
+        response when file_wrapper is used.
+        """
+        env = RequestFactory().get('/fileresponse/').environ
+        handler = FileWrapperHandler(None, BytesIO(), BytesIO(), env)
+        handler.run(get_internal_wsgi_application())
+        # Sendfile is used only when file_wrapper has been used.
+        self.assertTrue(handler._used_sendfile)
+        # Fetch the original response object.
+        self.assertIn('response', FILE_RESPONSE_HOLDER)
+        response = FILE_RESPONSE_HOLDER['response']
+        # The response and file buffers are closed.
+        self.assertIs(response.closed, True)
+        buf1, buf2 = FILE_RESPONSE_HOLDER['buffers']
+        self.assertIs(buf1.closed, True)
+        self.assertIs(buf2.closed, True)
+        FILE_RESPONSE_HOLDER.clear()
+
 
 class WriteChunkCounterHandler(ServerHandler):
     """
diff --git a/tests/builtin_server/urls.py b/tests/builtin_server/urls.py
new file mode 100644
--- /dev/null
+++ b/tests/builtin_server/urls.py
@@ -0,0 +1,7 @@
+from django.urls import path
+
+from . import views
+
+urlpatterns = [
+    path('fileresponse/', views.file_response),
+]
diff --git a/tests/builtin_server/views.py b/tests/builtin_server/views.py
new file mode 100644
--- /dev/null
+++ b/tests/builtin_server/views.py
@@ -0,0 +1,15 @@
+from io import BytesIO
+
+from django.http import FileResponse
+
+FILE_RESPONSE_HOLDER = {}
+
+
+def file_response(request):
+    f1 = BytesIO(b"test1")
+    f2 = BytesIO(b"test2")
+    response = FileResponse(f1)
+    response._resource_closers.append(f2.close)
+    FILE_RESPONSE_HOLDER['response'] = response
+    FILE_RESPONSE_HOLDER['buffers'] = (f1, f2)
+    return response
diff --git a/tests/responses/test_fileresponse.py b/tests/responses/test_fileresponse.py
--- a/tests/responses/test_fileresponse.py
+++ b/tests/responses/test_fileresponse.py
@@ -80,52 +80,3 @@ def test_unicode_attachment(self):
             response['Content-Disposition'],
             "attachment; filename*=utf-8''%E7%A5%9D%E6%82%A8%E5%B9%B3%E5%AE%89.odt"
         )
-
-    def test_file_to_stream_closes_response(self):
-        # Closing file_to_stream calls FileResponse.close(), even when
-        # file-like object doesn't have a close() method.
-        class FileLike:
-            def read(self):
-                pass
-
-        class FileLikeWithClose(FileLike):
-            def __init__(self):
-                self.closed = False
-
-            def close(self):
-                self.closed = True
-
-        for filelike_cls in (FileLike, FileLikeWithClose):
-            with self.subTest(filelike_cls=filelike_cls.__name__):
-                filelike = filelike_cls()
-                response = FileResponse(filelike)
-                self.assertFalse(response.closed)
-                # Object with close() is added to the list of closable.
-                if hasattr(filelike, 'closed'):
-                    self.assertEqual(response._closable_objects, [filelike])
-                else:
-                    self.assertEqual(response._closable_objects, [])
-                file_to_stream = response.file_to_stream
-                file_to_stream.close()
-                if hasattr(filelike, 'closed'):
-                    self.assertTrue(filelike.closed)
-                self.assertTrue(response.closed)
-
-    def test_file_to_stream_closes_response_on_error(self):
-        # Closing file_to_stream calls FileResponse.close(), even when
-        # closing file-like raises exceptions.
-        class FileLikeWithRaisingClose:
-            def read(self):
-                pass
-
-            def close(self):
-                raise RuntimeError()
-
-        filelike = FileLikeWithRaisingClose()
-        response = FileResponse(filelike)
-        self.assertFalse(response.closed)
-        self.assertEqual(response._closable_objects, [filelike])
-        file_to_stream = response.file_to_stream
-        with self.assertRaises(RuntimeError):
-            file_to_stream.close()
-        self.assertTrue(response.closed)