# 修复代码生成提示词（实例ID：sympy__sympy-13429）
## 代码仓库
sympy/sympy

## 原始问题描述
Some comparisons between rational and irrational numbers are incorrect
If you choose just the right rational number, you can end up in a situation where it is neither less than pi, nor equal to it, nor is pi less than it. This is with sympy 1.1.1, using Python 3.6.0 from Anaconda on Ubuntu 16.04.
```
>>> import sympy
>>> sympy.__version__
'1.1.1'
>>> r = sympy.Rational('905502432259640373/288230376151711744')
>>> r < sympy.pi
False
>>> r == sympy.pi
False
>>> sympy.pi < r
False
```
Of course, that same number is greater than pi, even though pi is not less than it.
```
>>> r > sympy.pi
True
```
I believe this is a result of using evalf() to do comparisons between rationals and reals... As we can see, this particular fraction happens to be exactly equal to pi if we use the default evalf precision of 15, but not if we use more.
```
>>> r == sympy.pi.evalf(15)
True
>>> r == sympy.pi.evalf(16)
False
```
Hopefully this isn't a duplicate issue; I did a bit of searching for related ones, and found the likes of #12583 and #12534. I think this is different than #12583 because I'm only concerned about comparisons where one of the numbers is rational. That should always be decidable - or am I misunderstanding something about math?


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_relational.py b/sympy/core/tests/test_relational.py
--- a/sympy/core/tests/test_relational.py
+++ b/sympy/core/tests/test_relational.py
@@ -718,6 +718,55 @@ def test_issue_10927():
     assert str(Eq(x, -oo)) == 'Eq(x, -oo)'
 
 
+def test_issues_13081_12583_12534():
+    # 13081
+    r = Rational('905502432259640373/288230376151711744')
+    assert (r < pi) is S.false
+    assert (r > pi) is S.true
+    # 12583
+    v = sqrt(2)
+    u = sqrt(v) + 2/sqrt(10 - 8/sqrt(2 - v) + 4*v*(1/sqrt(2 - v) - 1))
+    assert (u >= 0) is S.true
+    # 12534; Rational vs NumberSymbol
+    # here are some precisions for which Rational forms
+    # at a lower and higher precision bracket the value of pi
+    # e.g. for p = 20:
+    # Rational(pi.n(p + 1)).n(25) = 3.14159265358979323846 2834
+    #                    pi.n(25) = 3.14159265358979323846 2643
+    # Rational(pi.n(p    )).n(25) = 3.14159265358979323846 1987
+    assert [p for p in range(20, 50) if
+            (Rational(pi.n(p)) < pi) and
+            (pi < Rational(pi.n(p + 1)))
+        ] == [20, 24, 27, 33, 37, 43, 48]
+    # pick one such precision and affirm that the reversed operation
+    # gives the opposite result, i.e. if x < y is true then x > y
+    # must be false
+    p = 20
+    # Rational vs NumberSymbol
+    G = [Rational(pi.n(i)) > pi for i in (p, p + 1)]
+    L = [Rational(pi.n(i)) < pi for i in (p, p + 1)]
+    assert G == [False, True]
+    assert all(i is not j for i, j in zip(L, G))
+    # Float vs NumberSymbol
+    G = [pi.n(i) > pi for i in (p, p + 1)]
+    L = [pi.n(i) < pi for i in (p, p + 1)]
+    assert G == [False, True]
+    assert all(i is not j for i, j in zip(L, G))
+    # Float vs Float
+    G = [pi.n(p) > pi.n(p + 1)]
+    L = [pi.n(p) < pi.n(p + 1)]
+    assert G == [True]
+    assert all(i is not j for i, j in zip(L, G))
+    # Float vs Rational
+    # the rational form is less than the floating representation
+    # at the same precision
+    assert [i for i in range(15, 50) if Rational(pi.n(i)) > pi.n(i)
+        ] == []
+    # this should be the same if we reverse the relational
+    assert [i for i in range(15, 50) if pi.n(i) < Rational(pi.n(i))
+        ] == []
+
+
 def test_binary_symbols():
     ans = set([x])
     for f in Eq, Ne: