# ‰øÆÂ§ç‰ª£Á†ÅÁîüÊàêÊèêÁ§∫ËØçÔºàÂÆû‰æãIDÔºödjango__django-16603Ôºâ
## ‰ª£Á†Å‰ªìÂ∫ì
django/django

## ÂéüÂßãÈóÆÈ¢òÊèèËø∞
ASGI http.disconnect not handled on requests with body.
Description
	
Noticed whilst reviewing ‚ÄãPR 15704 for #33699, we're not handling the ASGI http.disconnect message correctly. Since it's only dealt with whilst reading the request body, http.disconnect is not processed on a request that includes a body. 
‚Äãhttps://github.com/django/django/blob/241fe59b74bb6031fa644f3ad55e6ad6a9187510/django/core/handlers/asgi.py#L189
	async def read_body(self, receive):
		"""Reads an HTTP body from an ASGI connection."""
		# Use the tempfile that auto rolls-over to a disk file as it fills up.
		body_file = tempfile.SpooledTemporaryFile(
			max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode="w+b"
		)
		while True:
			message = await receive()
			if message["type"] == "http.disconnect":	# This is the only place `http.disconnect` is handled. 
				body_file.close()
				# Early client disconnect.
				raise RequestAborted()
			# Add a body chunk from the message, if provided.
			if "body" in message:
				body_file.write(message["body"])
			# Quit out if that's the end.
			if not message.get("more_body", False):
				break
		body_file.seek(0)
		return body_file
http.disconnect is designed for long-polling ‚Äî so we imagine a client opening a request, with a request body, and then disconnecting before the response is generated. 
The protocol server (Daphne/uvicorn/...) will send the http.diconnect message, but it's not handled.
This test fails on main (at 9f5548952906c6ea97200c016734b4f519520a64 ‚Äî 4.2 pre-alpha)
diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py
index ef7b55724e..a68ca8a473 100644
--- a/tests/asgi/tests.py
+++ b/tests/asgi/tests.py
@@ -188,6 +188,18 @@ class ASGITest(SimpleTestCase):
		 with self.assertRaises(asyncio.TimeoutError):
			 await communicator.receive_output()
 
+	async def test_disconnect_with_body(self):
+		application = get_asgi_application()
+		scope = self.async_request_factory._base_scope(path="/")
+		communicator = ApplicationCommunicator(application, scope)
+		await communicator.send_input({
+			"type": "http.request",
+			"body": b"some body",
+		})
+		await communicator.send_input({"type": "http.disconnect"})
+		with self.assertRaises(asyncio.TimeoutError):
+			await communicator.receive_output()
+
	 async def test_wrong_connection_type(self):
		 application = get_asgi_application()
		 scope = self.async_request_factory._base_scope(path="/", type="other")
To handle this correctly it looks like we'd need something like Channel's ‚Äã`await_many_dispatch()` to keep receiving from the input queue whilst dispatching the request. ü§î


## ÂèÇËÄÉÈªÑÈáëË°•‰∏ÅÔºàÊ≠£Á°ÆÁöÑ‰øÆÂ§çÊñπÊ°àÔºâ
diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py
--- a/tests/asgi/tests.py
+++ b/tests/asgi/tests.py
@@ -7,8 +7,10 @@
 
 from django.contrib.staticfiles.handlers import ASGIStaticFilesHandler
 from django.core.asgi import get_asgi_application
+from django.core.handlers.asgi import ASGIHandler, ASGIRequest
 from django.core.signals import request_finished, request_started
 from django.db import close_old_connections
+from django.http import HttpResponse
 from django.test import (
     AsyncRequestFactory,
     SimpleTestCase,
@@ -16,6 +18,7 @@
     modify_settings,
     override_settings,
 )
+from django.urls import path
 from django.utils.http import http_date
 
 from .urls import sync_waiter, test_filename
@@ -234,6 +237,34 @@ async def test_disconnect(self):
         with self.assertRaises(asyncio.TimeoutError):
             await communicator.receive_output()
 
+    async def test_disconnect_with_body(self):
+        application = get_asgi_application()
+        scope = self.async_request_factory._base_scope(path="/")
+        communicator = ApplicationCommunicator(application, scope)
+        await communicator.send_input({"type": "http.request", "body": b"some body"})
+        await communicator.send_input({"type": "http.disconnect"})
+        with self.assertRaises(asyncio.TimeoutError):
+            await communicator.receive_output()
+
+    async def test_assert_in_listen_for_disconnect(self):
+        application = get_asgi_application()
+        scope = self.async_request_factory._base_scope(path="/")
+        communicator = ApplicationCommunicator(application, scope)
+        await communicator.send_input({"type": "http.request"})
+        await communicator.send_input({"type": "http.not_a_real_message"})
+        msg = "Invalid ASGI message after request body: http.not_a_real_message"
+        with self.assertRaisesMessage(AssertionError, msg):
+            await communicator.receive_output()
+
+    async def test_delayed_disconnect_with_body(self):
+        application = get_asgi_application()
+        scope = self.async_request_factory._base_scope(path="/delayed_hello/")
+        communicator = ApplicationCommunicator(application, scope)
+        await communicator.send_input({"type": "http.request", "body": b"some body"})
+        await communicator.send_input({"type": "http.disconnect"})
+        with self.assertRaises(asyncio.TimeoutError):
+            await communicator.receive_output()
+
     async def test_wrong_connection_type(self):
         application = get_asgi_application()
         scope = self.async_request_factory._base_scope(path="/", type="other")
@@ -318,3 +349,56 @@ async def test_concurrent_async_uses_multiple_thread_pools(self):
         self.assertEqual(len(sync_waiter.active_threads), 2)
 
         sync_waiter.active_threads.clear()
+
+    async def test_asyncio_cancel_error(self):
+        # Flag to check if the view was cancelled.
+        view_did_cancel = False
+
+        # A view that will listen for the cancelled error.
+        async def view(request):
+            nonlocal view_did_cancel
+            try:
+                await asyncio.sleep(0.2)
+                return HttpResponse("Hello World!")
+            except asyncio.CancelledError:
+                # Set the flag.
+                view_did_cancel = True
+                raise
+
+        # Request class to use the view.
+        class TestASGIRequest(ASGIRequest):
+            urlconf = (path("cancel/", view),)
+
+        # Handler to use request class.
+        class TestASGIHandler(ASGIHandler):
+            request_class = TestASGIRequest
+
+        # Request cycle should complete since no disconnect was sent.
+        application = TestASGIHandler()
+        scope = self.async_request_factory._base_scope(path="/cancel/")
+        communicator = ApplicationCommunicator(application, scope)
+        await communicator.send_input({"type": "http.request"})
+        response_start = await communicator.receive_output()
+        self.assertEqual(response_start["type"], "http.response.start")
+        self.assertEqual(response_start["status"], 200)
+        response_body = await communicator.receive_output()
+        self.assertEqual(response_body["type"], "http.response.body")
+        self.assertEqual(response_body["body"], b"Hello World!")
+        # Give response.close() time to finish.
+        await communicator.wait()
+        self.assertIs(view_did_cancel, False)
+
+        # Request cycle with a disconnect before the view can respond.
+        application = TestASGIHandler()
+        scope = self.async_request_factory._base_scope(path="/cancel/")
+        communicator = ApplicationCommunicator(application, scope)
+        await communicator.send_input({"type": "http.request"})
+        # Let the view actually start.
+        await asyncio.sleep(0.1)
+        # Disconnect the client.
+        await communicator.send_input({"type": "http.disconnect"})
+        # The handler should not send a response.
+        with self.assertRaises(asyncio.TimeoutError):
+            await communicator.receive_output()
+        await communicator.wait()
+        self.assertIs(view_did_cancel, True)
diff --git a/tests/asgi/urls.py b/tests/asgi/urls.py
--- a/tests/asgi/urls.py
+++ b/tests/asgi/urls.py
@@ -1,4 +1,5 @@
 import threading
+import time
 
 from django.http import FileResponse, HttpResponse
 from django.urls import path
@@ -10,6 +11,12 @@ def hello(request):
     return HttpResponse("Hello %s!" % name)
 
 
+def hello_with_delay(request):
+    name = request.GET.get("name") or "World"
+    time.sleep(1)
+    return HttpResponse(f"Hello {name}!")
+
+
 def hello_meta(request):
     return HttpResponse(
         "From %s" % request.META.get("HTTP_REFERER") or "",
@@ -46,4 +53,5 @@ def post_echo(request):
     path("meta/", hello_meta),
     path("post/", post_echo),
     path("wait/", sync_waiter),
+    path("delayed_hello/", hello_with_delay),
 ]