# 修复代码生成提示词（实例ID：sympy__sympy-11862）
## 代码仓库
sympy/sympy

## 原始问题描述
lambdify precision loss with module=mpmath from high-precision Floats
Floats with more than 16 digits are converted to double precision somewhere.

Consider:

```
In [52]: x = symbols('x')

In [53]: g = sqrt(2) - x

In [54]: h = g.evalf(64)

In [55]: g
Out[55]: -x + sqrt(2)

In [56]: h
Out[56]: -x + 1.414213562373095048801688724209698078569671875376948073176679738
```

Note `h` has a 64-digit accurate Float in it (and the value is correct).

But lambdifying `g` and `h` is not same:

```
In [57]: f1 = lambdify(x, g, modules='mpmath')

In [58]: f2 = lambdify(x, h, modules='mpmath')

In [59]: f1(N(sqrt(2),64))
Out[59]: 1.899113549151959749494648453912391430844193166723988993255955998e-65

In [60]: f2(N(sqrt(2),64))
Out[60]: 0.00000000000000009667293313452913037187168859825586442682332026201917202971226475
```

The help string for `f2` shows no loss: 

```
In [64]: f2?
Type:        function
String form: <function <lambda> at 0x7f6a43bd92a8>
File:        Dynamically generated function. No source code available.
Definition:  f2(_Dummy_22)
Docstring:
Created with lambdify. Signature:

func(x)

Expression:

-x + 1.414213562373095048801688724209698078569671875376948073176679738
```

I haven't figured out how to look at the actual code yet, but somewhere something is being converted to double-precision (which might be fine for module=numpy but should not happen here).



## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py
--- a/sympy/core/tests/test_numbers.py
+++ b/sympy/core/tests/test_numbers.py
@@ -8,6 +8,7 @@
 from sympy.core.logic import fuzzy_not
 from sympy.core.numbers import (igcd, ilcm, igcdex, seterr, _intcache,
     mpf_norm, comp, mod_inverse)
+from sympy.utilities.decorator import conserve_mpmath_dps
 from sympy.utilities.iterables import permutations
 from sympy.utilities.pytest import XFAIL, raises
 
@@ -379,8 +380,14 @@ def eq(a, b):
     x2_str = Float((0, '26666666666666', -53, 53))
     x_hex = Float((0, long(0x13333333333333), -52, 53))
     x_dec = Float((0, 5404319552844595, -52, 53))
+    assert x_str == x_hex == x_dec == Float(1.2)
+    # This looses a binary digit of precision, so it isn't equal to the above,
+    # but check that it normalizes correctly
     x2_hex = Float((0, long(0x13333333333333)*2, -53, 53))
-    assert x_str == x_hex == x_dec == x2_hex == Float(1.2)
+    assert x2_hex._mpf_ == (0, 5404319552844595, -52, 52)
+    # XXX: Should this test also hold?
+    # assert x2_hex._prec == 52
+
     # x2_str and 1.2 are superficially the same
     assert str(x2_str) == str(Float(1.2))
     # but are different at the mpf level
@@ -487,6 +494,17 @@ def teq(a):
     assert Float(u'0.73908513321516064100000000') == Float('0.73908513321516064100000000')
     assert Float(u'0.73908513321516064100000000', 28) == Float('0.73908513321516064100000000', 28)
 
+@conserve_mpmath_dps
+def test_float_mpf():
+    import mpmath
+    mpmath.mp.dps = 100
+    mp_pi = mpmath.pi()
+
+    assert Float(mp_pi, 100) == Float(mp_pi._mpf_, 100) == pi.evalf(100)
+
+    mpmath.mp.dps = 15
+
+    assert Float(mp_pi, 100) == Float(mp_pi._mpf_, 100) == pi.evalf(100)
 
 def test_Float_default_to_highprec_from_str():
     s = str(pi.evalf(128))
diff --git a/sympy/solvers/tests/test_numeric.py b/sympy/solvers/tests/test_numeric.py
--- a/sympy/solvers/tests/test_numeric.py
+++ b/sympy/solvers/tests/test_numeric.py
@@ -3,7 +3,7 @@
 from sympy.solvers import nsolve
 from sympy.utilities.lambdify import lambdify
 from sympy.utilities.pytest import raises, XFAIL
-
+from sympy.utilities.decorator import conserve_mpmath_dps
 
 def test_nsolve():
     # onedimensional
@@ -57,3 +57,15 @@ def test_issue_6408():
 def test_issue_6408_fail():
     x, y = symbols('x y')
     assert nsolve(Integral(x*y, (x, 0, 5)), y, 2) == 0.0
+
+
+@conserve_mpmath_dps
+def test_increased_dps():
+    # Issue 8564
+    import mpmath
+    mpmath.mp.dps = 128
+    x = Symbol('x')
+    e1 = x**2 - pi
+    q = nsolve(e1, x, 3.0)
+
+    assert abs(sqrt(pi).evalf(128) - q) < 1e-128
diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py
--- a/sympy/utilities/tests/test_lambdify.py
+++ b/sympy/utilities/tests/test_lambdify.py
@@ -118,7 +118,6 @@ def test_mpmath_lambda():
 
 
 @conserve_mpmath_dps
-@XFAIL
 def test_number_precision():
     mpmath.mp.dps = 50
     sin02 = mpmath.mpf("0.19866933079506121545941262711838975037020672954020")
@@ -126,6 +125,11 @@ def test_number_precision():
     prec = 1e-49  # mpmath precision is around 50 decimal places
     assert -prec < f(0) - sin02 < prec
 
+@conserve_mpmath_dps
+def test_mpmath_precision():
+    mpmath.mp.dps = 100
+    assert str(lambdify((), pi.evalf(100), 'mpmath')()) == str(pi.evalf(100))
+
 #================== Test Translations ==============================
 # We can only check if all translated functions are valid. It has to be checked
 # by hand if they are complete.