# 修复代码生成提示词（实例ID：scikit-learn__scikit-learn-14450）
## 代码仓库
scikit-learn/scikit-learn

## 原始问题描述
PLS reports "array must not contain nan" if a feature is constant
Originally reported at https://github.com/scikit-learn/scikit-learn/issues/2089#issuecomment-152753095 by @Franck-Dernoncourt. Reproduce with:
```py
import numpy as np
import sklearn.cross_decomposition

pls2 = sklearn.cross_decomposition.PLSRegression()
xx = np.random.random((5,5))
yy = np.zeros((5,5) ) 

yy[0,:] = [0,1,0,0,0]
yy[1,:] = [0,0,0,1,0]
yy[2,:] = [0,0,0,0,1]
#yy[3,:] = [1,0,0,0,0] # Uncommenting this line solves the issue

pls2.fit(xx, yy)
```

The obscure error message is due to the presence of a column containing only 0.


## 参考黄金补丁（正确的修复方案）
diff --git a/sklearn/cross_decomposition/tests/test_pls.py b/sklearn/cross_decomposition/tests/test_pls.py
--- a/sklearn/cross_decomposition/tests/test_pls.py
+++ b/sklearn/cross_decomposition/tests/test_pls.py
@@ -261,6 +261,47 @@ def check_ortho(M, err_msg):
     check_ortho(pls_ca.x_scores_, "x scores are not orthogonal")
     check_ortho(pls_ca.y_scores_, "y scores are not orthogonal")
 
+    # 4) Another "Non regression test" of PLS Regression (PLS2):
+    #    Checking behavior when the first column of Y is constant
+    # ===============================================
+    # The results were compared against a modified version of plsreg2
+    # from the R-package plsdepot
+    X = d.data
+    Y = d.target
+    Y[:, 0] = 1
+    pls_2 = pls_.PLSRegression(n_components=X.shape[1])
+    pls_2.fit(X, Y)
+
+    x_weights = np.array(
+        [[-0.6273573, 0.007081799, 0.7786994],
+         [-0.7493417, -0.277612681, -0.6011807],
+         [-0.2119194, 0.960666981, -0.1794690]])
+    x_weights_sign_flip = pls_2.x_weights_ / x_weights
+
+    x_loadings = np.array(
+        [[-0.6273512, -0.22464538, 0.7786994],
+         [-0.6643156, -0.09871193, -0.6011807],
+         [-0.5125877, 1.01407380, -0.1794690]])
+    x_loadings_sign_flip = pls_2.x_loadings_ / x_loadings
+
+    y_loadings = np.array(
+        [[0.0000000, 0.0000000, 0.0000000],
+         [0.4357300, 0.5828479, 0.2174802],
+         [-0.1353739, -0.2486423, -0.1810386]])
+
+    # R/python sign flip should be the same in x_weight and x_rotation
+    assert_array_almost_equal(x_loadings_sign_flip, x_weights_sign_flip, 4)
+
+    # This test that R / python give the same result up to column
+    # sign indeterminacy
+    assert_array_almost_equal(np.abs(x_loadings_sign_flip), 1, 4)
+    assert_array_almost_equal(np.abs(x_weights_sign_flip), 1, 4)
+
+    # For the PLSRegression with default parameters, it holds that
+    # y_loadings==y_weights. In this case we only test that R/python
+    # give the same result for the y_loadings irrespective of the sign
+    assert_array_almost_equal(np.abs(pls_2.y_loadings_), np.abs(y_loadings), 4)
+
 
 def test_convergence_fail():
     d = load_linnerud()