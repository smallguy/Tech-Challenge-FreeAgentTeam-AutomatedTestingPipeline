# 修复代码生成提示词（实例ID：sympy__sympy-18728）
## 代码仓库
sympy/sympy

## 原始问题描述
Fix is_zero and is_positive for Pow
<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write "Fixes #NNNN" in that exact
format, e.g. "Fixes #1234". See
https://github.com/blog/1506-closing-issues-via-pull-requests . Please also
write a comment on that issue linking back to this pull request once it is
open. -->

Fixes #9532 

#### Brief description of what is fixed or changed

Still a work in progress. This attempts to get Pow.is_zero working in all cases.

This PR fixes Pow.is_zero so that it doesn't assume finiteness unless justified by assumptions. For example on master:
```julia
In [1]: a, b = symbols('a b', positive=True)                                                                                                   

In [2]: print(a.is_finite)                                                                                                                     
None

In [3]: print(b.is_finite)                                                                                                                     
None

In [4]: print((a**b).is_zero)                                                                                                                  
False
```
This is incorrect because if a or b can be infinite then it is possible for `a**b` to be zero e.g. if
1. a is infinite and b is negative
2. abs(a)<1 and b is positive infinite (oo)
3. abs(a)>1 and b is negative infinite (-oo)

With this PR we have
```julia
In [1]: a, b = symbols('a b', positive=True)                                                                                                   

In [2]: print((a**b).is_zero)                                                                                                                  
None
```
meaning that `a**b` could be zero or could not be zero.

Also on master we have
```julia
In [1]: a, b = symbols('a b', positive=True)                                                                                                   

In [2]: (a**b).is_positive                                                                                                                     
Out[2]: True
```
whereas this PR gives `None` in that case since `a**b` could be zero and therefore not be positive.

This PR also fixes #9532 since
```julia
In [3]: n = Symbol('n', real=True, finite=True)                                                                                                

In [4]: zoo / n                                                                                                                                
Out[4]: zoo
```
This comes from the fact that `(1/n)` is properly considered nonzero if `n` is declared as finite.

At the time of writing we still have this problem with the PR though:
```julia
In [5]: n = Symbol('n', finite=True)                                                                                                           

In [6]: zoo / n                                                                                                                                
Out[6]: 
zoo
───
 n 
```

#### Other comments

I'm not sure that this PR should be merged as is. Many of the changes are adding `finite=True` flags that probably shouldn't be there. Those flags would not be necessary if the other assumptions implied finite=True. For example in some cases a symbol is declared as `integer=True` and with this PR I've had to add `finite=True` also.  Probably it would be better to fix those cases by having `integer --> finite` in the assumptions system. Most of the other cases are for symbols declared as `real=True` which could also be fixed.

Now that I (hopefully) have the tests passing I still want to improve this PR by tidying up the implementation. Also it still doesn't work in all cases as the zoo/n example above shows.

Perhaps instead of merging this I could build new PRs on top. One could add `Rational --> finite`. Then I could follow that with splitting real into extended_real and real and having `real --> finite` as well. That would be a big change though so maybe it would be better to merge this first.

#### Release Notes

<!-- Write the release notes for this release below. See
https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more information
on how to write release notes. The bot will check your release notes
automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* core
    * Fix is_zero assumptions for `a**b` and `a/b` when `a` or `b` could be infinite.
<!-- END RELEASE NOTES -->



## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py
--- a/sympy/core/tests/test_arit.py
+++ b/sympy/core/tests/test_arit.py
@@ -1200,6 +1200,108 @@ def test_Pow_is_zero():
     assert Pow(S.Half, oo, evaluate=False).is_zero
     assert Pow(S.Half, -oo, evaluate=False).is_zero is False
 
+    # All combinations of real/complex base/exponent
+    h = S.Half
+    T = True
+    F = False
+    N = None
+
+    pow_iszero = [
+        ['**',  0,  h,  1,  2, -h, -1,-2,-2*I,-I/2,I/2,1+I,oo,-oo,zoo],
+        [   0,  F,  T,  T,  T,  F,  F,  F,  F,  F,  F,  N,  T,  F,  N],
+        [   h,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [   1,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  N],
+        [   2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [  -h,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [  -1,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  N],
+        [  -2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [-2*I,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [-I/2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [ I/2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [ 1+I,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [  oo,  F,  F,  F,  F,  T,  T,  T,  F,  F,  F,  F,  F,  T,  N],
+        [ -oo,  F,  F,  F,  F,  T,  T,  T,  F,  F,  F,  F,  F,  T,  N],
+        [ zoo,  F,  F,  F,  F,  T,  T,  T,  N,  N,  N,  N,  F,  T,  N]
+    ]
+
+    def test_table(table):
+        n = len(table[0])
+        for row in range(1, n):
+            base = table[row][0]
+            for col in range(1, n):
+                exp = table[0][col]
+                is_zero = table[row][col]
+                # The actual test here:
+                assert Pow(base, exp, evaluate=False).is_zero is is_zero
+
+    test_table(pow_iszero)
+
+    # A zero symbol...
+    zo, zo2 = symbols('zo, zo2', zero=True)
+
+    # All combinations of finite symbols
+    zf, zf2 = symbols('zf, zf2', finite=True)
+    wf, wf2 = symbols('wf, wf2', nonzero=True)
+    xf, xf2 = symbols('xf, xf2', real=True)
+    yf, yf2 = symbols('yf, yf2', nonzero=True)
+    af, af2 = symbols('af, af2', positive=True)
+    bf, bf2 = symbols('bf, bf2', nonnegative=True)
+    cf, cf2 = symbols('cf, cf2', negative=True)
+    df, df2 = symbols('df, df2', nonpositive=True)
+
+    # Without finiteness:
+    zi, zi2 = symbols('zi, zi2')
+    wi, wi2 = symbols('wi, wi2', zero=False)
+    xi, xi2 = symbols('xi, xi2', extended_real=True)
+    yi, yi2 = symbols('yi, yi2', zero=False, extended_real=True)
+    ai, ai2 = symbols('ai, ai2', extended_positive=True)
+    bi, bi2 = symbols('bi, bi2', extended_nonnegative=True)
+    ci, ci2 = symbols('ci, ci2', extended_negative=True)
+    di, di2 = symbols('di, di2', extended_nonpositive=True)
+
+    pow_iszero_sym = [
+        ['**',zo,wf,yf,af,cf,zf,xf,bf,df,zi,wi,xi,yi,ai,bi,ci,di],
+        [ zo2, F, N, N, T, F, N, N, N, F, N, N, N, N, T, N, F, F],
+        [ wf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ yf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ af2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ cf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ zf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ xf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ bf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ df2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ zi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ wi2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ xi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ yi2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ ai2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ bi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ ci2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ di2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N]
+    ]
+
+    test_table(pow_iszero_sym)
+
+    # In some cases (x**x).is_zero is different from (x**y).is_zero even if y
+    # has the same assumptions as x.
+    assert (zo ** zo).is_zero is False
+    assert (wf ** wf).is_zero is False
+    assert (yf ** yf).is_zero is False
+    assert (af ** af).is_zero is False
+    assert (cf ** cf).is_zero is False
+    assert (zf ** zf).is_zero is None
+    assert (xf ** xf).is_zero is None
+    assert (bf ** bf).is_zero is False # None in table
+    assert (df ** df).is_zero is None
+    assert (zi ** zi).is_zero is None
+    assert (wi ** wi).is_zero is None
+    assert (xi ** xi).is_zero is None
+    assert (yi ** yi).is_zero is None
+    assert (ai ** ai).is_zero is False # None in table
+    assert (bi ** bi).is_zero is False # None in table
+    assert (ci ** ci).is_zero is None
+    assert (di ** di).is_zero is None
+
 
 def test_Pow_is_nonpositive_nonnegative():
     x = Symbol('x', real=True)