# 修复代码生成提示词（实例ID：django__django-13281）
## 代码仓库
django/django

## 原始问题描述
FK field caching behavior change between 1.11.x and 2.x
Description
	
Whilst upgrading a codebase from 1.11.x to 2.0/2.2 I noticed a weird change in behavior of FK fields when copying model instances.
At the bottom of the post there is a testcase that succeeds on 1.11.x and fails on 2.x
I think the commit that changed the behavior is bfb746f983aa741afa3709794e70f1e0ab6040b5
So my question is two fold:
Is the behavior in >=2.0 correct? It seems quite unexpected.
What is the recommended way to clone a model instance? To date we have been using copy() in a similar fashion to the test without issue. deepcopy seems to work fine in >=2.0 but we haven’t done too much testing yet.
Test (placed in tests/model_fields/test_field_caching_change.py):
import copy
from django.test import TestCase
from .models import Bar, Foo
class ForeignKeyCachingBehaviorTest(TestCase):
	def test_copy(self):
		foo1 = Foo.objects.create(a='foo1', d=1)
		foo2 = Foo.objects.create(a='foo2', d=2)
		bar1 = Bar.objects.create(a=foo1, b='bar1')
		bar2 = copy.copy(bar1)
		bar2.pk = None
		bar2.a = foo2
		# bar2 points to foo2
		self.assertEqual(bar2.a, foo2)
		self.assertEqual(bar2.a.id, bar2.a_id)
		# bar1 is unchanged and must still point to foo1
		# These fail on Django >= 2.0
		self.assertEqual(bar1.a, foo1)
		self.assertEqual(bar1.a.id, bar1.a_id)
and executed that via:
python3.6 tests/runtests.py --parallel 1 model_fields
In ​https://groups.google.com/g/django-developers/c/QMhVPIqVVP4/m/mbezfaBEAwAJ Simon suggests:
..... Model.copy should make sure to make a deep-copy of self._state now that fields are cached in self._state.fields_cache.
which I will attempt to implement.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/model_regress/tests.py b/tests/model_regress/tests.py
--- a/tests/model_regress/tests.py
+++ b/tests/model_regress/tests.py
@@ -1,3 +1,4 @@
+import copy
 import datetime
 from operator import attrgetter
 
@@ -256,3 +257,17 @@ def test_model_with_evaluate_method(self):
         dept = Department.objects.create(pk=1, name='abc')
         dept.evaluate = 'abc'
         Worker.objects.filter(department=dept)
+
+
+class ModelFieldsCacheTest(TestCase):
+    def test_fields_cache_reset_on_copy(self):
+        department1 = Department.objects.create(id=1, name='department1')
+        department2 = Department.objects.create(id=2, name='department2')
+        worker1 = Worker.objects.create(name='worker', department=department1)
+        worker2 = copy.copy(worker1)
+
+        self.assertEqual(worker2.department, department1)
+        # Changing related fields doesn't mutate the base object.
+        worker2.department = department2
+        self.assertEqual(worker2.department, department2)
+        self.assertEqual(worker1.department, department1)