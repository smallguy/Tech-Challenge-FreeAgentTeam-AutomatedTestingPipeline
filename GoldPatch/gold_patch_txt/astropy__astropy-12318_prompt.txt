# 修复代码生成提示词（实例ID：astropy__astropy-12318）
## 代码仓库
astropy/astropy

## 原始问题描述
BlackBody bolometric flux is wrong if scale has units of dimensionless_unscaled
The `astropy.modeling.models.BlackBody` class has the wrong bolometric flux if `scale` argument is passed as a Quantity with `dimensionless_unscaled` units, but the correct bolometric flux if `scale` is simply a float.

### Description
<!-- Provide a general description of the bug. -->

### Expected behavior
Expected output from sample code:

```
4.823870774433646e-16 erg / (cm2 s)
4.823870774433646e-16 erg / (cm2 s)
```

### Actual behavior
Actual output from sample code:

```
4.5930032795393893e+33 erg / (cm2 s)
4.823870774433646e-16 erg / (cm2 s)
```

### Steps to Reproduce
Sample code:

```python
from astropy.modeling.models import BlackBody
from astropy import units as u
import numpy as np

T = 3000 * u.K
r = 1e14 * u.cm
DL = 100 * u.Mpc
scale = np.pi * (r / DL)**2

print(BlackBody(temperature=T, scale=scale).bolometric_flux)
print(BlackBody(temperature=T, scale=scale.to_value(u.dimensionless_unscaled)).bolometric_flux)
```

### System Details
```pycon
>>> import numpy; print("Numpy", numpy.__version__)
Numpy 1.20.2
>>> import astropy; print("astropy", astropy.__version__)
astropy 4.3.dev758+g1ed1d945a
>>> import scipy; print("Scipy", scipy.__version__)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'scipy'
>>> import matplotlib; print("Matplotlib", matplotlib.__version__)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'matplotlib'
```


## 参考黄金补丁（正确的修复方案）
diff --git a/astropy/modeling/tests/test_physical_models.py b/astropy/modeling/tests/test_physical_models.py
--- a/astropy/modeling/tests/test_physical_models.py
+++ b/astropy/modeling/tests/test_physical_models.py
@@ -40,6 +40,17 @@ def test_blackbody_sefanboltzman_law():
     assert_quantity_allclose(b.bolometric_flux, 133.02471751812573 * u.W / (u.m * u.m))
 
 
+def test_blackbody_input_units():
+    SLAM = u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)
+    SNU = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)
+
+    b_lam = BlackBody(3000*u.K, scale=1*SLAM)
+    assert(b_lam.input_units['x'] == u.AA)
+
+    b_nu = BlackBody(3000*u.K, scale=1*SNU)
+    assert(b_nu.input_units['x'] == u.Hz)
+
+
 def test_blackbody_return_units():
     # return of evaluate has no units when temperature has no units
     b = BlackBody(1000.0 * u.K, scale=1.0)
@@ -72,7 +83,7 @@ def test_blackbody_fit():
     b_fit = fitter(b, wav, fnu, maxiter=1000)
 
     assert_quantity_allclose(b_fit.temperature, 2840.7438355865065 * u.K)
-    assert_quantity_allclose(b_fit.scale, 5.803783292762381e-17 * u.Jy / u.sr)
+    assert_quantity_allclose(b_fit.scale, 5.803783292762381e-17)
 
 
 def test_blackbody_overflow():
@@ -104,10 +115,11 @@ def test_blackbody_exceptions_and_warnings():
     """Test exceptions."""
 
     # Negative temperature
-    with pytest.raises(ValueError) as exc:
+    with pytest.raises(
+            ValueError,
+            match="Temperature should be positive: \\[-100.\\] K"):
         bb = BlackBody(-100 * u.K)
         bb(1.0 * u.micron)
-    assert exc.value.args[0] == "Temperature should be positive: [-100.] K"
 
     bb = BlackBody(5000 * u.K)
 
@@ -121,11 +133,11 @@ def test_blackbody_exceptions_and_warnings():
         bb(-1.0 * u.AA)
     assert len(w) == 1
 
-    # Test that a non surface brightness converatable scale unit
-    with pytest.raises(ValueError) as exc:
+    # Test that a non surface brightness convertible scale unit raises an error
+    with pytest.raises(
+            ValueError,
+            match="scale units not dimensionless or in surface brightness: Jy"):
         bb = BlackBody(5000 * u.K, scale=1.0 * u.Jy)
-        bb(1.0 * u.micron)
-    assert exc.value.args[0] == "scale units not surface brightness: Jy"
 
 
 def test_blackbody_array_temperature():
@@ -146,6 +158,45 @@ def test_blackbody_array_temperature():
     assert flux.shape == (3, 4)
 
 
+def test_blackbody_dimensionless():
+    """Test support for dimensionless (but not unscaled) units for scale"""
+    T = 3000 * u.K
+    r = 1e14 * u.cm
+    DL = 100 * u.Mpc
+    scale = np.pi * (r / DL)**2
+
+    bb1 = BlackBody(temperature=T, scale=scale)
+    # even though we passed scale with units, we should be able to evaluate with unitless
+    bb1.evaluate(0.5, T.value, scale.to_value(u.dimensionless_unscaled))
+
+    bb2 = BlackBody(temperature=T, scale=scale.to_value(u.dimensionless_unscaled))
+    bb2.evaluate(0.5, T.value, scale.to_value(u.dimensionless_unscaled))
+
+    # bolometric flux for both cases should be equivalent
+    assert(bb1.bolometric_flux == bb2.bolometric_flux)
+
+
+@pytest.mark.skipif("not HAS_SCIPY")
+def test_blackbody_dimensionless_fit():
+    T = 3000 * u.K
+    r = 1e14 * u.cm
+    DL = 100 * u.Mpc
+    scale = np.pi * (r / DL)**2
+
+    bb1 = BlackBody(temperature=T, scale=scale)
+    bb2 = BlackBody(temperature=T, scale=scale.to_value(u.dimensionless_unscaled))
+
+    fitter = LevMarLSQFitter()
+
+    wav = np.array([0.5, 5, 10]) * u.micron
+    fnu = np.array([1, 10, 5]) * u.Jy / u.sr
+
+    bb1_fit = fitter(bb1, wav, fnu, maxiter=1000)
+    bb2_fit = fitter(bb2, wav, fnu, maxiter=1000)
+
+    assert(bb1_fit.temperature == bb2_fit.temperature)
+
+
 @pytest.mark.parametrize("mass", (2.0000000000000E15 * u.M_sun, 3.976819741e+45 * u.kg))
 def test_NFW_evaluate(mass):
     """Evaluation, density, and radii validation of NFW model."""