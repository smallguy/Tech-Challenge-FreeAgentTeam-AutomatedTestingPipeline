# 修复代码生成提示词（实例ID：scikit-learn__scikit-learn-13628）
## 代码仓库
scikit-learn/scikit-learn

## 原始问题描述
brier_score_loss error
Hello. I think I found a mistake in brier_score_loss. 
When you have a target = 1 and a prediction = 1 too, brier_score_loss should be 0 (best result), but it gives 1. Why is it happening? Because _check_binary_probabilistic_predictions gets target with only one class and convert it to 0. And metric calculates for target = 0 and prediction = 1. The same problem for target = 1 and prediction = 0. brier_score_loss is 0 (the best result), but it should be 1. 

Examples:
Approx = [0, 0, 0, 0]
Target = [1, 1, 1, 1]
Weight = [1, 1, 1, 1]
brier_score_loss(Target, Approx, sample_weight=Weight) 
result is 0

Approx = [1, 1, 1, 1]
Target = [1, 1, 1, 1]
Weight = [1, 1, 1, 1]
brier_score_loss(Target, Approx, sample_weight=Weight) 
result is 1

Maybe we should fix it? Thank you.


## 参考黄金补丁（正确的修复方案）
diff --git a/sklearn/metrics/tests/test_classification.py b/sklearn/metrics/tests/test_classification.py
--- a/sklearn/metrics/tests/test_classification.py
+++ b/sklearn/metrics/tests/test_classification.py
@@ -1997,9 +1997,23 @@ def test_brier_score_loss():
     assert_raises(ValueError, brier_score_loss, y_true, y_pred[1:])
     assert_raises(ValueError, brier_score_loss, y_true, y_pred + 1.)
     assert_raises(ValueError, brier_score_loss, y_true, y_pred - 1.)
-    # calculate even if only single class in y_true (#6980)
-    assert_almost_equal(brier_score_loss([0], [0.5]), 0.25)
-    assert_almost_equal(brier_score_loss([1], [0.5]), 0.25)
+
+    # ensure to raise an error for multiclass y_true
+    y_true = np.array([0, 1, 2, 0])
+    y_pred = np.array([0.8, 0.6, 0.4, 0.2])
+    error_message = ("Only binary classification is supported. Labels "
+                     "in y_true: {}".format(np.array([0, 1, 2])))
+    assert_raise_message(ValueError, error_message, brier_score_loss,
+                         y_true, y_pred)
+
+    # calculate correctly when there's only one class in y_true
+    assert_almost_equal(brier_score_loss([-1], [0.4]), 0.16)
+    assert_almost_equal(brier_score_loss([0], [0.4]), 0.16)
+    assert_almost_equal(brier_score_loss([1], [0.4]), 0.36)
+    assert_almost_equal(
+        brier_score_loss(['foo'], [0.4], pos_label='bar'), 0.16)
+    assert_almost_equal(
+        brier_score_loss(['foo'], [0.4], pos_label='foo'), 0.36)
 
 
 def test_balanced_accuracy_score_unseen():