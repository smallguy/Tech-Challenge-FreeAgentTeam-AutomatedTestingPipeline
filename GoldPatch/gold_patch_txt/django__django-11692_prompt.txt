# 修复代码生成提示词（实例ID：django__django-11692）
## 代码仓库
django/django

## 原始问题描述
Can't use OuterRef in union Subquery
Description
	
When you make a QuerySet using the union method or the | operator, the QuerySet passed into the union method cannot reference OuterRef even when wrapped with Subquery.
For example:
cls = Document.objects.filter(
	checklist__isnull=False,
	part=OuterRef('id')
).values('checklist__customer', 'created')
ots = Document.objects.filter(
	ownershiptransfer__isnull=False,
	part=OuterRef('id')
).values('ownershiptransfer__ship_target__contact', 'created')
return self.annotate(
	owner=Subquery(cls.union(ots).values('owner')[:1])
)
Returns this error:
ValueError
This queryset contains a reference to an outer query and may only be used in a subquery.
I get the same error with this statement:
return self.annotate(
	owner=Subquery((cls | ots).values('owner')[:1])
)
(As an aside, I also get an error when I try to apply an order_by clause.)


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -1,11 +1,11 @@
 import operator
 
 from django.db import DatabaseError, NotSupportedError, connection
-from django.db.models import Exists, F, IntegerField, OuterRef, Value
+from django.db.models import Exists, F, IntegerField, OuterRef, Subquery, Value
 from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature
 from django.test.utils import CaptureQueriesContext
 
-from .models import Celebrity, Number, ReservedName
+from .models import Author, Celebrity, ExtraInfo, Number, ReservedName
 
 
 @skipUnlessDBFeature('supports_select_union')
@@ -252,6 +252,39 @@ def test_union_multiple_models_with_values_list_and_order_by_extra_select(self):
             [reserved_name.pk],
         )
 
+    def test_union_in_subquery(self):
+        ReservedName.objects.bulk_create([
+            ReservedName(name='rn1', order=8),
+            ReservedName(name='rn2', order=1),
+            ReservedName(name='rn3', order=5),
+        ])
+        qs1 = Number.objects.filter(num__gt=7, num=OuterRef('order'))
+        qs2 = Number.objects.filter(num__lt=2, num=OuterRef('order'))
+        self.assertCountEqual(
+            ReservedName.objects.annotate(
+                number=Subquery(qs1.union(qs2).values('num')),
+            ).filter(number__isnull=False).values_list('order', flat=True),
+            [8, 1],
+        )
+
+    def test_union_in_subquery_related_outerref(self):
+        e1 = ExtraInfo.objects.create(value=7, info='e3')
+        e2 = ExtraInfo.objects.create(value=5, info='e2')
+        e3 = ExtraInfo.objects.create(value=1, info='e1')
+        Author.objects.bulk_create([
+            Author(name='a1', num=1, extra=e1),
+            Author(name='a2', num=3, extra=e2),
+            Author(name='a3', num=2, extra=e3),
+        ])
+        qs1 = ExtraInfo.objects.order_by().filter(value=OuterRef('num'))
+        qs2 = ExtraInfo.objects.order_by().filter(value__lt=OuterRef('extra__value'))
+        qs = Author.objects.annotate(
+            info=Subquery(qs1.union(qs2).values('info')[:1]),
+        ).filter(info__isnull=False).values_list('name', flat=True)
+        self.assertCountEqual(qs, ['a1', 'a2'])
+        # Combined queries don't mutate.
+        self.assertCountEqual(qs, ['a1', 'a2'])
+
     def test_count_union(self):
         qs1 = Number.objects.filter(num__lte=1).values('num')
         qs2 = Number.objects.filter(num__gte=2, num__lte=3).values('num')