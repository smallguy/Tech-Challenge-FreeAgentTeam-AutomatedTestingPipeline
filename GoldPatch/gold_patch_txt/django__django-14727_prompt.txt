# 修复代码生成提示词（实例ID：django__django-14727）
## 代码仓库
django/django

## 原始问题描述
Naming an incompletely applied squashed migration as a migration target fails with bare NodeNotFoundError
Description
	
In Line 205-208 in django/db/migrations/loader.py replacement migrations (created with squash) are checked if they can be applied. If any of the to be replaced migrations isn't already applied the replacement migration is not added to the nodes list.
This leads to the fact that if some of the migrations are removed or not completely applied before the squash is added and there is a dependency on the replacement migration, the user gets a 'NodeNotFoundError' where the replacement migration that is not being applied because of line 206 is the missing one.
This is very confusing to the user, raising a warning in line 208 would inform the user that the squashed migration can not be applied because not all the 'child' migrations are applied. 
Had to debug into that to figure that out.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py
--- a/tests/migrations/test_commands.py
+++ b/tests/migrations/test_commands.py
@@ -951,6 +951,34 @@ def test_migrate_record_squashed(self):
         )
         # No changes were actually applied so there is nothing to rollback
 
+    def test_migrate_partially_applied_squashed_migration(self):
+        """
+        Migrating to a squashed migration specified by name should succeed
+        even if it is partially applied.
+        """
+        with self.temporary_migration_module(module='migrations.test_migrations'):
+            recorder = MigrationRecorder(connection)
+            try:
+                call_command('migrate', 'migrations', '0001_initial', verbosity=0)
+                call_command(
+                    'squashmigrations',
+                    'migrations',
+                    '0002',
+                    interactive=False,
+                    verbosity=0,
+                )
+                call_command(
+                    'migrate',
+                    'migrations',
+                    '0001_squashed_0002_second',
+                    verbosity=0,
+                )
+                applied_migrations = recorder.applied_migrations()
+                self.assertIn(('migrations', '0002_second'), applied_migrations)
+            finally:
+                # Unmigrate everything.
+                call_command('migrate', 'migrations', 'zero', verbosity=0)
+
     @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
     def test_migrate_inconsistent_history(self):
         """
diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py
--- a/tests/migrations/test_loader.py
+++ b/tests/migrations/test_loader.py
@@ -179,9 +179,11 @@ def test_name_match(self):
             migration_loader.get_migration_by_prefix("migrations", "0001").name,
             "0001_initial",
         )
-        with self.assertRaises(AmbiguityError):
+        msg = "There is more than one migration for 'migrations' with the prefix '0'"
+        with self.assertRaisesMessage(AmbiguityError, msg):
             migration_loader.get_migration_by_prefix("migrations", "0")
-        with self.assertRaises(KeyError):
+        msg = "There is no migration for 'migrations' with the prefix 'blarg'"
+        with self.assertRaisesMessage(KeyError, msg):
             migration_loader.get_migration_by_prefix("migrations", "blarg")
 
     def test_load_import_error(self):
@@ -297,7 +299,7 @@ def num_nodes():
         loader.build_graph()
         self.assertEqual(num_nodes(), 3)
 
-        # Starting at 5 to 7 we are passed the squashed migrations
+        # Starting at 5 to 7 we are past the squashed migrations.
         self.record_applied(recorder, 'migrations', '5_auto')
         loader.build_graph()
         self.assertEqual(num_nodes(), 2)