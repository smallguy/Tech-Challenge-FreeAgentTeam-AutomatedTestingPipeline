# 修复代码生成提示词（实例ID：sympy__sympy-12945）
## 代码仓库
sympy/sympy

## 原始问题描述
Assumptions do not work for Functions
```
In [73]: Function('W', real=True)(x).expand(complex=True)
Out[73]: re(W(re(x) + ⅈ⋅im(x))) + ⅈ⋅im(W(re(x) + ⅈ⋅im(x)))

In [74]: Function('W', real=True)(x).is_real
None

It should also inherit any assumptions from Symbol if created using Symbol.__call__.
```

Original issue for #6494: http://code.google.com/p/sympy/issues/detail?id=3395
Original author: https://code.google.com/u/asmeurer@gmail.com/



## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_function.py b/sympy/core/tests/test_function.py
--- a/sympy/core/tests/test_function.py
+++ b/sympy/core/tests/test_function.py
@@ -828,3 +828,34 @@ def test_issue_12005():
     e5 = Subs(Derivative(f(x), x), (y, z), (y, z))
     assert e5.diff(x) == Derivative(f(x), x, x)
     assert f(g(x)).diff(g(x), g(x)) == Subs(Derivative(f(y), y, y), (y,), (g(x),))
+
+def test_undefined_function_eq():
+    f = Function('f')
+    f2 = Function('f')
+    g = Function('g')
+    f_real = Function('f', is_real=True)
+
+    # This test may only be meaningful if the cache is turned off
+    assert f == f2
+    assert hash(f) == hash(f2)
+    assert f == f
+
+    assert f != g
+
+    assert f != f_real
+
+def test_function_assumptions():
+    x = Symbol('x')
+    f = Function('f')
+    f_real = Function('f', real=True)
+
+    assert f != f_real
+    assert f(x) != f_real(x)
+
+    assert f(x).is_real is None
+    assert f_real(x).is_real is True
+
+    # Can also do it this way, but it won't be equal to f_real because of the
+    # way UndefinedFunction.__new__ works.
+    f_real2 = Function('f', is_real=True)
+    assert f_real2(x).is_real is True
diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py
--- a/sympy/utilities/tests/test_lambdify.py
+++ b/sympy/utilities/tests/test_lambdify.py
@@ -610,7 +610,7 @@ def test_imps():
     func = sympy.Function('myfunc')
     assert not hasattr(func, '_imp_')
     my_f = implemented_function(func, lambda x: 2*x)
-    assert hasattr(func, '_imp_')
+    assert hasattr(my_f, '_imp_')
     # Error for functions with same name and different implementation
     f2 = implemented_function("f", lambda x: x + 101)
     raises(ValueError, lambda: lambdify(x, f(f2(x))))