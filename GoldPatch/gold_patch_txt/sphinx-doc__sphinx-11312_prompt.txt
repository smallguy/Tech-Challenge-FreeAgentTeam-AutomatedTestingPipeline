# 修复代码生成提示词（实例ID：sphinx-doc__sphinx-11312）
## 代码仓库
sphinx-doc/sphinx

## 原始问题描述
util.inspect.object_description: does not emit reliable ordering for a set nested within another collection
### Describe the bug

### Summary
Differences appear in some `sphinx` v5.3.0 generated `set` object descriptions for `alembic` v1.8.1, as demonstrated by [recent results visible on the Reproducible Builds diffoscope dashboard](https://tests.reproducible-builds.org/debian/rb-pkg/unstable/amd64/diffoscope-results/alembic.html).

Arguably it could make sense for code authors to intentionally write `set` elements in their code files in a way that does not correspond to their computed sort order -- as a means to communicate with human readers about abstract ideas that aren't relevant to computers at runtime, for example.

However, the current behaviour does result in non-reproducible documentation output.

### Details
In particular, the ordering of a class attribute with a value that contains a set-within-a-tuple seems unreliable across differing builds:

https://github.com/sqlalchemy/alembic/blob/a968c9d2832173ee7d5dde50c7573f7b99424c38/alembic/ddl/impl.py#L90

... is emitted variously as ...

```
<span·class="pre">({'NUMERIC',</span>·<span·class="pre">'DECIMAL'},)</span>
```

... or ...

```
<span·class="pre">({'DECIMAL',</span>·<span·class="pre">'NUMERIC'},)</span>
```

cc @lamby who has been [investigating a fix on the reproducible-builds mailing list](https://lists.reproducible-builds.org/pipermail/rb-general/2023-February/002862.html).

### How to Reproduce

It is not yet clear to me exactly what circumstances cause the ordering of elements to vary - and it's OK not to proceed until that's figured out (maybe not a blocker, but it would be nice to have confidence about the cause).

From searching around on previous issues while writing up this bugreport: I wonder if this could be an edge-case for / follow-up to #4834.

### Environment Information

Although these build log links are somewhat ephemeral, the system environment details for two builds that produce differing output are visible at:

- https://tests.reproducible-builds.org/debian/rbuild/unstable/amd64/alembic_1.8.1-2.rbuild.log.gz
- https://tests.reproducible-builds.org/debian/logs/unstable/amd64/alembic_1.8.1-2.build2.log.gz


### Sphinx extensions

```python
https://github.com/sqlalchemy/alembic/blob/rel_1_8_1/docs/build/conf.py#L36-L42


sphinx.ext.autodoc
sphinx.ext.intersphinx
changelog
sphinx_paramlinks
sphinx_copybutton
```


### Additional context

_No response_


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py
--- a/tests/test_util_inspect.py
+++ b/tests/test_util_inspect.py
@@ -503,10 +503,32 @@ def test_set_sorting():
     assert description == "{'a', 'b', 'c', 'd', 'e', 'f', 'g'}"
 
 
+def test_set_sorting_enum():
+    class MyEnum(enum.Enum):
+        a = 1
+        b = 2
+        c = 3
+
+    set_ = set(MyEnum)
+    description = inspect.object_description(set_)
+    assert description == "{MyEnum.a, MyEnum.b, MyEnum.c}"
+
+
 def test_set_sorting_fallback():
     set_ = {None, 1}
     description = inspect.object_description(set_)
-    assert description in ("{1, None}", "{None, 1}")
+    assert description == "{1, None}"
+
+
+def test_deterministic_nested_collection_descriptions():
+    # sortable
+    assert inspect.object_description([{1, 2, 3, 10}]) == "[{1, 2, 3, 10}]"
+    assert inspect.object_description(({1, 2, 3, 10},)) == "({1, 2, 3, 10},)"
+    # non-sortable (elements of varying datatype)
+    assert inspect.object_description([{None, 1}]) == "[{1, None}]"
+    assert inspect.object_description(({None, 1},)) == "({1, None},)"
+    assert inspect.object_description([{None, 1, 'A'}]) == "[{'A', 1, None}]"
+    assert inspect.object_description(({None, 1, 'A'},)) == "({'A', 1, None},)"
 
 
 def test_frozenset_sorting():
@@ -518,7 +540,39 @@ def test_frozenset_sorting():
 def test_frozenset_sorting_fallback():
     frozenset_ = frozenset((None, 1))
     description = inspect.object_description(frozenset_)
-    assert description in ("frozenset({1, None})", "frozenset({None, 1})")
+    assert description == "frozenset({1, None})"
+
+
+def test_nested_tuple_sorting():
+    tuple_ = ({"c", "b", "a"},)  # nb. trailing comma
+    description = inspect.object_description(tuple_)
+    assert description == "({'a', 'b', 'c'},)"
+
+    tuple_ = ({"c", "b", "a"}, {"f", "e", "d"})
+    description = inspect.object_description(tuple_)
+    assert description == "({'a', 'b', 'c'}, {'d', 'e', 'f'})"
+
+
+def test_recursive_collection_description():
+    dict_a_, dict_b_ = {"a": 1}, {"b": 2}
+    dict_a_["link"], dict_b_["link"] = dict_b_, dict_a_
+    description_a, description_b = (
+        inspect.object_description(dict_a_),
+        inspect.object_description(dict_b_),
+    )
+    assert description_a == "{'a': 1, 'link': {'b': 2, 'link': dict(...)}}"
+    assert description_b == "{'b': 2, 'link': {'a': 1, 'link': dict(...)}}"
+
+    list_c_, list_d_ = [1, 2, 3, 4], [5, 6, 7, 8]
+    list_c_.append(list_d_)
+    list_d_.append(list_c_)
+    description_c, description_d = (
+        inspect.object_description(list_c_),
+        inspect.object_description(list_d_),
+    )
+
+    assert description_c == "[1, 2, 3, 4, [5, 6, 7, 8, list(...)]]"
+    assert description_d == "[5, 6, 7, 8, [1, 2, 3, 4, list(...)]]"
 
 
 def test_dict_customtype():