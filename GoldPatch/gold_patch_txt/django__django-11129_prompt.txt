# 修复代码生成提示词（实例ID：django__django-11129）
## 代码仓库
django/django

## 原始问题描述
Incorrect error message with QuerySet.update() that requires a join on an annotated F expression
Description
	 
		(last modified by Asif Saifuddin Auvi)
	 
I ran into a bit of a nasty error yesterday on Django 1.11, Postgres 9.5 where I was trying to do an update using an F expression where the value in that expression referred to an annotation of an annotation, each using a Case statement inside the annotation. The error message it was giving me was something like the following:
ProgrammingError						 Traceback (most recent call last)
<ipython-input-1-29e48364245c> in <module>()
----> 1 MyModel.objects.causing_problems()
/usr/src/app/apps/myapp/managers.py in causing_problems(self)
	833				 ).update(		
--> 834						 my_field=F('my_annotated_field'),
	835				 )
	836 
/usr/src/app/apps/django/db/models/query.py in update(self, **kwargs)
	645		 query._annotations = None
	646		 with transaction.atomic(using=self.db, savepoint=False):
--> 647			 rows = query.get_compiler(self.db).execute_sql(CURSOR)
	648		 self._result_cache = None
	649		 return rows
/usr/src/app/apps/django/db/models/sql/compiler.py in execute_sql(self, result_type)
 1189		 related queries are not available.
 1190		 """
-> 1191		 cursor = super(SQLUpdateCompiler, self).execute_sql(result_type)
 1192		 try:
 1193			 rows = cursor.rowcount if cursor else 0
/usr/src/app/apps/django/db/models/sql/compiler.py in execute_sql(self, result_type, chunked_fetch)
	884				 # silencing when dropping Python 2 compatibility.
	885				 pass
--> 886			 raise original_exception
	887 
	888		 if result_type == CURSOR:
ProgrammingError: missing FROM-clause entry for table "myapp_mymodel"
LINE 1: ...false END, "a_field" = CASE WHEN CASE WHEN ("myapp_my...
Spent a while trying to debug where it was going wrong, ended up narrowing down the problem to trying to update a field using an F expression on an annotated field which included a join in it. I'm not sure if better error message would have helped in my case but in the much simpler test attached it'd be useful if the first and second assertions raised the same or similar error message.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/update/tests.py b/tests/update/tests.py
--- a/tests/update/tests.py
+++ b/tests/update/tests.py
@@ -1,5 +1,6 @@
 from django.core.exceptions import FieldError
 from django.db.models import Count, F, Max
+from django.db.models.functions import Concat, Lower
 from django.test import TestCase
 
 from .models import A, B, Bar, D, DataPoint, Foo, RelatedPoint
@@ -182,16 +183,19 @@ def test_update_annotated_multi_table_queryset(self):
         # Update where annotation is used for filtering
         qs = DataPoint.objects.annotate(related_count=Count('relatedpoint'))
         self.assertEqual(qs.filter(related_count=1).update(value='Foo'), 1)
-        # Update where annotation is used in update parameters
-        # #26539 - This isn't forbidden but also doesn't generate proper SQL
-        # qs = RelatedPoint.objects.annotate(data_name=F('data__name'))
-        # updated = qs.update(name=F('data_name'))
-        # self.assertEqual(updated, 1)
         # Update where aggregation annotation is used in update parameters
         qs = RelatedPoint.objects.annotate(max=Max('data__value'))
-        msg = (
-            'Aggregate functions are not allowed in this query '
-            '(name=Max(Col(update_datapoint, update.DataPoint.value))).'
-        )
+        msg = 'Joined field references are not permitted in this query'
         with self.assertRaisesMessage(FieldError, msg):
             qs.update(name=F('max'))
+
+    def test_update_with_joined_field_annotation(self):
+        msg = 'Joined field references are not permitted in this query'
+        for annotation in (
+            F('data__name'),
+            Lower('data__name'),
+            Concat('data__name', 'data__value'),
+        ):
+            with self.subTest(annotation=annotation):
+                with self.assertRaisesMessage(FieldError, msg):
+                    RelatedPoint.objects.annotate(new_name=annotation).update(name=F('new_name'))