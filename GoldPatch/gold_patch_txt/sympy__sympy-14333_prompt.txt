# 修复代码生成提示词（实例ID：sympy__sympy-14333）
## 代码仓库
sympy/sympy

## 原始问题描述
Modular inverse for negative modulo and sign resolve
SymPy assigns `mod_inverse(a,m)` the same sign as `a`.
Mathematically, `mod m` has range `[0,m)` for `m>0` , `(m,0]` for `m<0`.

The former sign assignment is used in C/C++/Java built-in modulo operator as `-2%5` returns `-2`.
The latter sign assignment is used in Python's built-in modulo operator as `-2%5` returns `3`.

```python
>> mod_inverse(2,5)
3

>> mod_inverse(-2,5)
-3
```

SymPy does not find modular inverses for negative modulo (because of the `m>1` check).
```
>> mod_inverse(2,-5)
>> mod_inverse(-2,-5)
```

Moreover, as checked from WA (uses the same sign as `m` rule)
[mod_inverse(-2,+5) = 2](http://www.wolframalpha.com/input/?i=modular+inverse+of+-2+modulo+5)
[mod_inverse(+2,-5) = -2](http://www.wolframalpha.com/input/?i=modular+inverse+of+2+modulo+-5)
[mod_inverse(-2,-5) = -3](http://www.wolframalpha.com/input/?i=modular+inverse+of+-2+modulo+-5)


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py
--- a/sympy/core/tests/test_numbers.py
+++ b/sympy/core/tests/test_numbers.py
@@ -1709,7 +1709,10 @@ def test_mod_inverse():
     assert mod_inverse(5823991, 3299) == 1442
     assert mod_inverse(123, 44) == 39
     assert mod_inverse(2, 5) == 3
-    assert mod_inverse(-2, 5) == -3
+    assert mod_inverse(-2, 5) == 2
+    assert mod_inverse(2, -5) == -2
+    assert mod_inverse(-2, -5) == -3
+    assert mod_inverse(-3, -7) == -5
     x = Symbol('x')
     assert S(2).invert(x) == S.Half
     raises(TypeError, lambda: mod_inverse(2, x))