# 修复代码生成提示词（实例ID：sphinx-doc__sphinx-9547）
## 代码仓库
sphinx-doc/sphinx

## 原始问题描述
Missing support for GNU extension types like `_Complex` or `_Fract`
I'm currently working on the transition of the GNU C compiler (GCC) manuals and I noticed there are unsupported C extensions like:

```
.. c:function:: complex long foo(int)
.. c:function:: _Complex long foo(int)
.. c:function:: long fract __satfractunssisq (unsigned int a)

  My function.
```

where I see the following parsing error:
```
/home/marxin/Programming/texi2rst-generated/sphinx/demo/demo.rst:66: WARNING: Invalid C declaration: Expected identifier, got user-defined keyword: complex. Remove it from c_extra_keywords to allow it as identifier.
Currently c_extra_keywords is ['alignas', 'alignof', 'bool', 'complex', 'imaginary', 'noreturn', 'static_assert', 'thread_local']. [error at 7]
  complex long foo(int)
  -------^
/home/marxin/Programming/texi2rst-generated/sphinx/demo/demo.rst:67: WARNING: Invalid C declaration: Expected identifier in nested name, got keyword: _Complex [error at 8]
  _Complex long foo(int)
  --------^
/home/marxin/Programming/texi2rst-generated/sphinx/demo/demo.rst:68: WARNING: Error in declarator or parameters
Invalid C declaration: Expecting "(" in parameters. [error at 11]
  long fract __satfractunssisq (unsigned int a)
  -----------^
```

Right now, there's some special casing for e.g. 'unsigned' type:
https://github.com/sphinx-doc/sphinx/blob/6ac326e019db949c2c8d58f523c2534be36d4e62/sphinx/domains/c.py#L2566-L2585

One possible fix is adding the mentioned C extension handling for the following types:
https://gcc.gnu.org/onlinedocs/gcc/Fixed-Point.html
https://gcc.gnu.org/onlinedocs/gcc/Complex.html

or I can see a domain parser can become public via an API entry point:
https://github.com/sphinx-doc/sphinx/blob/6ac326e019db949c2c8d58f523c2534be36d4e62/sphinx/domains/c.py#L2128-L2131

What do you think?


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/test_domain_c.py b/tests/test_domain_c.py
--- a/tests/test_domain_c.py
+++ b/tests/test_domain_c.py
@@ -275,6 +275,62 @@ def exprCheck(expr, output=None):
     exprCheck('a or_eq 5')
 
 
+def test_domain_c_ast_fundamental_types():
+    def types():
+        def signed(t):
+            yield t
+            yield 'signed  ' + t
+            yield 'unsigned  ' + t
+
+        # integer types
+        # -------------
+        yield 'void'
+        yield from ('_Bool', 'bool')
+        yield from signed('char')
+        yield from signed('short')
+        yield from signed('short int')
+        yield from signed('int')
+        yield from ('signed', 'unsigned')
+        yield from signed('long')
+        yield from signed('long int')
+        yield from signed('long long')
+        yield from signed('long long int')
+        yield from ('__int128', '__uint128')
+        # extensions
+        for t in ('__int8', '__int16', '__int32', '__int64', '__int128'):
+            yield from signed(t)
+
+        # floating point types
+        # --------------------
+        yield from ('_Decimal32', '_Decimal64', '_Decimal128')
+        for f in ('float', 'double', 'long double'):
+            yield f
+            yield from (f + "  _Complex", f + "  complex")
+            yield from ("_Complex  " + f, "complex  " + f)
+            yield from ("_Imaginary  " + f, "imaginary  " + f)
+        # extensions
+        # https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html#Floating-Types
+        yield from ('__float80', '_Float64x',
+                    '__float128', '_Float128',
+                    '__ibm128')
+        # https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html#Half-Precision
+        yield '__fp16'
+
+        # fixed-point types (extension)
+        # -----------------------------
+        # https://gcc.gnu.org/onlinedocs/gcc/Fixed-Point.html#Fixed-Point
+        for sat in ('', '_Sat  '):
+            for t in ('_Fract', 'fract', '_Accum', 'accum'):
+                for size in ('short  ', '', 'long  ', 'long long  '):
+                    for tt in signed(size + t):
+                        yield sat + tt
+
+    for t in types():
+        input = "{key}%s foo" % t
+        output = ' '.join(input.split())
+        check('type', input, {1: 'foo'}, key='typedef', output=output)
+
+
 def test_domain_c_ast_type_definitions():
     check('type', "{key}T", {1: "T"})
 
diff --git a/tests/test_domain_cpp.py b/tests/test_domain_cpp.py
--- a/tests/test_domain_cpp.py
+++ b/tests/test_domain_cpp.py
@@ -123,7 +123,9 @@ def test_domain_cpp_ast_fundamental_types():
         def makeIdV1():
             if t == 'decltype(auto)':
                 return None
-            id = t.replace(" ", "-").replace("long", "l").replace("int", "i")
+            id = t.replace(" ", "-").replace("long", "l")
+            if "__int" not in t:
+                id = id.replace("int", "i")
             id = id.replace("bool", "b").replace("char", "c")
             id = id.replace("wc_t", "wchar_t").replace("c16_t", "char16_t")
             id = id.replace("c8_t", "char8_t")
@@ -135,7 +137,9 @@ def makeIdV2():
             if t == "std::nullptr_t":
                 id = "NSt9nullptr_tE"
             return "1f%s" % id
-        check("function", "void f(%s arg)" % t, {1: makeIdV1(), 2: makeIdV2()})
+        input = "void f(%s arg)" % t.replace(' ', '  ')
+        output = "void f(%s arg)" % t
+        check("function", input, {1: makeIdV1(), 2: makeIdV2()}, output=output)
 
 
 def test_domain_cpp_ast_expressions():