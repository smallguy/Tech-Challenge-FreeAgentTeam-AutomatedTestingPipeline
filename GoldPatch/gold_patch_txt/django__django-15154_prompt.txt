# 修复代码生成提示词（实例ID：django__django-15154）
## 代码仓库
django/django

## 原始问题描述
Detecting uniqueness doesn't work for models with functional unique constraints.
Description
	
When creating a new object from Django Administration site, I'm getting an error "Tag with this already exists.". (Tag is my model name)
I'm using on this model the new functional unique constraints introducted in Django 4.0 (​https://docs.djangoproject.com/en/dev/ref/models/constraints/#django.db.models.UniqueConstraint).
I suppose this is related to the contraints put on the model. However, creating a Tag object with code - e.g. Tag.objects.create(...) - works fine. It only fails in Django admin. I'm not sure if it's a bug or misunderstanding/misconfiguration on my side?
This is my model:
class Tag(models.Model):
	"""Basic tag model."""
	# When using get_or_create, we need to pass tag name as a default value, like this:
	# Tag.objects.get_or_create(defaults={'name': tag}, name__iexact=tag, user=request.user)
	user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, verbose_name=_('user'))
	name = models.CharField(max_length=50, db_index=False, verbose_name=_('name'),
							blank=False, # It's the default behavior, but let's be explicit
							validators=[RegexValidator(regex=r'[A-z0-9À-ž\s]+',
													 message='This field accepts only letters, digits and space.')])
	slug = models.SlugField(max_length=50, verbose_name=_('slug'))
	class Meta:
		ordering = ['name']
		# Make sure tag name:
		# - are unique per user
		# - are case insensitive (prevent adding "test" if "Test" already exists)
		# - aren't empty
		constraints = [models.UniqueConstraint(fields=['user', 'name'],
											 name='%(app_label)s_%(class)s_name_unique_per_user'),
					 models.UniqueConstraint(Lower('name'),
											 name='%(app_label)s_%(class)s_name_case_insensitive'),
					 models.CheckConstraint(check=models.Q(name__length__gt=0),
											 name='%(app_label)s_%(class)s_name_not_empty')]
(snip)
This is the admin configuration:
@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
	list_display = ('pk', 'user', 'name', 'slug')
	list_display_links = ['pk']
	fields = ('user', 'name',)
	list_filter = ('user__email',)
	search_fields = ('name',)


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/validation/models.py b/tests/validation/models.py
--- a/tests/validation/models.py
+++ b/tests/validation/models.py
@@ -2,6 +2,7 @@
 
 from django.core.exceptions import ValidationError
 from django.db import models
+from django.db.models.functions import Lower
 
 
 def validate_answer_to_universe(value):
@@ -125,3 +126,13 @@ class GenericIPAddressTestModel(models.Model):
 
 class GenericIPAddrUnpackUniqueTest(models.Model):
     generic_v4unpack_ip = models.GenericIPAddressField(null=True, blank=True, unique=True, unpack_ipv4=True)
+
+
+class UniqueFuncConstraintModel(models.Model):
+    field = models.CharField(max_length=255)
+
+    class Meta:
+        required_db_features = {'supports_expression_indexes'}
+        constraints = [
+            models.UniqueConstraint(Lower('field'), name='func_lower_field_uq'),
+        ]
diff --git a/tests/validation/test_unique.py b/tests/validation/test_unique.py
--- a/tests/validation/test_unique.py
+++ b/tests/validation/test_unique.py
@@ -8,7 +8,8 @@
 
 from .models import (
     CustomPKModel, FlexibleDatePost, ModelToValidate, Post, UniqueErrorsModel,
-    UniqueFieldsModel, UniqueForDateModel, UniqueTogetherModel,
+    UniqueFieldsModel, UniqueForDateModel, UniqueFuncConstraintModel,
+    UniqueTogetherModel,
 )
 
 
@@ -86,6 +87,13 @@ def test_unique_for_date_exclusion(self):
         ), m._get_unique_checks(exclude='start_date')
         )
 
+    def test_func_unique_constraint_ignored(self):
+        m = UniqueFuncConstraintModel()
+        self.assertEqual(
+            m._get_unique_checks(),
+            ([(UniqueFuncConstraintModel, ('id',))], []),
+        )
+
 
 class PerformUniqueChecksTest(TestCase):
     def test_primary_key_unique_check_not_performed_when_adding_and_pk_not_specified(self):
@@ -108,6 +116,10 @@ def test_primary_key_unique_check_not_performed_when_not_adding(self):
             mtv = ModelToValidate(number=10, name='Some Name')
             mtv.full_clean()
 
+    def test_func_unique_check_not_performed(self):
+        with self.assertNumQueries(0):
+            UniqueFuncConstraintModel(field='some name').full_clean()
+
     def test_unique_for_date(self):
         Post.objects.create(
             title="Django 1.0 is released", slug="Django 1.0",