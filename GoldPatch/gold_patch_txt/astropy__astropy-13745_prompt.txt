# 修复代码生成提示词（实例ID：astropy__astropy-13745）
## 代码仓库
astropy/astropy

## 原始问题描述
float32 representation of pi/2 is rejected by `Latitude`
<!-- This comments are hidden when you submit the issue,
so you do not need to remove them! -->

<!-- Please be sure to check out our contributing guidelines,
https://github.com/astropy/astropy/blob/main/CONTRIBUTING.md .
Please be sure to check out our code of conduct,
https://github.com/astropy/astropy/blob/main/CODE_OF_CONDUCT.md . -->

<!-- Please have a search on our GitHub repository to see if a similar
issue has already been posted.
If a similar issue is closed, have a quick look to see if you are satisfied
by the resolution.
If not please go ahead and open an issue! -->

<!-- Please check that the development version still produces the same bug.
You can install development version with
pip install git+https://github.com/astropy/astropy
command. -->

### Description

The closest float32 value to pi/2 is by accident slightly larger than pi/2:

```
In [5]: np.pi/2
Out[5]: 1.5707963267948966

In [6]: np.float32(np.pi/2)
Out[6]: 1.5707964
```

Astropy checks using float64 precision, rejecting "valid" alt values (e.g. float32 values read from files):

```

In [1]: from astropy.coordinates import Latitude

In [2]: import numpy as np

In [3]: lat = np.float32(np.pi/2)

In [4]: Latitude(lat, 'rad')
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In [4], line 1
----> 1 Latitude(lat, 'rad')

File ~/.local/lib/python3.10/site-packages/astropy/coordinates/angles.py:564, in Latitude.__new__(cls, angle, unit, **kwargs)
    562     raise TypeError("A Latitude angle cannot be created from a Longitude angle")
    563 self = super().__new__(cls, angle, unit=unit, **kwargs)
--> 564 self._validate_angles()
    565 return self

File ~/.local/lib/python3.10/site-packages/astropy/coordinates/angles.py:585, in Latitude._validate_angles(self, angles)
    582     invalid_angles = (np.any(angles.value < lower) or
    583                       np.any(angles.value > upper))
    584 if invalid_angles:
--> 585     raise ValueError('Latitude angle(s) must be within -90 deg <= angle <= 90 deg, '
    586                      'got {}'.format(angles.to(u.degree)))

ValueError: Latitude angle(s) must be within -90 deg <= angle <= 90 deg, got 90.00000250447816 deg
```

### Expected behavior

Be lenient? E.g. only make the comparison up to float 32 precision?

### Actual behavior
See error above

### Steps to Reproduce

See snippet above.

### System Details
<!-- Even if you do not think this is necessary, it is useful information for the maintainers.
Please run the following snippet and paste the output below:
import platform; print(platform.platform())
import sys; print("Python", sys.version)
import numpy; print("Numpy", numpy.__version__)
import erfa; print("pyerfa", erfa.__version__)
import astropy; print("astropy", astropy.__version__)
import scipy; print("Scipy", scipy.__version__)
import matplotlib; print("Matplotlib", matplotlib.__version__)
-->
```
Linux-5.15.65-1-MANJARO-x86_64-with-glibc2.36
Python 3.10.7 (main, Sep  6 2022, 21:22:27) [GCC 12.2.0]
Numpy 1.23.3
pyerfa 2.0.0.1
astropy 5.0.1
Scipy 1.9.1
Matplotlib 3.5.2
```


## 参考黄金补丁（正确的修复方案）
diff --git a/astropy/coordinates/tests/test_angles.py b/astropy/coordinates/tests/test_angles.py
--- a/astropy/coordinates/tests/test_angles.py
+++ b/astropy/coordinates/tests/test_angles.py
@@ -1092,3 +1092,54 @@ def test_str_repr_angles_nan(cls, input, expstr, exprepr):
     # Deleting whitespaces since repr appears to be adding them for some values
     # making the test fail.
     assert repr(q).replace(" ", "") == f'<{cls.__name__}{exprepr}>'.replace(" ","")
+
+
+@pytest.mark.parametrize("sign", (-1, 1))
+@pytest.mark.parametrize(
+    "value,expected_value,dtype,expected_dtype",
+    [
+        (np.pi / 2, np.pi / 2, None, np.float64),
+        (np.pi / 2, np.pi / 2, np.float64, np.float64),
+        (np.float32(np.pi / 2), np.float32(np.pi / 2), None, np.float32),
+        (np.float32(np.pi / 2), np.float32(np.pi / 2), np.float32, np.float32),
+        # these cases would require coercing the float32 value to the float64 value
+        # making validate have side effects, so it's not implemented for now
+        # (np.float32(np.pi / 2), np.pi / 2, np.float64, np.float64),
+        # (np.float32(-np.pi / 2), -np.pi / 2, np.float64, np.float64),
+    ]
+)
+def test_latitude_limits(value, expected_value, dtype, expected_dtype, sign):
+    """
+    Test that the validation of the Latitude value range in radians works
+    in both float32 and float64.
+
+    As discussed in issue #13708, before, the float32 represenation of pi/2
+    was rejected as invalid because the comparison always used the float64
+    representation.
+    """
+    # this prevents upcasting to float64 as sign * value would do
+    if sign < 0:
+        value = -value
+        expected_value = -expected_value
+
+    result = Latitude(value, u.rad, dtype=dtype)
+    assert result.value == expected_value
+    assert result.dtype == expected_dtype
+    assert result.unit == u.rad
+
+
+@pytest.mark.parametrize(
+    "value,dtype",
+    [
+        (0.50001 * np.pi, np.float32),
+        (np.float32(0.50001 * np.pi), np.float32),
+        (0.50001 * np.pi, np.float64),
+    ]
+)
+def test_latitude_out_of_limits(value, dtype):
+    """
+    Test that values slightly larger than pi/2 are rejected for different dtypes.
+    Test cases for issue #13708
+    """
+    with pytest.raises(ValueError, match=r"Latitude angle\(s\) must be within.*"):
+        Latitude(value, u.rad, dtype=dtype)