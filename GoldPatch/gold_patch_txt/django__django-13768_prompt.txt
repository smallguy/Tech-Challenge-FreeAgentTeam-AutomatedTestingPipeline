# 修复代码生成提示词（实例ID：django__django-13768）
## 代码仓库
django/django

## 原始问题描述
Log exceptions handled in Signal.send_robust()
Description
	
As pointed out by ​Haki Benita on Twitter, by default Signal.send_robust() doesn't have any log messages for exceptions raised in receivers. Since Django logs exceptions in other similar situations, such as missing template variables, I think it would be worth adding a logger.exception() call in the except clause of send_robust() . Users would then see such exceptions in their error handling tools, e.g. Sentry, and be able to figure out what action to take from there. Ultimately any *expected* exception should be caught with a try in the receiver function.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py
--- a/tests/dispatch/tests.py
+++ b/tests/dispatch/tests.py
@@ -165,13 +165,28 @@ def test_send_robust_fail(self):
         def fails(val, **kwargs):
             raise ValueError('this')
         a_signal.connect(fails)
-        result = a_signal.send_robust(sender=self, val="test")
-        err = result[0][1]
-        self.assertIsInstance(err, ValueError)
-        self.assertEqual(err.args, ('this',))
-        self.assertTrue(hasattr(err, '__traceback__'))
-        self.assertIsInstance(err.__traceback__, TracebackType)
-        a_signal.disconnect(fails)
+        try:
+            with self.assertLogs('django.dispatch', 'ERROR') as cm:
+                result = a_signal.send_robust(sender=self, val='test')
+            err = result[0][1]
+            self.assertIsInstance(err, ValueError)
+            self.assertEqual(err.args, ('this',))
+            self.assertIs(hasattr(err, '__traceback__'), True)
+            self.assertIsInstance(err.__traceback__, TracebackType)
+
+            log_record = cm.records[0]
+            self.assertEqual(
+                log_record.getMessage(),
+                'Error calling '
+                'DispatcherTests.test_send_robust_fail.<locals>.fails in '
+                'Signal.send_robust() (this)',
+            )
+            self.assertIsNotNone(log_record.exc_info)
+            _, exc_value, _ = log_record.exc_info
+            self.assertIsInstance(exc_value, ValueError)
+            self.assertEqual(str(exc_value), 'this')
+        finally:
+            a_signal.disconnect(fails)
         self.assertTestIsClean(a_signal)
 
     def test_disconnection(self):