# 修复代码生成提示词（实例ID：django__django-11085）
## 代码仓库
django/django

## 原始问题描述
Custom model metaclasses cannot access the attribute dict in __init__
Description
	
In Django <=2.2, it is possible for models to define a custom metaclass (as a subclass of models.base.ModelBase) and access the attribute dict of the class being defined:
from django.db import models
class PageBase(models.base.ModelBase):
	def __init__(cls, name, bases, dct):
		super(PageBase, cls).__init__(name, bases, dct)
		if 'magic' in dct:
			print("enabling magic on %s" % (name))
class Page(models.Model, metaclass=PageBase):
	magic = True
	title = models.CharField(max_length=255)
As of commit a68ea231012434b522ce45c513d84add516afa60, this fails because all attributes without a contribute_to_class method are popped from the dict in ModelBase.__new__ .
(This pattern is used by Wagtail's Page model ​https://github.com/wagtail/wagtail/blob/3e1e67021e0a20783ed59e17b43e3c481897fce3/wagtail/core/models.py#L190 , so this is causing various failures against django stable/2.2.x.)


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/model_regress/tests.py b/tests/model_regress/tests.py
--- a/tests/model_regress/tests.py
+++ b/tests/model_regress/tests.py
@@ -2,9 +2,10 @@
 from operator import attrgetter
 
 from django.core.exceptions import ValidationError
-from django.db import router
+from django.db import models, router
 from django.db.models.sql import InsertQuery
 from django.test import TestCase, skipUnlessDBFeature
+from django.test.utils import isolate_apps
 from django.utils.timezone import get_fixed_timezone
 
 from .models import (
@@ -217,6 +218,23 @@ def test_chained_fks(self):
         m3 = Model3.objects.get(model2=1000)
         m3.model2
 
+    @isolate_apps('model_regress')
+    def test_metaclass_can_access_attribute_dict(self):
+        """
+        Model metaclasses have access to the class attribute dict in
+        __init__() (#30254).
+        """
+        class HorseBase(models.base.ModelBase):
+            def __init__(cls, name, bases, attrs):
+                super(HorseBase, cls).__init__(name, bases, attrs)
+                cls.horns = (1 if 'magic' in attrs else 0)
+
+        class Horse(models.Model, metaclass=HorseBase):
+            name = models.CharField(max_length=255)
+            magic = True
+
+        self.assertEqual(Horse.horns, 1)
+
 
 class ModelValidationTest(TestCase):
     def test_pk_validation(self):