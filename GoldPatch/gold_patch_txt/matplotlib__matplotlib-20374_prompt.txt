# 修复代码生成提示词（实例ID：matplotlib__matplotlib-20374）
## 代码仓库
matplotlib/matplotlib

## 原始问题描述
plot_directive is confused by include directives, part 2 (context option)
### Bug summary

Whenever a file `b.rst` is included in `a.rst` via the RST `include` directive, Sphinx rebuilds the `a.html` page; but in plot_directive, `a.rst` is not considered 'out of date' (as judged by the `out_of_date()` function), because the modification time of `a.rst` was not changed.

This discrepancy is part of the reason why #17860 exists; and while working on it (at PR #20374) I discovered also that figures with the `:context:` option set will get confused. A specific example is shown below. It's quite hard to encounter in real life but it is directly relevant to matplotlib's tests as there is a very similar construct in plots 6-9 of matplotlib's `test_sphinxext.py`.

### Code for reproduction

**conf.py**
```python
extensions = ['matplotlib.sphinxext.plot_directive']
exclude_patterns = ['_build']
```

**index.rst**
```rst
Index
=====

.. toctree::
   
   a
   b
```

**a.rst**
```rst
File A
======

It's important that the first plot produces an image, and also sets a variable
via ``:context:``.


.. plot::
   :context:

   plt.plot(range(2))
   a = 1  

The second plot must not use ``:context:``. It doesn't necessarily have to
produce an image. The important thing is that it must close the figure from the
previous plot, so that the third plot doesn't actually produce an image (if
figures aren't closed, then the third plot will reuse the same image from the
first plot).

.. plot::

   plt.plot(range(3))

The third plot must try to use a variable previously saved in `:context:`` and
must not produce an image.


.. plot::
   :context:

   assert a == 1

Lastly we include another file.

.. include:: b.rst
```

**b.rst**
```rst
File B
======

This can be anything.
```


### Steps to reproduce

1. Put the four files above in a directory and `cd` into it.
2. Build the docs the first time using `sphinx-build -b html . ./_build/html`.
3. Modify `b.rst` in any way.
4. Build the docs again.

### Actual outcome

The third plot in `a.rst` throws an error.

```
/Users/yongrenjie/test/rst/a.rst:21: WARNING: Exception occurred in plotting a-3
 from /Users/yongrenjie/test/rst/a.rst:
Traceback (most recent call last):
  File "/Users/yongrenjie/progs/matplotlib/lib/matplotlib/sphinxext/plot_directive.py", line 497, in _run_code
    exec(code, ns)
  File "<string>", line 1, in <module>
NameError: name 'a' is not defined
```

The reason for this, as suggested above, is because of the `out_of_date()` function. When `sphinx-build` is invoked again, Sphinx decides that both `a.rst` and `b.rst` must be recompiled. Now:

 - Plot 1 is not considered out of date, because the image file already exists and `a.rst` was not modified. So the code is never run and `a` is never saved to the context.
 - Plot 2 is there to ensure that figures are closed prior to Plot 3, so that Plot 3 never generates an image file.
 - Plot 3 is considered out of date, because there is no image file that corresponds to it. Thus it is run again, and doesn't see `a` in the context, hence the warning.

### Expected outcome

There shouldn't be any errors.

One easy way to accomplish this is to make sure that Sphinx re-runs all code snippets which are context-dependent, whenever a file is recompiled. That is, if a plot directive has :context: on, then the code should always be considered out of date regardless of the file modification times.

This will lead to some excessive regeneration of plots whenever included files are modified. For example, in the above code, whenever `b.rst` is modified, Plots 1 and 3 will always be re-created, even if `a.rst` is untouched. But IMO this is more sensible behaviour than the current bug. It would also be in line with what happens if *any* part of `a.rst` is modified, including the text outside the plot directives: all the plots in `a.rst` would be re-created.

This doesn't change the case where neither `a.rst` nor `b.rst` are modified, because in that case Sphinx will never attempt to recompile either file and plot_directive will never be called.


## 参考黄金补丁（正确的修复方案）
diff --git a/lib/matplotlib/tests/test_sphinxext.py b/lib/matplotlib/tests/test_sphinxext.py
--- a/lib/matplotlib/tests/test_sphinxext.py
+++ b/lib/matplotlib/tests/test_sphinxext.py
@@ -3,6 +3,7 @@
 import filecmp
 import os
 from pathlib import Path
+import shutil
 from subprocess import Popen, PIPE
 import sys
 
@@ -13,27 +14,21 @@
 
 
 def test_tinypages(tmpdir):
-    tmp_path = Path(tmpdir)
-    html_dir = tmp_path / 'html'
-    doctree_dir = tmp_path / 'doctrees'
-    # Build the pages with warnings turned into errors
-    cmd = [sys.executable, '-msphinx', '-W', '-b', 'html',
-           '-d', str(doctree_dir),
-           str(Path(__file__).parent / 'tinypages'), str(html_dir)]
-    proc = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True,
-                 env={**os.environ, "MPLBACKEND": ""})
-    out, err = proc.communicate()
+    source_dir = Path(tmpdir) / 'src'
+    shutil.copytree(Path(__file__).parent / 'tinypages', source_dir)
+    html_dir = source_dir / '_build' / 'html'
+    doctree_dir = source_dir / 'doctrees'
 
-    assert proc.returncode == 0, \
-        f"sphinx build failed with stdout:\n{out}\nstderr:\n{err}\n"
-    if err:
-        pytest.fail(f"sphinx build emitted the following warnings:\n{err}")
-
-    assert html_dir.is_dir()
+    # Build the pages with warnings turned into errors
+    build_sphinx_html(source_dir, doctree_dir, html_dir)
 
     def plot_file(num):
         return html_dir / f'some_plots-{num}.png'
 
+    def plot_directive_file(num):
+        # This is always next to the doctree dir.
+        return doctree_dir.parent / 'plot_directive' / f'some_plots-{num}.png'
+
     range_10, range_6, range_4 = [plot_file(i) for i in range(1, 4)]
     # Plot 5 is range(6) plot
     assert filecmp.cmp(range_6, plot_file(5))
@@ -48,6 +43,7 @@ def plot_file(num):
     assert filecmp.cmp(range_4, plot_file(13))
     # Plot 14 has included source
     html_contents = (html_dir / 'some_plots.html').read_bytes()
+
     assert b'# Only a comment' in html_contents
     # check plot defined in external file.
     assert filecmp.cmp(range_4, html_dir / 'range4.png')
@@ -62,3 +58,45 @@ def plot_file(num):
     assert b'plot-directive my-class my-other-class' in html_contents
     # check that the multi-image caption is applied twice
     assert html_contents.count(b'This caption applies to both plots.') == 2
+    # Plot 21 is range(6) plot via an include directive. But because some of
+    # the previous plots are repeated, the argument to plot_file() is only 17.
+    assert filecmp.cmp(range_6, plot_file(17))
+
+    # Modify the included plot
+    contents = (source_dir / 'included_plot_21.rst').read_text()
+    contents = contents.replace('plt.plot(range(6))', 'plt.plot(range(4))')
+    (source_dir / 'included_plot_21.rst').write_text(contents)
+    # Build the pages again and check that the modified file was updated
+    modification_times = [plot_directive_file(i).stat().st_mtime
+                          for i in (1, 2, 3, 5)]
+    build_sphinx_html(source_dir, doctree_dir, html_dir)
+    assert filecmp.cmp(range_4, plot_file(17))
+    # Check that the plots in the plot_directive folder weren't changed.
+    # (plot_directive_file(1) won't be modified, but it will be copied to html/
+    # upon compilation, so plot_file(1) will be modified)
+    assert plot_directive_file(1).stat().st_mtime == modification_times[0]
+    assert plot_directive_file(2).stat().st_mtime == modification_times[1]
+    assert plot_directive_file(3).stat().st_mtime == modification_times[2]
+    assert filecmp.cmp(range_10, plot_file(1))
+    assert filecmp.cmp(range_6, plot_file(2))
+    assert filecmp.cmp(range_4, plot_file(3))
+    # Make sure that figures marked with context are re-created (but that the
+    # contents are the same)
+    assert plot_directive_file(5).stat().st_mtime > modification_times[3]
+    assert filecmp.cmp(range_6, plot_file(5))
+
+
+def build_sphinx_html(source_dir, doctree_dir, html_dir):
+    # Build the pages with warnings turned into errors
+    cmd = [sys.executable, '-msphinx', '-W', '-b', 'html',
+           '-d', str(doctree_dir), str(source_dir), str(html_dir)]
+    proc = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True,
+                 env={**os.environ, "MPLBACKEND": ""})
+    out, err = proc.communicate()
+
+    assert proc.returncode == 0, \
+        f"sphinx build failed with stdout:\n{out}\nstderr:\n{err}\n"
+    if err:
+        pytest.fail(f"sphinx build emitted the following warnings:\n{err}")
+
+    assert html_dir.is_dir()
diff --git a/lib/matplotlib/tests/tinypages/included_plot_21.rst b/lib/matplotlib/tests/tinypages/included_plot_21.rst
new file mode 100644
--- /dev/null
+++ b/lib/matplotlib/tests/tinypages/included_plot_21.rst
@@ -0,0 +1,6 @@
+Plot 21 has length 6
+
+.. plot::
+
+    plt.plot(range(6))
+
diff --git a/lib/matplotlib/tests/tinypages/some_plots.rst b/lib/matplotlib/tests/tinypages/some_plots.rst
--- a/lib/matplotlib/tests/tinypages/some_plots.rst
+++ b/lib/matplotlib/tests/tinypages/some_plots.rst
@@ -166,3 +166,8 @@ scenario:
 
    plt.figure()
    plt.plot(range(4))
+ 
+Plot 21 is generated via an include directive:
+
+.. include:: included_plot_21.rst
+