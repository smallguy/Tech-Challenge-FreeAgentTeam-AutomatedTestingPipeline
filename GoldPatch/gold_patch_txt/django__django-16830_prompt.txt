# 修复代码生成提示词（实例ID：django__django-16830）
## 代码仓库
django/django

## 原始问题描述
force_insert flag is not passed when saving parents on inherited models.
Description
	
We're using non-abstract model inheritance (table per model class) and issuing our own primary keys. When saving we pass force_insert=True to prevent the extra UPDATE statement that precedes the INSERT. The force_insert flag is respected on the child table but not on the parent. So given:
class ParentModel(models.Model):
	id = models.BigIntegerField(primary_key=True)
class ChildModel(ParentModel):
	pass
ChildModel(id=1).save(force_insert=True)
We'll see queries:
UPDATE app_parentmodel (no rows affected)
INSERT app_parentmodel
INSERT app_childmodel
This is because Model.save_base doesn't pass force_insert along to Model._save_parents, and onto Model._save_table. Doing so would prevent the extra UPDATE and respect the spirit of the force_insert feature. This is a change I've made locally and seems to work / is pretty straightforward. I'm curious though if there's intent behind not carrying the force_insert functionality through for parents. I couldn't find any discussion on the topic.
For context about why this is particularly problematic in our case -- we're using MySQL w/ Innodb and Innodb will take out different exclusive locks for the UPDATE and INSERT in question -- so if you're creating new ChildModel instances in parallel you can get deadlocks when multiple threads issue query #1 and then need a lock with insert intention in order to get #2.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/extra_regress/models.py b/tests/extra_regress/models.py
--- a/tests/extra_regress/models.py
+++ b/tests/extra_regress/models.py
@@ -10,7 +10,7 @@ class RevisionableModel(models.Model):
     title = models.CharField(blank=True, max_length=255)
     when = models.DateTimeField(default=datetime.datetime.now)
 
-    def save(self, *args, force_insert=None, force_update=None, **kwargs):
+    def save(self, *args, force_insert=False, force_update=False, **kwargs):
         super().save(
             *args, force_insert=force_insert, force_update=force_update, **kwargs
         )
diff --git a/tests/force_insert_update/models.py b/tests/force_insert_update/models.py
--- a/tests/force_insert_update/models.py
+++ b/tests/force_insert_update/models.py
@@ -30,3 +30,13 @@ class SubSubCounter(SubCounter):
 class WithCustomPK(models.Model):
     name = models.IntegerField(primary_key=True)
     value = models.IntegerField()
+
+
+class OtherSubCounter(Counter):
+    other_counter_ptr = models.OneToOneField(
+        Counter, primary_key=True, parent_link=True, on_delete=models.CASCADE
+    )
+
+
+class DiamondSubSubCounter(SubCounter, OtherSubCounter):
+    pass
diff --git a/tests/force_insert_update/tests.py b/tests/force_insert_update/tests.py
--- a/tests/force_insert_update/tests.py
+++ b/tests/force_insert_update/tests.py
@@ -1,9 +1,11 @@
-from django.db import DatabaseError, IntegrityError, transaction
+from django.db import DatabaseError, IntegrityError, models, transaction
 from django.test import TestCase
 
 from .models import (
     Counter,
+    DiamondSubSubCounter,
     InheritedCounter,
+    OtherSubCounter,
     ProxyCounter,
     SubCounter,
     SubSubCounter,
@@ -76,6 +78,29 @@ def test_force_update_on_inherited_model_without_fields(self):
 
 
 class ForceInsertInheritanceTests(TestCase):
+    def test_force_insert_not_bool_or_tuple(self):
+        msg = "force_insert must be a bool or tuple."
+        with self.assertRaisesMessage(TypeError, msg), transaction.atomic():
+            Counter().save(force_insert=1)
+        with self.assertRaisesMessage(TypeError, msg), transaction.atomic():
+            Counter().save(force_insert="test")
+        with self.assertRaisesMessage(TypeError, msg), transaction.atomic():
+            Counter().save(force_insert=[])
+
+    def test_force_insert_not_model(self):
+        msg = f"Invalid force_insert member. {object!r} must be a model subclass."
+        with self.assertRaisesMessage(TypeError, msg), transaction.atomic():
+            Counter().save(force_insert=(object,))
+        instance = Counter()
+        msg = f"Invalid force_insert member. {instance!r} must be a model subclass."
+        with self.assertRaisesMessage(TypeError, msg), transaction.atomic():
+            Counter().save(force_insert=(instance,))
+
+    def test_force_insert_not_base(self):
+        msg = "Invalid force_insert member. SubCounter must be a base of Counter."
+        with self.assertRaisesMessage(TypeError, msg):
+            Counter().save(force_insert=(SubCounter,))
+
     def test_force_insert_false(self):
         with self.assertNumQueries(3):
             obj = SubCounter.objects.create(pk=1, value=0)
@@ -87,6 +112,10 @@ def test_force_insert_false(self):
             SubCounter(pk=obj.pk, value=2).save(force_insert=False)
         obj.refresh_from_db()
         self.assertEqual(obj.value, 2)
+        with self.assertNumQueries(2):
+            SubCounter(pk=obj.pk, value=3).save(force_insert=())
+        obj.refresh_from_db()
+        self.assertEqual(obj.value, 3)
 
     def test_force_insert_false_with_existing_parent(self):
         parent = Counter.objects.create(pk=1, value=1)
@@ -96,13 +125,59 @@ def test_force_insert_false_with_existing_parent(self):
     def test_force_insert_parent(self):
         with self.assertNumQueries(3):
             SubCounter(pk=1, value=1).save(force_insert=True)
+        # Force insert a new parent and don't UPDATE first.
+        with self.assertNumQueries(2):
+            SubCounter(pk=2, value=1).save(force_insert=(Counter,))
+        with self.assertNumQueries(2):
+            SubCounter(pk=3, value=1).save(force_insert=(models.Model,))
 
     def test_force_insert_with_grandparent(self):
         with self.assertNumQueries(4):
             SubSubCounter(pk=1, value=1).save(force_insert=True)
+        # Force insert parents on all levels and don't UPDATE first.
+        with self.assertNumQueries(3):
+            SubSubCounter(pk=2, value=1).save(force_insert=(models.Model,))
+        with self.assertNumQueries(3):
+            SubSubCounter(pk=3, value=1).save(force_insert=(Counter,))
+        # Force insert only the last parent.
+        with self.assertNumQueries(4):
+            SubSubCounter(pk=4, value=1).save(force_insert=(SubCounter,))
 
     def test_force_insert_with_existing_grandparent(self):
         # Force insert only the last child.
         grandparent = Counter.objects.create(pk=1, value=1)
         with self.assertNumQueries(4):
             SubSubCounter(pk=grandparent.pk, value=1).save(force_insert=True)
+        # Force insert a parent, and don't force insert a grandparent.
+        grandparent = Counter.objects.create(pk=2, value=1)
+        with self.assertNumQueries(3):
+            SubSubCounter(pk=grandparent.pk, value=1).save(force_insert=(SubCounter,))
+        # Force insert parents on all levels, grandparent conflicts.
+        grandparent = Counter.objects.create(pk=3, value=1)
+        with self.assertRaises(IntegrityError), transaction.atomic():
+            SubSubCounter(pk=grandparent.pk, value=1).save(force_insert=(Counter,))
+
+    def test_force_insert_diamond_mti(self):
+        # Force insert all parents.
+        with self.assertNumQueries(4):
+            DiamondSubSubCounter(pk=1, value=1).save(
+                force_insert=(Counter, SubCounter, OtherSubCounter)
+            )
+        with self.assertNumQueries(4):
+            DiamondSubSubCounter(pk=2, value=1).save(force_insert=(models.Model,))
+        # Force insert parents, and don't force insert a common grandparent.
+        with self.assertNumQueries(5):
+            DiamondSubSubCounter(pk=3, value=1).save(
+                force_insert=(SubCounter, OtherSubCounter)
+            )
+        grandparent = Counter.objects.create(pk=4, value=1)
+        with self.assertNumQueries(4):
+            DiamondSubSubCounter(pk=grandparent.pk, value=1).save(
+                force_insert=(SubCounter, OtherSubCounter),
+            )
+        # Force insert all parents, grandparent conflicts.
+        grandparent = Counter.objects.create(pk=5, value=1)
+        with self.assertRaises(IntegrityError), transaction.atomic():
+            DiamondSubSubCounter(pk=grandparent.pk, value=1).save(
+                force_insert=(models.Model,)
+            )