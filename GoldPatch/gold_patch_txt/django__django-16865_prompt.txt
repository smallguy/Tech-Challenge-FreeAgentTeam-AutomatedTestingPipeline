# 修复代码生成提示词（实例ID：django__django-16865）
## 代码仓库
django/django

## 原始问题描述
makemigrations --update should respect the --name option.
Description
	 
		(last modified by David Sanders)
	 
This may be intentional behaviour but the docs don't mention this so creating a ticket to update docs or correct behaviour:
If you create a migration with a custom name:
$ ./manage.py makemigrations --name foo
Migrations for 'update_rename':
 update_rename/migrations/0001_foo.py
	- Create model Foo
then running --update will change the name "foo" to the autogenerated one based on the operations:
$ ./manage.py makemigrations --update
Migrations for 'update_rename':
 update_rename/migrations/0001_initial.py
	- Create model Foo
Deleted update_rename/migrations/0001_foo.py
My opinion is that it shouldn't as it violates the principle of least astonishment even though the --name argument wasn't supplied.
EDIT:
This is my first time using --update and here are a few other observations which could indicate that it requires broader discussion:
It doesn't utilise the --name argument so it's impossible to customise the name during --update
It'd be nice to provide --no-optimize option to --update, here's my use-case: 3-step non-null field addition. After doing nullable step 1, elidable data migration step 2, I want to merge the step 3 non-null update into the migration but --update optimizes this into a single step.
Perhaps --update requires a rethink?


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py
--- a/tests/migrations/test_commands.py
+++ b/tests/migrations/test_commands.py
@@ -2655,6 +2655,32 @@ def test_makemigrations_update_existing_name(self):
                 self.assertNotEqual(initial_content, fp.read())
             self.assertIn(f"Deleted {migration_file}", out.getvalue())
 
+    def test_makemigrations_update_custom_name(self):
+        custom_name = "delete_something"
+        with self.temporary_migration_module(
+            module="migrations.test_migrations"
+        ) as migration_dir:
+            old_migration_file = os.path.join(migration_dir, "0002_second.py")
+            with open(old_migration_file) as fp:
+                initial_content = fp.read()
+
+            with captured_stdout() as out:
+                call_command(
+                    "makemigrations", "migrations", update=True, name=custom_name
+                )
+            self.assertFalse(
+                any(
+                    filename.startswith("0003")
+                    for filename in os.listdir(migration_dir)
+                )
+            )
+            self.assertIs(os.path.exists(old_migration_file), False)
+            new_migration_file = os.path.join(migration_dir, f"0002_{custom_name}.py")
+            self.assertIs(os.path.exists(new_migration_file), True)
+            with open(new_migration_file) as fp:
+                self.assertNotEqual(initial_content, fp.read())
+            self.assertIn(f"Deleted {old_migration_file}", out.getvalue())
+
     def test_makemigrations_update_applied_migration(self):
         recorder = MigrationRecorder(connection)
         recorder.record_applied("migrations", "0001_initial")