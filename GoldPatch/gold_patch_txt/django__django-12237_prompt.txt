# 修复代码生成提示词（实例ID：django__django-12237）
## 代码仓库
django/django

## 原始问题描述
slugify() doesn't return a valid slug for "İ".
Description
	
While working on an international project, we discovered that the turkish/azerbaijani letter İ can not be properly processed when SlugField and slugify are run with allow_unicode=True.
The project itself runs with Django 2.2.6 and Wagtail 2.6.2. I first talked about this in the Wagtail Support Channel and while researching further, discovered that this is a Django/Python related issue. This was tested on Python 3.6 and on Python 3.7.
(quick shoutout to Matt Wescott @gasmanic of Wagtail Fame for being a sparing partner in this)
There is a rather detailed analysis (README) in a git repo I created ​https://github.com/originell/django-wagtail-turkish-i - it was also the basis for my initial call for help in wagtail's support channel. Meanwhile I have extended it with a Django-only project, as to be a 100% sure this has nothing to do with Wagtail.
I was not able to find anything similar in trac. While I encourage whoever is reading this to actually read the README in the git repo, I want to honor your time and will try to provide a more concise version of the bug here.
Explanation
models.py
from django.db import models
from django.utils.text import slugify
class Page(models.Model):
	title = models.CharField(max_length=255)
	slug = models.SlugField(allow_unicode=True)
	def __str__(self):
		return self.title
Using this in a shell/test like a (Model)Form might:
from django.utils.text import slugify
page = Page(title="Hello İstanbul")
page.slug = slugify(page.title, allow_unicode=True)
page.full_clean()
full_clean() then raises
django.core.exceptions.ValidationError: {'slug': Enter a valid 'slug' consisting of Unicode letters, numbers, underscores, or hyphens.?}
Why is that?
slugify does the following internally:
re.sub(r'[^\w\s-]', '', value).strip().lower()
Thing is, Python's .lower() of the İ in İstanbul looks like this:
>>> [unicodedata.name(character) for character in 'İ'.lower()]
['LATIN SMALL LETTER I', 'COMBINING DOT ABOVE']
So, while slugify() finishes, the result is then passed into SlugField which uses the slug_unicode_re (^[-\w]+\Z). However, the Combining Dot Above is not a valid \w:
>>> [(character, unicodedata.name(character), slug_unicode_re.match(character)) for character in 'İ'.lower()]
[
 ('i', 'LATIN SMALL LETTER I', <re.Match object; span=(0, 1), match='i'>),
 # EUREKA!!
 ('̇', 'COMBINING DOT ABOVE', None)
]
So that's why the ValidationError is raised.
Proposed Solution
The culprit seems to be the order in which lower() is called in slugify. The assumption that the lowercase version of a re.sub-ed string is still a valid slug_unicode_re, does not seem to hold true.
Hence, instead of doing this in slugify()
re.sub(r'[^\w\s-]', '', value).strip().lower()
It might be better to do it like this
re.sub(r'[^\w\s-]', '', value.lower()).strip()
Is Python the actual culprit?
Yeah it might be. Matt (@gasmanic) urged me to also take a look if Python might be doing this wrong. 
 The İ is the Latin Capital Letter I with Dot Above. It's codepoint is U+0130 According to the chart for the Latin Extended-A set (​https://www.unicode.org/charts/PDF/U0100.pdf), it's lowercase version is U+0069.
 U+0069 lives in the C0 Controls and Basic Latin set (​https://www.unicode.org/charts/PDF/U0000.pdf). Lo and behold: it is the Latin small letter I. So a latin lowercase i.
Does this really mean that Python is doing something weird here by adding the Combining dot above? Honestly, I can't imagine that and I am probably missing an important thing here because my view is too naive.
---
I hope this shorter explanation makes sense. If it does not, please try to read through the detailed analysis in the repo (​https://github.com/originell/django-wagtail-turkish-i/blob/master/README.md). If that also does not make a ton of sense, let me know.
In any case, thank you for taking the time to read this bug report. Looking forward to feedback and thoughts. I am happy to oblige in any capacity necessary.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py
--- a/tests/admin_views/tests.py
+++ b/tests/admin_views/tests.py
@@ -4442,13 +4442,13 @@ def test_prepopulated_fields(self):
         # Main form ----------------------------------------------------------
         self.selenium.find_element_by_id('id_pubdate').send_keys('2012-02-18')
         self.select_option('#id_status', 'option two')
-        self.selenium.find_element_by_id('id_name').send_keys(' this is the mAin nÀMë and it\'s awεšomeııı')
+        self.selenium.find_element_by_id('id_name').send_keys(' this is the mAin nÀMë and it\'s awεšomeıııİ')
         slug1 = self.selenium.find_element_by_id('id_slug1').get_attribute('value')
         slug2 = self.selenium.find_element_by_id('id_slug2').get_attribute('value')
         slug3 = self.selenium.find_element_by_id('id_slug3').get_attribute('value')
-        self.assertEqual(slug1, 'main-name-and-its-awesomeiii-2012-02-18')
-        self.assertEqual(slug2, 'option-two-main-name-and-its-awesomeiii')
-        self.assertEqual(slug3, 'this-is-the-main-n\xe0m\xeb-and-its-aw\u03b5\u0161ome\u0131\u0131\u0131')
+        self.assertEqual(slug1, 'main-name-and-its-awesomeiiii-2012-02-18')
+        self.assertEqual(slug2, 'option-two-main-name-and-its-awesomeiiii')
+        self.assertEqual(slug3, 'this-is-the-main-n\xe0m\xeb-and-its-aw\u03b5\u0161ome\u0131\u0131\u0131i')
 
         # Stacked inlines ----------------------------------------------------
         # Initial inline
@@ -4526,11 +4526,12 @@ def test_prepopulated_fields(self):
             self.selenium.find_element_by_xpath('//input[@value="Save"]').click()
         self.assertEqual(MainPrepopulated.objects.all().count(), 1)
         MainPrepopulated.objects.get(
-            name=' this is the mAin nÀMë and it\'s awεšomeııı',
+            name=' this is the mAin nÀMë and it\'s awεšomeıııİ',
             pubdate='2012-02-18',
             status='option two',
-            slug1='main-name-and-its-awesomeiii-2012-02-18',
-            slug2='option-two-main-name-and-its-awesomeiii',
+            slug1='main-name-and-its-awesomeiiii-2012-02-18',
+            slug2='option-two-main-name-and-its-awesomeiiii',
+            slug3='this-is-the-main-nàmë-and-its-awεšomeıııi',
         )
         self.assertEqual(RelatedPrepopulated.objects.all().count(), 4)
         RelatedPrepopulated.objects.get(
diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py
--- a/tests/utils_tests/test_text.py
+++ b/tests/utils_tests/test_text.py
@@ -196,6 +196,7 @@ def test_slugify(self):
             ('foo ıç bar', 'foo-ıç-bar', True),
             ('    foo ıç bar', 'foo-ıç-bar', True),
             ('你好', '你好', True),
+            ('İstanbul', 'istanbul', True),
         )
         for value, output, is_unicode in items:
             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)