# 修复代码生成提示词（实例ID：matplotlib__matplotlib-23057）
## 代码仓库
matplotlib/matplotlib

## 原始问题描述
[Bug]: Figures fail to redraw with IPython
### Bug summary

A regression between release versions 3.5.1 and 3.5.2 causes figures to fail to redraw after an initial plot is added using the `pyplot` interface in an interactive IPython session. This has been observed with both `pyplot.plot` and `pyplot.tripcolor`. The figure will show the first plot drawn, but subsequent calls to `pyplot.plot` and `pyplot.tripcolor` fail to update an on-screen figure until `pyplot.draw` is invoked. This has been observed with IPython versions 8.3.0 (current) and 8.2.0.

Both the Qt5 and Tk backends exhibit the same issues.

### Code for reproduction

```python
# Install matplotlib and ipython in a virtualenv
python3 -m venv ~/mpl.venv
. ~/mpl.venv/bin/activate
pip install matplotlib ipython

# Make sure to start with a clean config
mv ~/.ipython ~/.ipython.backup
mv ~/.config/matplotlib .config/matplotlib.backup

# Run `pylab`
ipython --pylab=tk

# ... the following are commands issues in the ipython prompt
plot(arange(10))
plot(-arange(10))
draw()
```


### Actual outcome

1. After the first `plot` command, a figure appears with a `y = x` line shown.
2. After the second `plot` command, the figure does not update.
3. After the `draw` command, the figure updates to show both the `y = x` and `y = -x` lines.

### Expected outcome

1. After the first `plot` command, a figure appears with a `y = x` line shown. (This is as expected.)
2. After the second `plot` command, the figure updates with the addition of a `y = -x` line. (This is the deviation.)
3. The `draw` command should produce no visible change in the figure.

### Additional information

This regression has been bisected to commit f937b0ab5ef9d5ffe9f2f58f6391357783cc4afa.

The testbed is a current Void Linux system running Python 3.10.4, including the system `python3-tkinter` package for a GUI. (As noted above, this bug is also present with the Qt5 backend.) All packages were installed in a virtual environment. The output of `pip freeze` is:

```
asttokens==2.0.5
backcall==0.2.0
cycler==0.11.0
decorator==5.1.1
executing==0.8.3
fonttools==4.33.3
ipython==8.3.0
jedi==0.18.1
kiwisolver==1.4.2
matplotlib==3.6.0.dev155+gf937b0ab5e
matplotlib-inline==0.1.3
numpy==1.22.3
packaging==21.3
parso==0.8.3
pexpect==4.8.0
pickleshare==0.7.5
Pillow==9.1.0
prompt-toolkit==3.0.29
ptyprocess==0.7.0
pure-eval==0.2.2
Pygments==2.12.0
pyparsing==3.0.9
python-dateutil==2.8.2
setuptools-scm==6.4.2
six==1.16.0
stack-data==0.2.0
tk==0.1.0
tomli==2.0.1
traitlets==5.2.0
wcwidth==0.2.5
```
(Note that the funny `matplotlib` version comes from a local git repo checked out to the problematic commit.)

### Operating system

Void Linux x86_64

### Matplotlib Version

3.5.2

### Matplotlib Backend

TkAgg, Qt5Agg

### Python version

3.10.4

### Jupyter version

None

### Installation

pip


## 参考黄金补丁（正确的修复方案）
diff --git a/lib/matplotlib/tests/test_pyplot.py b/lib/matplotlib/tests/test_pyplot.py
--- a/lib/matplotlib/tests/test_pyplot.py
+++ b/lib/matplotlib/tests/test_pyplot.py
@@ -1,5 +1,6 @@
 import difflib
 import numpy as np
+import os
 import subprocess
 import sys
 from pathlib import Path
@@ -367,3 +368,26 @@ def test_set_current_axes_on_subfigure():
     assert plt.gca() != ax
     plt.sca(ax)
     assert plt.gca() == ax
+
+
+def test_pylab_integration():
+    pytest.importorskip("IPython")
+    subprocess.run(
+        [
+            sys.executable,
+            "-m",
+            "IPython",
+            "--pylab",
+            "-c",
+            ";".join((
+                "import matplotlib.pyplot as plt",
+                "assert plt._REPL_DISPLAYHOOK == plt._ReplDisplayHook.IPYTHON",
+            )),
+        ],
+        env={**os.environ, "SOURCE_DATE_EPOCH": "0"},
+        timeout=60,
+        check=True,
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+        universal_newlines=True,
+    )