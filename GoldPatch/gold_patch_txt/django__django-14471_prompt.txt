# 修复代码生成提示词（实例ID：django__django-14471）
## 代码仓库
django/django

## 原始问题描述
Reject requests earlier if the CSRF cookie token has the wrong format
Description
	 
		(last modified by Chris Jerdonek)
	 
(This issue is similar to #32795 but for the cookie token rather than for the non-cookie token.)
I noticed in CsrfViewMiddleware.process_view() that if the CSRF cookie has the wrong format (i.e. wrong length or contains invalid characters), then the code will do a fair amount of unnecessary work. Specifically, the code will proceed inside _get_token() at ​this line to use Python's secrets module twice to generate both a new token and a mask for the token. But this new token will only be used for the purposes of later calling _compare_masked_tokens() in a way that will be guaranteed to fail (since the cookie being used will be brand new and so won't match). And then it will call _compare_masked_tokens() with that value.
Instead, if the CSRF cookie is found at that line to have the wrong format, the middleware could reject the request outright similar to how #32795 does it if the token has the wrong format (as well as similar to how the code currently handles a missing cookie in the ​lines after). I think this will simplify CsrfViewMiddleware and make it easier to understand because it will eliminate a number of steps that aren't needed for security. In particular, one thing this will do is cut down on the number of places where _get_new_csrf_token() is called, which will make it clearer where a new value is really needed / used. Similar to #32795, it will also make troubleshooting easier because the rejection messages will be more specific.
I think this could be implemented as follows. After #32795 is merged, ​_get_token() could be changed to allow InvalidTokenFormat to bubble up instead of handling it. Then the InvalidTokenFormat exception could be handled differently in the two places _get_token() is called: (1) In process_request(), it could be handled by calling _get_new_csrf_token() (_get_token()'s current behavior). (2) In process_view(), it could be handled similar to how #32795 handles it. Namely, reject the request using the InvalidTokenFormat's reason string.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/csrf_tests/tests.py b/tests/csrf_tests/tests.py
--- a/tests/csrf_tests/tests.py
+++ b/tests/csrf_tests/tests.py
@@ -43,11 +43,12 @@ def _get_GET_no_csrf_cookie_request(self):
         req.method = 'GET'
         return req
 
-    def _get_GET_csrf_cookie_request(self):
+    def _get_GET_csrf_cookie_request(self, cookie=None):
         raise NotImplementedError('This method must be implemented by a subclass.')
 
-    def _get_POST_csrf_cookie_request(self):
-        req = self._get_GET_csrf_cookie_request()
+    def _get_POST_csrf_cookie_request(self, cookie=None):
+        """The cookie argument defaults to the valid test cookie."""
+        req = self._get_GET_csrf_cookie_request(cookie=cookie)
         req.method = "POST"
         return req
 
@@ -94,18 +95,25 @@ def test_process_response_get_token_not_used(self):
         csrf_cookie = resp.cookies.get(settings.CSRF_COOKIE_NAME, False)
         self.assertIs(csrf_cookie, False)
 
-    def test_no_csrf_cookie(self):
-        """
-        If no CSRF cookies is present, the middleware rejects the incoming
-        request. This will stop login CSRF.
-        """
-        req = self._get_POST_no_csrf_cookie_request()
+    def _check_bad_or_missing_cookie(self, cookie, expected):
+        """Passing None for cookie includes no cookie."""
+        if cookie is None:
+            req = self._get_POST_no_csrf_cookie_request()
+        else:
+            req = self._get_POST_csrf_cookie_request(cookie=cookie)
         mw = CsrfViewMiddleware(post_form_view)
         mw.process_request(req)
         with self.assertLogs('django.security.csrf', 'WARNING') as cm:
             resp = mw.process_view(req, post_form_view, (), {})
         self.assertEqual(403, resp.status_code)
-        self.assertEqual(cm.records[0].getMessage(), 'Forbidden (%s): ' % REASON_NO_CSRF_COOKIE)
+        self.assertEqual(cm.records[0].getMessage(), 'Forbidden (%s): ' % expected)
+
+    def test_no_csrf_cookie(self):
+        """
+        If no CSRF cookies is present, the middleware rejects the incoming
+        request. This will stop login CSRF.
+        """
+        self._check_bad_or_missing_cookie(None, REASON_NO_CSRF_COOKIE)
 
     def _check_bad_or_missing_token(self, token, expected):
         """Passing None for token includes no token."""
@@ -762,9 +770,12 @@ def test_good_origin_wildcard_csrf_trusted_origin_allowed(self):
 
 class CsrfViewMiddlewareTests(CsrfViewMiddlewareTestMixin, SimpleTestCase):
 
-    def _get_GET_csrf_cookie_request(self):
+    def _get_GET_csrf_cookie_request(self, cookie=None):
+        """The cookie argument defaults to the valid test cookie."""
+        if cookie is None:
+            cookie = self._csrf_id_cookie
         req = TestingHttpRequest()
-        req.COOKIES[settings.CSRF_COOKIE_NAME] = self._csrf_id_cookie
+        req.COOKIES[settings.CSRF_COOKIE_NAME] = cookie
         return req
 
     def _get_POST_bare_secret_csrf_cookie_request(self):
@@ -847,6 +858,20 @@ def test_csrf_cookie_samesite(self):
             resp = mw(req)
             self.assertEqual(resp.cookies['csrfcookie']['samesite'], 'Strict')
 
+    def test_bad_csrf_cookie_characters(self):
+        """
+        If the CSRF cookie has invalid characters in a POST request, the
+        middleware rejects the incoming request.
+        """
+        self._check_bad_or_missing_cookie(64 * '*', 'CSRF cookie has invalid characters.')
+
+    def test_bad_csrf_cookie_length(self):
+        """
+        If the CSRF cookie has an incorrect length in a POST request, the
+        middleware rejects the incoming request.
+        """
+        self._check_bad_or_missing_cookie(16 * 'a', 'CSRF cookie has incorrect length.')
+
     def test_process_view_token_too_long(self):
         """
         If the token is longer than expected, it is ignored and a new token is
@@ -943,9 +968,12 @@ def _get_POST_bare_secret_csrf_cookie_request(self):
         req.session[CSRF_SESSION_KEY] = self._csrf_id_cookie[:32]
         return req
 
-    def _get_GET_csrf_cookie_request(self):
+    def _get_GET_csrf_cookie_request(self, cookie=None):
+        """The cookie argument defaults to the valid test cookie."""
+        if cookie is None:
+            cookie = self._csrf_id_cookie
         req = TestingHttpRequest()
-        req.session[CSRF_SESSION_KEY] = self._csrf_id_cookie
+        req.session[CSRF_SESSION_KEY] = cookie
         return req
 
     def test_no_session_on_request(self):