# 修复代码生成提示词（实例ID：django__django-10606）
## 代码仓库
django/django

## 原始问题描述
Using RelatedOnlyFieldListFilter with reverse ManyToMany crashes
Description
	 
		(last modified by Tim Graham)
	 
Using RelatedOnlyFieldListFilter with a reverse ManyToMany relation causes this exception:
get_choices() got an unexpected keyword argument 'limit_choices_to'
This method in ForeignObjectRel.get_choices is missing the parameter that Field.get_choices has.
Pull Request: ​https://github.com/django/django/pull/10606
Demo of how to trigger bug: ​https://github.com/mgrdcm/django-bug-reverse-related/blob/master/rrbug/rrapp/admin.py#L11-L15


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/admin_filters/tests.py b/tests/admin_filters/tests.py
--- a/tests/admin_filters/tests.py
+++ b/tests/admin_filters/tests.py
@@ -741,6 +741,43 @@ def test_relatedonlyfieldlistfilter_foreignkey(self):
         expected = [(self.alfred.pk, 'alfred'), (self.bob.pk, 'bob')]
         self.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))
 
+    def test_relatedonlyfieldlistfilter_foreignkey_reverse_relationships(self):
+        class EmployeeAdminReverseRelationship(ModelAdmin):
+            list_filter = (
+                ('book', RelatedOnlyFieldListFilter),
+            )
+
+        self.djangonaut_book.employee = self.john
+        self.djangonaut_book.save()
+        self.django_book.employee = self.jack
+        self.django_book.save()
+
+        modeladmin = EmployeeAdminReverseRelationship(Employee, site)
+        request = self.request_factory.get('/')
+        request.user = self.alfred
+        changelist = modeladmin.get_changelist_instance(request)
+        filterspec = changelist.get_filters(request)[0][0]
+        self.assertEqual(filterspec.lookup_choices, [
+            (self.djangonaut_book.pk, 'Djangonaut: an art of living'),
+            (self.django_book.pk, 'The Django Book'),
+        ])
+
+    def test_relatedonlyfieldlistfilter_manytomany_reverse_relationships(self):
+        class UserAdminReverseRelationship(ModelAdmin):
+            list_filter = (
+                ('books_contributed', RelatedOnlyFieldListFilter),
+            )
+
+        modeladmin = UserAdminReverseRelationship(User, site)
+        request = self.request_factory.get('/')
+        request.user = self.alfred
+        changelist = modeladmin.get_changelist_instance(request)
+        filterspec = changelist.get_filters(request)[0][0]
+        self.assertEqual(
+            filterspec.lookup_choices,
+            [(self.guitar_book.pk, 'Guitar for dummies')],
+        )
+
     def test_relatedonlyfieldlistfilter_foreignkey_ordering(self):
         """RelatedOnlyFieldListFilter ordering respects ModelAdmin.ordering."""
         class EmployeeAdminWithOrdering(ModelAdmin):
diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py
--- a/tests/model_fields/tests.py
+++ b/tests/model_fields/tests.py
@@ -266,3 +266,37 @@ def test_get_choices_reverse_related_field_default_ordering(self):
             self.field.remote_field.get_choices(include_blank=False),
             [self.bar2, self.bar1]
         )
+
+
+class GetChoicesLimitChoicesToTests(TestCase):
+    @classmethod
+    def setUpTestData(cls):
+        cls.foo1 = Foo.objects.create(a='a', d='12.34')
+        cls.foo2 = Foo.objects.create(a='b', d='12.34')
+        cls.bar1 = Bar.objects.create(a=cls.foo1, b='b')
+        cls.bar2 = Bar.objects.create(a=cls.foo2, b='a')
+        cls.field = Bar._meta.get_field('a')
+
+    def assertChoicesEqual(self, choices, objs):
+        self.assertEqual(choices, [(obj.pk, str(obj)) for obj in objs])
+
+    def test_get_choices(self):
+        self.assertChoicesEqual(
+            self.field.get_choices(include_blank=False, limit_choices_to={'a': 'a'}),
+            [self.foo1],
+        )
+        self.assertChoicesEqual(
+            self.field.get_choices(include_blank=False, limit_choices_to={}),
+            [self.foo1, self.foo2],
+        )
+
+    def test_get_choices_reverse_related_field(self):
+        field = self.field.remote_field
+        self.assertChoicesEqual(
+            field.get_choices(include_blank=False, limit_choices_to={'b': 'b'}),
+            [self.bar1],
+        )
+        self.assertChoicesEqual(
+            field.get_choices(include_blank=False, limit_choices_to={}),
+            [self.bar1, self.bar2],
+        )