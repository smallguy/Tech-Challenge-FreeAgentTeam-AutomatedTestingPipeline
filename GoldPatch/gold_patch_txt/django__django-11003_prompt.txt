# 修复代码生成提示词（实例ID：django__django-11003）
## 代码仓库
django/django

## 原始问题描述
Initialising disabled ModelChoiceField yields 'Select a valid choice'-error despite initialised option being valid
Description
	 
		(last modified by Mariusz Felisiak)
	 
I have a form with a ModelChoiceField that gets initialised to a specific value using get_initial in that form's View. This value is a valid choice for that Model. I don't want the user to be able to change the option on the form, but it needs to be displayed nonetheless.
When I set disabled=True on that field in forms.py, submitting the form yields the following error:
<ul class="errorlist"><li>fieldname<ul class="errorlist"><li>Select a valid choice. That choice is not one of the available choices.</li></ul></li></ul>.
Firstly, I would like to comment on the general quality of the error message, as it is not very useful: It does not return which choice it considers invalid. Including this information would make the message much more informative, and would avoid sending people on a wild goose chase to discover what the message could possibly mean.
Secondly, if a field is disabled but does contain a valid choice, validating the form should work and not trigger an error. 
Edit: Adding the to_field_name option to the form field fixes the problem. However, when disabled=True is not present, this is not required.
This is probably related to the bugfix for this bug: #28387


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py
--- a/tests/model_forms/test_modelchoicefield.py
+++ b/tests/model_forms/test_modelchoicefield.py
@@ -55,6 +55,19 @@ def test_basics(self):
         with self.assertRaisesMessage(ValidationError, msg):
             f.clean(c4.id)
 
+    def test_clean_model_instance(self):
+        f = forms.ModelChoiceField(Category.objects.all())
+        self.assertEqual(f.clean(self.c1), self.c1)
+        # An instance of incorrect model.
+        msg = "['Select a valid choice. That choice is not one of the available choices.']"
+        with self.assertRaisesMessage(ValidationError, msg):
+            f.clean(Book.objects.create())
+
+    def test_clean_to_field_name(self):
+        f = forms.ModelChoiceField(Category.objects.all(), to_field_name='slug')
+        self.assertEqual(f.clean(self.c1.slug), self.c1)
+        self.assertEqual(f.clean(self.c1), self.c1)
+
     def test_choices(self):
         f = forms.ModelChoiceField(Category.objects.filter(pk=self.c1.id), required=False)
         self.assertIsNone(f.clean(''))
@@ -190,6 +203,16 @@ def test_disabled_modelchoicefield_has_changed(self):
         field = forms.ModelChoiceField(Author.objects.all(), disabled=True)
         self.assertIs(field.has_changed('x', 'y'), False)
 
+    def test_disabled_modelchoicefield_initial_model_instance(self):
+        class ModelChoiceForm(forms.Form):
+            categories = forms.ModelChoiceField(
+                Category.objects.all(),
+                disabled=True,
+                initial=self.c1,
+            )
+
+        self.assertTrue(ModelChoiceForm(data={'categories': self.c1.pk}).is_valid())
+
     def test_disabled_multiplemodelchoicefield(self):
         class ArticleForm(forms.ModelForm):
             categories = forms.ModelMultipleChoiceField(Category.objects.all(), required=False)