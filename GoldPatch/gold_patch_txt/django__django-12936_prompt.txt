# 修复代码生成提示词（实例ID：django__django-12936）
## 代码仓库
django/django

## 原始问题描述
Subquery.__eq__() doesn't work properly for resolved subqueries.
Description
	
Subquery.__eq__() doesn't work properly for resolved subqueries, basically all resolved subqueries are now equal.
Regression in 691def10a0197d83d2d108bd9043b0916d0f09b4.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py
--- a/tests/expressions/tests.py
+++ b/tests/expressions/tests.py
@@ -511,6 +511,25 @@ def test_subquery(self):
             Employee.objects.exclude(company_point_of_contact_set=None).values('pk')
         )
 
+    def test_subquery_eq(self):
+        qs = Employee.objects.annotate(
+            is_ceo=Exists(Company.objects.filter(ceo=OuterRef('pk'))),
+            is_point_of_contact=Exists(
+                Company.objects.filter(point_of_contact=OuterRef('pk')),
+            ),
+            small_company=Exists(
+                queryset=Company.objects.filter(num_employees__lt=200),
+            ),
+        ).filter(is_ceo=True, is_point_of_contact=False, small_company=True)
+        self.assertNotEqual(
+            qs.query.annotations['is_ceo'],
+            qs.query.annotations['is_point_of_contact'],
+        )
+        self.assertNotEqual(
+            qs.query.annotations['is_ceo'],
+            qs.query.annotations['small_company'],
+        )
+
     def test_in_subquery(self):
         # This is a contrived test (and you really wouldn't write this query),
         # but it is a succinct way to test the __in=Subquery() construct.
diff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py
--- a/tests/queryset_pickle/tests.py
+++ b/tests/queryset_pickle/tests.py
@@ -195,6 +195,18 @@ def test_pickle_exists_queryset_not_evaluated(self):
         with self.assertNumQueries(0):
             self.assert_pickles(groups)
 
+    def test_pickle_exists_kwargs_queryset_not_evaluated(self):
+        group = Group.objects.create(name='group')
+        Event.objects.create(title='event', group=group)
+        groups = Group.objects.annotate(
+            has_event=models.Exists(
+                queryset=Event.objects.filter(group_id=models.OuterRef('id')),
+            ),
+        )
+        list(groups)  # evaluate QuerySet.
+        with self.assertNumQueries(0):
+            self.assert_pickles(groups)
+
     def test_pickle_subquery_queryset_not_evaluated(self):
         group = Group.objects.create(name='group')
         Event.objects.create(title='event', group=group)