# 修复代码生成提示词（实例ID：django__django-15324）
## 代码仓库
django/django

## 原始问题描述
File upload crash when a file extension contains null characters.
Description
	
A >2.5M file uploaded with a raw null byte anyplace after the . in its filename means that Django attempts to create a tempfile with that same "extension," which errors out with ValueError: embedded null byte.
It's almost certainly a violation of RFC to have a filename with a raw null byte in it, but it shouldn't result in a 500 when parsing the form.
Here's code to generate a bad request:
#!/usr/bin/env python3
import io
import requests
contents = io.StringIO("." * (1024 * 1024 * 3))
files = {"docfile": (b"bogus.txt!", contents, "text/plain")}
req = requests.Request("POST", "http://localhost:8000/", files=files, data={})
prepared = req.prepare()
body = prepared.body
assert isinstance(body, bytes)
prepared.body = body.replace(b"!", b"\x00")
requests.Session().send(prepared)
...which produces an error with the view:
from django import forms
from django.http import HttpResponseRedirect
from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt
class UploadFileForm(forms.Form):
	docfile = forms.FileField()
@csrf_exempt
def index(request):
	if request.method == 'POST':
		form = UploadFileForm(request.POST, request.FILES)
		if form.is_valid():
			print(repr(request.FILES['docfile']))
			return HttpResponseRedirect('/')
		else:
			print("Not valid!")
			return HttpResponseRedirect('/')
	else:
		form = UploadFileForm()
	return render(request, 'uploads/index.html', {'form': form})
I'm not sure what the goal is of preserving the "extension" of the uploaded file in the tempfile that is made; if that's important enough a behaviour to keep, some amount of escaping on the parsed-out extension may be necessary.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/file_uploads/tests.py b/tests/file_uploads/tests.py
--- a/tests/file_uploads/tests.py
+++ b/tests/file_uploads/tests.py
@@ -283,6 +283,29 @@ def test_blank_filenames(self):
         for i, name in enumerate(filenames):
             self.assertIsNone(received.get('file%s' % i))
 
+    def test_non_printable_chars_in_file_names(self):
+        file_name = 'non-\x00printable\x00\n_chars.txt\x00'
+        payload = client.FakePayload()
+        payload.write('\r\n'.join([
+            '--' + client.BOUNDARY,
+            f'Content-Disposition: form-data; name="file"; filename="{file_name}"',
+            'Content-Type: application/octet-stream',
+            '',
+            'You got pwnd.\r\n'
+        ]))
+        payload.write('\r\n--' + client.BOUNDARY + '--\r\n')
+        r = {
+            'CONTENT_LENGTH': len(payload),
+            'CONTENT_TYPE': client.MULTIPART_CONTENT,
+            'PATH_INFO': '/echo/',
+            'REQUEST_METHOD': 'POST',
+            'wsgi.input': payload,
+        }
+        response = self.client.request(**r)
+        # Non-printable chars are sanitized.
+        received = response.json()
+        self.assertEqual(received['file'], 'non-printable_chars.txt')
+
     def test_dangerous_file_names(self):
         """Uploaded file names should be sanitized before ever reaching the view."""
         # This test simulates possible directory traversal attacks by a