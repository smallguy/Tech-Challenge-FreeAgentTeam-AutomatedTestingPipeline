# 修复代码生成提示词（实例ID：django__django-13490）
## 代码仓库
django/django

## 原始问题描述
Raise a descriptive error on get() with filters operation following QuerySet.union(), intersection(), and difference().
Description
	
The QuerySet resulting from q1.difference(q2) does not allow to retrieve one specific object of that resulting QuerySet.
Minimal example:
models.py
from django.db import models
class Test(models.Model):
	name = models.CharField(max_length=30)
python manage.py shell
>>> from test.models import Test
>>> qs1 = Test.objects.all()
>>> qs1
<QuerySet [<Test: Test object (1)>, <Test: Test object (2)>, <Test: Test object (3)>]>
>>> qs2 = Test.objects.filter(id=1)
>>> qs2
<QuerySet [<Test: Test object (1)>]>
>>> qs3 = qs1.difference(qs2)
>>> qs3
<QuerySet [<Test: Test object (2)>, <Test: Test object (3)>]>
>>> qs3.get(id=2)
Traceback (most recent call last):
 File "<console>", line 1, in <module>
 File "/lib/python3.8/site-packages/django/db/models/query.py", line 433, in get
	raise self.model.MultipleObjectsReturned(
test.models.Test.MultipleObjectsReturned: get() returned more than one Test -- it returned 2!
Django version: 3.1.2
Python version: 3.8.5
OS: Arch Linux
I also experienced this in the regular request/view-context, with other Django versions (2.2) and other python versions (3.7).
Sorry if this is the expected behavior, a known bug or if I missed something which changes the behavior only on my system.
If you need more information, I'll be happy to assist.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -227,6 +227,22 @@ def test_count_intersection(self):
         qs2 = Number.objects.filter(num__lte=5)
         self.assertEqual(qs1.intersection(qs2).count(), 1)
 
+    def test_get_union(self):
+        qs = Number.objects.filter(num=2)
+        self.assertEqual(qs.union(qs).get().num, 2)
+
+    @skipUnlessDBFeature('supports_select_difference')
+    def test_get_difference(self):
+        qs1 = Number.objects.all()
+        qs2 = Number.objects.exclude(num=2)
+        self.assertEqual(qs1.difference(qs2).get().num, 2)
+
+    @skipUnlessDBFeature('supports_select_intersection')
+    def test_get_intersection(self):
+        qs1 = Number.objects.all()
+        qs2 = Number.objects.filter(num=2)
+        self.assertEqual(qs1.intersection(qs2).get().num, 2)
+
     @skipUnlessDBFeature('supports_slicing_ordering_in_compound')
     def test_ordering_subqueries(self):
         qs1 = Number.objects.order_by('num')[:2]
@@ -325,3 +341,16 @@ def test_unsupported_operations_on_combined_qs(self):
                         msg % (operation, combinator),
                     ):
                         getattr(getattr(qs, combinator)(qs), operation)()
+
+    def test_get_with_filters_unsupported_on_combined_qs(self):
+        qs = Number.objects.all()
+        msg = 'Calling QuerySet.get(...) with filters after %s() is not supported.'
+        combinators = ['union']
+        if connection.features.supports_select_difference:
+            combinators.append('difference')
+        if connection.features.supports_select_intersection:
+            combinators.append('intersection')
+        for combinator in combinators:
+            with self.subTest(combinator=combinator):
+                with self.assertRaisesMessage(NotSupportedError, msg % combinator):
+                    getattr(qs, combinator)(qs).get(num=2)