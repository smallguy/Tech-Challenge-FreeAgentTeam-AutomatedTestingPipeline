# 修复代码生成提示词（实例ID：mwaskom__seaborn-3216）
## 代码仓库
mwaskom/seaborn

## 原始问题描述
Figure title being removed by seaborn objects API when plotting on subfigures
I recently came across an odd behaviour with the seaborn objects API when using subfigures. Here is a minimal example : 
```
import seaborn as sns
import seaborn.objects as so
import matplotlib.pyplot as plt

fig = plt.figure(constrained_layout=True)
subfigs = fig.subfigures(1,2)
tips = sns.load_dataset("tips")
p = (
    so.Plot(tips, "total_bill")
    .add(so.Bars(), so.Hist())
)
p.on(subfigs[0]).plot()

ax = subfigs[1].subplots()
ax.scatter([1],[1])

fig.suptitle("Test title")
plt.show()
```
which results in the title missing from the image :
![title_issue_bad](https://user-images.githubusercontent.com/1338337/210242982-57262fb0-d1d4-4aab-b400-8f59cae522f3.png)

Commenting the `p.on(subfigs[0]).plot()` results in the title reappearing.
I have done a bit of digging and found that changing  line 186 from the _core/subplots.py file from `figure = target.figure` to `figure = target` seems to solve the issue. Is there a specific reason to why it fetches the parent figure currently, since Subfigure is supposed to be a drop-in replacement for Figure ? I also expect this will not have the intended behaviour if we deal with subfigures of subfigures.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py
--- a/tests/_core/test_plot.py
+++ b/tests/_core/test_plot.py
@@ -1133,11 +1133,30 @@ def test_on_axes_with_subplots_error(self):
         with pytest.raises(RuntimeError, match="Cannot create multiple subplots"):
             p2.plot()
 
-    def test_on_disables_layout_algo(self):
+    @pytest.mark.skipif(
+        _version_predates(mpl, "3.6"),
+        reason="Requires newer matplotlib layout engine API"
+    )
+    def test_on_layout_algo_default(self):
 
-        f = mpl.figure.Figure()
+        class MockEngine(mpl.layout_engine.ConstrainedLayoutEngine):
+            ...
+
+        f = mpl.figure.Figure(layout=MockEngine())
         p = Plot().on(f).plot()
-        assert not p._figure.get_tight_layout()
+        layout_engine = p._figure.get_layout_engine()
+        assert layout_engine.__class__.__name__ == "MockEngine"
+
+    @pytest.mark.skipif(
+        _version_predates(mpl, "3.6"),
+        reason="Requires newer matplotlib layout engine API"
+    )
+    def test_on_layout_algo_spec(self):
+
+        f = mpl.figure.Figure(layout="constrained")
+        p = Plot().on(f).layout(engine="tight").plot()
+        layout_engine = p._figure.get_layout_engine()
+        assert layout_engine.__class__.__name__ == "TightLayoutEngine"
 
     def test_axis_labels_from_constructor(self, long_df):
 
@@ -1383,7 +1402,7 @@ def test_layout_algo(self, algo):
         p = Plot().facet(["a", "b"]).limit(x=(.1, .9))
 
         p1 = p.layout(engine=algo).plot()
-        p2 = p.layout(engine=None).plot()
+        p2 = p.layout(engine="none").plot()
 
         # Force a draw (we probably need a method for this)
         p1.save(io.BytesIO())