# 修复代码生成提示词（实例ID：django__django-14894）
## 代码仓库
django/django

## 原始问题描述
Incorrect annotation value when doing a subquery with empty queryset
Description
	
ORM seems to generate annotation/subqueries incorrectly if empty queryset is used. 
Models:
class Article(models.Model):
	author_name = models.CharField(max_length=100)
	content = models.TextField()
	is_public = models.BooleanField()
class Comment(models.Model):
	article = models.ForeignKey(Article, related_name="comments", on_delete=models.CASCADE)
	author_name = models.CharField(max_length=100)
	content = models.TextField()
test data:
article = Article.objects.create(author_name="Jack", content="Example content", is_public=True)
comment = Comment.objects.create(article=article, author_name="John", content="Example comment")
queries:
qs = Article.objects.all()
# keep one list_x uncommented to see the difference:
list_x = ["random_thing_that_is_not_equal_to_any_authors_name"] # list not empty, bug doesnt occur
#list_x = [] # if this list is empty, then the bug occurs
comment_qs = Comment.objects.filter(author_name__in=list_x)
qs = qs.annotate(
	A=Coalesce(Subquery(
		comment_qs.annotate(x=Count('content')).values('x')[:1], output_field=IntegerField(),
	), 101) # if list_x == [], Coalesce wont work and A will be 0 instead of 101
)
# please note that above annotation doesnt make much logical sense, its just for testing purposes
qs = qs.annotate(
	B=Value(99, output_field=IntegerField())
)
qs = qs.annotate(
	C=F("A") + F("B") # if list_x == [], C will result in 0 sic! instead of 101 + 99 = 200
)
data = {
	"A": qs.last().A,
	"B": qs.last().B,
	"C": qs.last().C,
}
print(data)
print(format_sql(qs.query))
console output for list_x=["random_thing_that_is_not_equal_to_any_authors_name"] (expected, correct):
{'A': 101, 'B': 99, 'C': 200}
SELECT "articles_article"."id",
	 "articles_article"."author_name",
	 "articles_article"."content",
	 "articles_article"."is_public",
	 COALESCE(
				 (SELECT COUNT(U0."content") AS "x"
				 FROM "articles_comment" U0
				 WHERE U0."author_name" IN (random_thing_that_is_not_equal_to_any_authors_name)
				 GROUP BY U0."id", U0."article_id", U0."author_name", U0."content"
				 LIMIT 1), 101) AS "A",
	 99 AS "B",
	 (COALESCE(
				 (SELECT COUNT(U0."content") AS "x"
					FROM "articles_comment" U0
					WHERE U0."author_name" IN (random_thing_that_is_not_equal_to_any_authors_name)
					GROUP BY U0."id", U0."article_id", U0."author_name", U0."content"
					LIMIT 1), 101) + 99) AS "C"
FROM "articles_article"
console output for list_x=[] (incorrect):
{'A': 0, 'B': 99, 'C': 0}
SELECT "articles_article"."id",
	 "articles_article"."author_name",
	 "articles_article"."content",
	 "articles_article"."is_public",
	 0 AS "A",
	 99 AS "B",
	 0 AS "C"
FROM "articles_article"
Background story: Above queries are made up (simplified), but based on some parts of logic that I had in my code. list_x was generated dynamically, and it was very hard to detect what is causing unexpected results. This behavior is very strange, I believe its a bug and needs to be fixed, because it is totally unintuitive that:
SomeModel.objects.filter(x__in=["something_that_causes_this_qs_lenth_to_be_0"])
and 
SomeModel.objects.filter(x__in=[]) 
may yield different results when used in queries later, even though results of this querysets are logically equivalent
I will attach a minimal repro project (with code from above)


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py
--- a/tests/aggregation/tests.py
+++ b/tests/aggregation/tests.py
@@ -1367,7 +1367,7 @@ def test_empty_result_optimization(self):
                     'books_count': 0,
                 }
             )
-        # Expression without empty_aggregate_value forces queries to be
+        # Expression without empty_result_set_value forces queries to be
         # executed even if they would return an empty result set.
         raw_books_count = Func('book', function='COUNT')
         raw_books_count.contains_aggregate = True
diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py
--- a/tests/annotations/tests.py
+++ b/tests/annotations/tests.py
@@ -210,6 +210,12 @@ def test_empty_expression_annotation(self):
         self.assertEqual(len(books), Book.objects.count())
         self.assertTrue(all(not book.selected for book in books))
 
+    def test_empty_queryset_annotation(self):
+        qs = Author.objects.annotate(
+            empty=Subquery(Author.objects.values('id').none())
+        )
+        self.assertIsNone(qs.first().empty)
+
     def test_annotate_with_aggregation(self):
         books = Book.objects.annotate(is_book=Value(1), rating_count=Count('rating'))
         for book in books:
diff --git a/tests/db_functions/comparison/test_coalesce.py b/tests/db_functions/comparison/test_coalesce.py
--- a/tests/db_functions/comparison/test_coalesce.py
+++ b/tests/db_functions/comparison/test_coalesce.py
@@ -1,4 +1,4 @@
-from django.db.models import TextField
+from django.db.models import Subquery, TextField
 from django.db.models.functions import Coalesce, Lower
 from django.test import TestCase
 from django.utils import timezone
@@ -70,3 +70,14 @@ def test_ordering(self):
             authors, ['John Smith', 'Rhonda'],
             lambda a: a.name
         )
+
+    def test_empty_queryset(self):
+        Author.objects.create(name='John Smith')
+        tests = [
+            Author.objects.none(),
+            Subquery(Author.objects.none()),
+        ]
+        for empty_query in tests:
+            with self.subTest(empty_query.__class__.__name__):
+                qs = Author.objects.annotate(annotation=Coalesce(empty_query, 42))
+                self.assertEqual(qs.first().annotation, 42)