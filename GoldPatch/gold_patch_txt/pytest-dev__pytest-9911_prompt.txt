# 修复代码生成提示词（实例ID：pytest-dev__pytest-9911）
## 代码仓库
pytest-dev/pytest

## 原始问题描述
Improved error when `()` (empty tuple) is passed to `pytest.raises()` or `pytest.warns()`
When using `pytest.raises()` as a context manager, you can pass an exception type or tuple of exception types; it's then an error if no exception is raised or if the exception raised is not an instance of the expected type(s).  The same logic applies to `pytest.warns()`, which has a near-identical API.

The *problem* is that if you pass the empty tuple `()`, this will *always* result in an error: even if an exception is raised, it can't be an instance of `()`!  I think we should explicitly check tuple inputs, and raise a more helpful error message if they're empty.  For example:

- "Passing `expected_exception=()` is an error, because it's impossible to raise an exception which is not an instance of any type.  Raising exceptions is already understood as failing the test, so you don't need any special code to say 'this should never raise an exception'."  
  (for bonus points, `pytest.raises(None)` should have the same message, with `=None` instead of `=()`)
- The same logic, and same error message, applies to the `raises=` argument to `pytest.mark.xfail()`.
- "Passing `expected_warning=()` is an error, because it's impossible to emit a warning which is not an instance of any type.  To assert that no warnings are emitted, use <whatever we come up with for #9002>


## 参考黄金补丁（正确的修复方案）
diff --git a/testing/python/raises.py b/testing/python/raises.py
--- a/testing/python/raises.py
+++ b/testing/python/raises.py
@@ -19,6 +19,16 @@ def test_raises_function(self):
         excinfo = pytest.raises(ValueError, int, "hello")
         assert "invalid literal" in str(excinfo.value)
 
+    def test_raises_does_not_allow_none(self):
+        with pytest.raises(ValueError, match="Expected an exception type or"):
+            # We're testing that this invalid usage gives a helpful error,
+            # so we can ignore Mypy telling us that None is invalid.
+            pytest.raises(expected_exception=None)  # type: ignore
+
+    def test_raises_does_not_allow_empty_tuple(self):
+        with pytest.raises(ValueError, match="Expected an exception type or"):
+            pytest.raises(expected_exception=())
+
     def test_raises_callable_no_exception(self) -> None:
         class A:
             def __call__(self):