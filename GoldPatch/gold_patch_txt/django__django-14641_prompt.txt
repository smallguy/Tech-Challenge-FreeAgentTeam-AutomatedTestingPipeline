# 修复代码生成提示词（实例ID：django__django-14641）
## 代码仓库
django/django

## 原始问题描述
Move special-case logic in BoundField.initial() to BaseForm.get_initial_for_field()
Description
	
This is another follow-up to ticket #32920.
Currently, BoundField.initial() has logic to special-case time and datetime objects:
​https://github.com/django/django/blob/f5669fd7b568cf8a3eda1e65c1c6fb583c7b177d/django/forms/boundfield.py#L217-L219
I noticed that this logic can be moved to BaseForm.get_initial_for_field(), and in particular under the if callable(value) block:
​https://github.com/django/django/blob/f5669fd7b568cf8a3eda1e65c1c6fb583c7b177d/django/forms/forms.py#L496-L497
Eventually, I think it could make sense to go further and move some of this logic to a new method of the Field class, which could permit the special-casing to be handled by overriding in sub-classes that use times and datetimes.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py
--- a/tests/forms_tests/tests/test_forms.py
+++ b/tests/forms_tests/tests/test_forms.py
@@ -1983,19 +1983,33 @@ class UserRegistration(Form):
         )
 
     def test_get_initial_for_field(self):
+        now = datetime.datetime(2006, 10, 25, 14, 30, 45, 123456)
+
         class PersonForm(Form):
             first_name = CharField(initial='John')
             last_name = CharField(initial='Doe')
             age = IntegerField()
             occupation = CharField(initial=lambda: 'Unknown')
+            dt_fixed = DateTimeField(initial=now)
+            dt_callable = DateTimeField(initial=lambda: now)
 
         form = PersonForm(initial={'first_name': 'Jane'})
-        self.assertIsNone(form.get_initial_for_field(form.fields['age'], 'age'))
-        self.assertEqual(form.get_initial_for_field(form.fields['last_name'], 'last_name'), 'Doe')
-        # Form.initial overrides Field.initial.
-        self.assertEqual(form.get_initial_for_field(form.fields['first_name'], 'first_name'), 'Jane')
-        # Callables are evaluated.
-        self.assertEqual(form.get_initial_for_field(form.fields['occupation'], 'occupation'), 'Unknown')
+        cases = [
+            ('age', None),
+            ('last_name', 'Doe'),
+            # Form.initial overrides Field.initial.
+            ('first_name', 'Jane'),
+            # Callables are evaluated.
+            ('occupation', 'Unknown'),
+            # Microseconds are removed from datetimes.
+            ('dt_fixed', datetime.datetime(2006, 10, 25, 14, 30, 45)),
+            ('dt_callable', datetime.datetime(2006, 10, 25, 14, 30, 45)),
+        ]
+        for field_name, expected in cases:
+            with self.subTest(field_name=field_name):
+                field = form.fields[field_name]
+                actual = form.get_initial_for_field(field, field_name)
+                self.assertEqual(actual, expected)
 
     def test_changed_data(self):
         class Person(Form):
@@ -2097,6 +2111,8 @@ class TextInputWithoutMicrosec(TextInput):
             supports_microseconds = False
 
         class DateTimeForm(Form):
+            # Test a non-callable.
+            fixed = DateTimeField(initial=now)
             auto_timestamp = DateTimeField(initial=delayed_now)
             auto_time_only = TimeField(initial=delayed_now_time)
             supports_microseconds = DateTimeField(initial=delayed_now, widget=TextInput)
@@ -2105,12 +2121,23 @@ class DateTimeForm(Form):
             ti_without_microsec = DateTimeField(initial=delayed_now, widget=TextInputWithoutMicrosec)
 
         unbound = DateTimeForm()
-        self.assertEqual(unbound['auto_timestamp'].value(), now_no_ms)
-        self.assertEqual(unbound['auto_time_only'].value(), now_no_ms.time())
-        self.assertEqual(unbound['supports_microseconds'].value(), now)
-        self.assertEqual(unbound['hi_default_microsec'].value(), now)
-        self.assertEqual(unbound['hi_without_microsec'].value(), now_no_ms)
-        self.assertEqual(unbound['ti_without_microsec'].value(), now_no_ms)
+        cases = [
+            ('fixed', now_no_ms),
+            ('auto_timestamp', now_no_ms),
+            ('auto_time_only', now_no_ms.time()),
+            ('supports_microseconds', now),
+            ('hi_default_microsec', now),
+            ('hi_without_microsec', now_no_ms),
+            ('ti_without_microsec', now_no_ms),
+        ]
+        for field_name, expected in cases:
+            with self.subTest(field_name=field_name):
+                actual = unbound[field_name].value()
+                self.assertEqual(actual, expected)
+                # Also check get_initial_for_field().
+                field = unbound.fields[field_name]
+                actual = unbound.get_initial_for_field(field, field_name)
+                self.assertEqual(actual, expected)
 
     def get_datetime_form_with_callable_initial(self, disabled, microseconds=0):
         class FakeTime: