# 修复代码生成提示词（实例ID：astropy__astropy-13073）
## 代码仓库
astropy/astropy

## 原始问题描述
Document reading True/False in ASCII table as bool not str
<!-- This comments are hidden when you submit the issue,
so you do not need to remove them! -->

<!-- Please be sure to check out our contributing guidelines,
https://github.com/astropy/astropy/blob/main/CONTRIBUTING.md .
Please be sure to check out our code of conduct,
https://github.com/astropy/astropy/blob/main/CODE_OF_CONDUCT.md . -->

<!-- Please have a search on our GitHub repository to see if a similar
issue has already been posted.
If a similar issue is closed, have a quick look to see if you are satisfied
by the resolution.
If not please go ahead and open an issue! -->

### Description
<!-- Provide a general description of the feature you would like. -->
<!-- If you want to, you can suggest a draft design or API. -->
<!-- This way we have a deeper discussion on the feature. -->

#12826 showed a use case for having an ASCII table column consisting of only "True" and "False" be read as `bool` instead of `str` (current behavior). That issue discusses reasons to maintain the current behavior, but there are simple workarounds discussed there that should be brought out to the narrative docs as examples for users.

I'd suggest the following as a recommendation for users:
```
from astropy.io.ascii import convert_numpy
converters = {'*': [convert_numpy(typ) for typ in (int, float, bool, str)]}

# Then for example
dat = Table.read(filename, format='ascii', converters=converters)
```
This new information could go in the existing section on `Converters` in the `io.ascii` read documentation.

### Additional context
<!-- Add any other context or screenshots about the feature request here. -->
<!-- This part is optional. -->

#12826
Control dtype with ascii.read (converters API needs better doc or refactoring)
I cannot find a way to control the dtype of the output table when reading a file into a `Table`. Consider the following MWE, with 3 numerical columns, while one of them would preferably be kept as a string:

```
>>> from astropy.io import ascii

>>> indata = ("# This is a dummy file\n" 
...           "# with some text to ignore, and a header with column names\n" 
...           "# ra dec objid\n" 
...           "1 2 345\n" 
...           "3 4 456\n") 

>>> ascii.read(indata, format='commented_header', header_start=2, guess=False, fast_reader=False)
<Table length=2>
  ra   dec  objid
int64 int64 int64
----- ----- -----
    1     2   345
    3     4   456

>>> ascii.read(indata, format='commented_header', header_start=2, dtye=('i8', 'i8', 'S10'), guess=False, fast_reader=False)
TypeError: __init__() got an unexpected keyword argument 'dtye'
```

Reading in the same with `np.loadtxt` and then converting to a Table works, but it should ideally be supported directly.

```
import numpy as np
from astropy.table import Table

>>> Table(np.loadtxt('/tmp/a', dtype=[('ra', 'i8'), ('dec', 'i8'), ('objid', 'S10')]))
<Table length=2>
  ra   dec   objid 
int64 int64 bytes10
----- ----- -------
    1     2     345
    3     4     456
```


## 参考黄金补丁（正确的修复方案）
diff --git a/astropy/io/ascii/tests/test_read.py b/astropy/io/ascii/tests/test_read.py
--- a/astropy/io/ascii/tests/test_read.py
+++ b/astropy/io/ascii/tests/test_read.py
@@ -1686,3 +1686,47 @@ def test_read_converters_wildcard():
     t = ascii.read(['Fabc Iabc', '1 2'], converters=converters)
     assert np.issubdtype(t['Fabc'].dtype, np.float32)
     assert not np.issubdtype(t['Iabc'].dtype, np.float32)
+
+
+def test_read_converters_simplified():
+    """Test providing io.ascii read converters as type or dtypes instead of
+    convert_numpy(type) outputs"""
+    t = Table()
+    t['a'] = [1, 2]
+    t['b'] = [3.5, 4]
+    t['c'] = ['True', 'False']
+    t['d'] = ['true', 'false']  # Looks kindof like boolean but actually a string
+    t['e'] = [5, 6]
+
+    out = StringIO()
+    t.write(out, format='ascii.basic')
+
+    converters = {'a': str, 'e': np.float32}
+    t2 = Table.read(out.getvalue(), format='ascii.basic', converters=converters)
+    assert t2.pformat(show_dtype=True) == [
+        ' a      b      c     d      e   ',
+        'str1 float64  str5  str5 float32',
+        '---- ------- ----- ----- -------',
+        '   1     3.5  True  true     5.0',
+        '   2     4.0 False false     6.0'
+    ]
+
+    converters = {'a': float, '*': [np.int64, float, bool, str]}
+    t2 = Table.read(out.getvalue(), format='ascii.basic', converters=converters)
+    assert t2.pformat_all(show_dtype=True) == [
+        '   a       b      c     d     e  ',
+        'float64 float64  bool  str5 int64',
+        '------- ------- ----- ----- -----',
+        '    1.0     3.5  True  true     5',
+        '    2.0     4.0 False false     6'
+    ]
+
+    # Test failures
+    for converters in ({'*': [int, 1, bool, str]},  # bad converter type
+                       # Tuple converter where 2nd element is not a subclass of NoType
+                       {'a': [(int, int)]},
+                       # Tuple converter with 3 elements not 2
+                       {'a': [(int, int, int)]}):
+        with pytest.raises(ValueError, match='Error: invalid format for converters'):
+            t2 = Table.read(out.getvalue(), format='ascii.basic',
+                            converters=converters, guess=False)