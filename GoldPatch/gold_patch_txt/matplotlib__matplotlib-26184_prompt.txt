# 修复代码生成提示词（实例ID：matplotlib__matplotlib-26184）
## 代码仓库
matplotlib/matplotlib

## 原始问题描述
[Bug]: AnnotationBbox does not return correct window_extent before first draw
### Bug summary

I’m trying to use a constrained layout in a visualization that contains an artist that is an instance of AnnotationBbox, and matplotlib raises a warning saying constrained layout is not applied. The visual effect is not evident in this simple example, but it becomes very clear once we have multiple panels.

### Code for reproduction

```python
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.offsetbox import AnnotationBbox, TextArea

fig, ax = plt.subplots(layout="constrained")

ab = AnnotationBbox(
    TextArea("Some text", textprops={"size": 42}),
    (0.5, 0.5),
    xycoords="axes fraction",
    box_alignment=(0.5, 0.5),
    pad=0
)

ax.add_artist(ab)
fig.set_facecolor("w")
fig.savefig("annotation_box.png", dpi=300)
```


### Actual outcome

UserWarning: constrained_layout not applied because axes sizes collapsed to zero.  Try making figure larger or axes decorations smaller.


### Expected outcome

No warning should appear

### Additional information

The following works without any warning

```python
fig, ax = plt.subplots(layout="constrained")
ax.text(0.5, 0.5, "Some text", size=42, ha="center")
fig.set_facecolor("w")
fig.savefig("ax_text.png", dpi=300)
```


The problem with the constrained layout is more evident if I have two or more panels.
One way of fixing it (i.e. getting rid of the warning and bad functionality) is to do ab.set_in_layout(False) before doing ax.add_artist(ab).

This was first posted on Discourse https://discourse.matplotlib.org/t/constrained-layout-does-not-work-well-with-annotationbbox/23301

### Operating system

Ubuntu 22

### Matplotlib Version

3.6.2

### Matplotlib Backend

_No response_

### Python version

_No response_

### Jupyter version

_No response_

### Installation

pip


## 参考黄金补丁（正确的修复方案）
diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py
--- a/lib/matplotlib/tests/test_offsetbox.py
+++ b/lib/matplotlib/tests/test_offsetbox.py
@@ -257,7 +257,8 @@ def test_anchoredtext_horizontal_alignment():
     ax.add_artist(text2)
 
 
-def test_annotationbbox_extents():
+@pytest.mark.parametrize("extent_kind", ["window_extent", "tightbbox"])
+def test_annotationbbox_extents(extent_kind):
     plt.rcParams.update(plt.rcParamsDefault)
     fig, ax = plt.subplots(figsize=(4, 3), dpi=100)
 
@@ -284,31 +285,22 @@ def test_annotationbbox_extents():
                          arrowprops=dict(arrowstyle="->"))
     ax.add_artist(ab6)
 
-    fig.canvas.draw()
-    renderer = fig.canvas.get_renderer()
-
     # Test Annotation
-    bb1w = an1.get_window_extent(renderer)
-    bb1e = an1.get_tightbbox(renderer)
+    bb1 = getattr(an1, f"get_{extent_kind}")()
 
     target1 = [332.9, 242.8, 467.0, 298.9]
-    assert_allclose(bb1w.extents, target1, atol=2)
-    assert_allclose(bb1e.extents, target1, atol=2)
+    assert_allclose(bb1.extents, target1, atol=2)
 
     # Test AnnotationBbox
-    bb3w = ab3.get_window_extent(renderer)
-    bb3e = ab3.get_tightbbox(renderer)
+    bb3 = getattr(ab3, f"get_{extent_kind}")()
 
     target3 = [-17.6, 129.0, 200.7, 167.9]
-    assert_allclose(bb3w.extents, target3, atol=2)
-    assert_allclose(bb3e.extents, target3, atol=2)
+    assert_allclose(bb3.extents, target3, atol=2)
 
-    bb6w = ab6.get_window_extent(renderer)
-    bb6e = ab6.get_tightbbox(renderer)
+    bb6 = getattr(ab6, f"get_{extent_kind}")()
 
     target6 = [180.0, -32.0, 230.0, 92.9]
-    assert_allclose(bb6w.extents, target6, atol=2)
-    assert_allclose(bb6e.extents, target6, atol=2)
+    assert_allclose(bb6.extents, target6, atol=2)
 
     # Test bbox_inches='tight'
     buf = io.BytesIO()