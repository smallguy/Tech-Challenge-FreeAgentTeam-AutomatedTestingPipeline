# 修复代码生成提示词（实例ID：django__django-15483）
## 代码仓库
django/django

## 原始问题描述
AppAdmin class for customizing app listing in admin index
Description
	
See ​http://code.djangoproject.com/wiki/DjangoSpecifications/NfAdmin/FlexibleAppHandling for details.
This supplements the app directive.
As discussed with brosner and jkocherhans in #django-dev:
<brosner> it looks reasonable, but haven't spent much time thinking about it
<jkocherhans> mrts: I think this is clearly backwards incompatible with the current nfa api and has to go in pre 1.0 if it goes in at all
<jkocherhans> I'm a big -1 on the order attribute and -0 on models (maybe just a different syntax), but the other stuff seems reasonable
<mrts> jkocherhans: what's wrong with ordering?
<jkocherhans> it just feels like the wrong place to specify it
<jkocherhans> it's a global issue, and an issue any particular app should handle
<mrts> my use case: I have a lot of functionality exposed to somewhat dumb users
<mrts> and they have trouble finding the right bits in the admin interface
 ordering is only used in context of admin index
 I would like to put the important apps to top and collapse the rest
<jkocherhans> exactly. what should 3rd party apps put there? therein lies my objection.
<mrts> well, I'd say decouple admin from models (as nfa already does) and don't specify any admin options at all -- users are free to customize things with AppAdmin
<jkocherhans> I guess not if using a AppAdmin class is optional. I was originally thinking it would replace model registration with an admin site.
<mrts> jkocherhans: yeah, that's what I kinda meant... it looks more coherent this way
 jkocherhans: and it may solve some of the issues register() currently has
<jkocherhans> mrts: I'm gonna have to let it sit for awhile. I'm trying to think of what else an AdminApp class would do besides being a coathanger for a few attributes, nothing is coming to mind.
<mrts> jkocherhans: but jezdez has a point -- it would also provide easy bridging for app instances
Example syntax follows.
class BarModelAdmin(admin.ModelAdmin):
 description = 'A bar is a bar is a bar'
 ...
class FooAppAdmin(admin.AppAdmin):
	app = settings.INSTALLED_APPS[0]
	name = "Foo" # overrides app().name
	description = "An application that does foo"
	style = {'classes' : ('collapse',)}
	order = 1
	models = ( # model order in this list determines their display order in app block
	 (BarModel, BarModelAdmin),
	 (BazModel, None), # use default ModelAdmin, don't show description
 )
admin.site.register(FooAppAdmin) # no need for the tedious for model in [A, B, C, D]: admin.site.register(model)


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/admin_views/customadmin.py b/tests/admin_views/customadmin.py
--- a/tests/admin_views/customadmin.py
+++ b/tests/admin_views/customadmin.py
@@ -35,6 +35,14 @@ def my_view(self, request):
     def password_change(self, request, extra_context=None):
         return super().password_change(request, {"spam": "eggs"})
 
+    def get_app_list(self, request, app_label=None):
+        app_list = super().get_app_list(request, app_label=app_label)
+        # Reverse order of apps and models.
+        app_list = list(reversed(app_list))
+        for app in app_list:
+            app["models"].sort(key=lambda x: x["name"], reverse=True)
+        return app_list
+
 
 class UserLimitedAdmin(UserAdmin):
     # used for testing password change on a user not in queryset
diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py
--- a/tests/admin_views/tests.py
+++ b/tests/admin_views/tests.py
@@ -1354,6 +1354,20 @@ def test_app_index_context(self):
         )
         self.assertEqual(response.context["title"], "Admin_Views administration")
         self.assertEqual(response.context["app_label"], "admin_views")
+        # Models are sorted alphabetically by default.
+        models = [model["name"] for model in response.context["app_list"][0]["models"]]
+        self.assertSequenceEqual(models, sorted(models))
+
+    def test_app_index_context_reordered(self):
+        self.client.force_login(self.superuser)
+        response = self.client.get(reverse("admin2:app_list", args=("admin_views",)))
+        self.assertContains(
+            response,
+            "<title>Admin_Views administration | Django site admin</title>",
+        )
+        # Models are in reverse order.
+        models = [model["name"] for model in response.context["app_list"][0]["models"]]
+        self.assertSequenceEqual(models, sorted(models, reverse=True))
 
     def test_change_view_subtitle_per_object(self):
         response = self.client.get(