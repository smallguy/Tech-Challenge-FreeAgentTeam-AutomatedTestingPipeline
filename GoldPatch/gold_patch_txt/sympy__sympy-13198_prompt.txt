# 修复代码生成提示词（实例ID：sympy__sympy-13198）
## 代码仓库
sympy/sympy

## 原始问题描述
Problem factoring trivial polynomial
```
>>> import sympy as sp
>>> x, y = sp.symbols('x y')
>>> z = 0.0001 * (x * (x + (4.0 * y))) + 0.0001 * (y * (x + (4.0 * y)))
>>> z
0.0001*x*(x + 4.0*y) + 0.0001*y*(x + 4.0*y)
>>> w = sp.expand(z)
>>> w
0.0001*x**2 + 0.0005*x*y + 0.0004*y**2
>>> v = sp.factor(w)
>>> v
1.0*(0.0001*x + 0.0001*y)*(0.0001*x + 0.0004*y)
>>> sp.expand(v)
1.0e-8*x**2 + 5.0e-8*x*y + 4.0e-8*y**2
>>> sp.__version__
'0.7.6'
```

The factoring of w is incorrect - look at the order of x it is 10^-8 not 10^-4.

Bug in simplify ?
Hi, I'm running into issues where simplify comes up with incorrect results.

sympy verion 1.0, python version 3.52, ubuntu 16.04. I've also verified the same with the Sympy online console (http://live.sympy.org/).

The problem comes when trying to simplify a mass matrix for a simple 3-DOF robot:
```
q_1 = Symbol('q_1')
q_2 = Symbol('q_2')
q_3 = Symbol('q_3')
q = [q_1,q_2,q_3]

Mq = Matrix([[(1.0*cos(q_2) + 0.5*cos(q_2 + q_3))**2*sin(q_1)**2 + (1.0*cos(q_2) + 0.5*cos(q_2 + q_3))**2*cos(q_1)**2 + 0.25*sin(q_1)**2*cos(q_2)**2 + 0.25*cos(q_1)**2*cos(q_2)**2, 0, 0], [0, (-1.0*sin(q_2) - 0.5*sin(q_2 + q_3))**2*sin(q_1)**2 + (-1.0*sin(q_2) - 0.5*sin(q_2 + q_3))**2*cos(q_1)**2 + (-1.0*cos(q_2) - 0.5*cos(q_2 + q_3))**2 + 0.25*sin(q_1)**2*sin(q_2)**2 + 0.25*sin(q_2)**2*cos(q_1)**2 + 0.25*cos(q_2)**2, -0.5*(-1.0*sin(q_2) - 0.5*sin(q_2 + q_3))*sin(q_1)**2*sin(q_2 + q_3) - 0.5*(-1.0*sin(q_2) - 0.5*sin(q_2 + q_3))*sin(q_2 + q_3)*cos(q_1)**2 - 0.5*(-1.0*cos(q_2) - 0.5*cos(q_2 + q_3))*cos(q_2 + q_3)], [0, -0.5*(-1.0*sin(q_2) - 0.5*sin(q_2 + q_3))*sin(q_1)**2*sin(q_2 + q_3) - 0.5*(-1.0*sin(q_2) - 0.5*sin(q_2 + q_3))*sin(q_2 + q_3)*cos(q_1)**2 - 0.5*(-1.0*cos(q_2) - 0.5*cos(q_2 + q_3))*cos(q_2 + q_3), 0.25*sin(q_1)**2*sin(q_2 + q_3)**2 + 0.25*sin(q_2 + q_3)**2*cos(q_1)**2 + 0.25*cos(q_2 + q_3)**2]])
```

If I use the matrix above directly, I get correct results:
```
Mq_fnc = lambdify(q,Mq)
print(Mq_fnc(0,0,0))
```
which should be:
```
[[ 2.5   0.    0.  ]
 [ 0.    2.5   0.75]
 [ 0.    0.75  0.25]]
```

If on the other hand, I simplify first
```
Mqs = simplify(Mq)
Mqs_fnc = lambdify(q,Mqs)
print(Mqs_fnc(0,0,0))
```

I get an incorrect result:

```
[[ 0.625  0.     0.   ]
 [ 0.     2.5    0.75 ]
 [ 0.     0.75   0.25 ]]
```

I was wondering if this is a bug with simplify, or am I doing something wrong?

Thanks.


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/polys/tests/test_factortools.py b/sympy/polys/tests/test_factortools.py
--- a/sympy/polys/tests/test_factortools.py
+++ b/sympy/polys/tests/test_factortools.py
@@ -528,7 +528,10 @@ def test_dup_factor_list():
 
     f = 6.7225336055071*x**2 - 10.6463972754741*x - 0.33469524022264
     coeff, factors = R.dup_factor_list(f)
-    assert coeff == RR(1.0) and len(factors) == 1 and factors[0][0].almosteq(f, 1e-10) and factors[0][1] == 1
+    assert coeff == RR(10.6463972754741)
+    assert len(factors) == 1
+    assert factors[0][0].max_norm() == RR(1.0)
+    assert factors[0][1] == 1
 
     Rt, t = ring("t", ZZ)
     R, x = ring("x", Rt)
@@ -628,12 +631,15 @@ def test_dmp_factor_list():
     f = 2.0*x**2 - 8.0*y**2
 
     assert R.dmp_factor_list(f) == \
-        (RR(2.0), [(1.0*x - 2.0*y, 1),
-                   (1.0*x + 2.0*y, 1)])
+        (RR(8.0), [(0.5*x - y, 1),
+                   (0.5*x + y, 1)])
 
     f = 6.7225336055071*x**2*y**2 - 10.6463972754741*x*y - 0.33469524022264
     coeff, factors = R.dmp_factor_list(f)
-    assert coeff == RR(1.0) and len(factors) == 1 and factors[0][0].almosteq(f, 1e-10) and factors[0][1] == 1
+    assert coeff == RR(10.6463972754741)
+    assert len(factors) == 1
+    assert factors[0][0].max_norm() == RR(1.0)
+    assert factors[0][1] == 1
 
     Rt, t = ring("t", ZZ)
     R, x, y = ring("x,y", Rt)
diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py
--- a/sympy/polys/tests/test_polytools.py
+++ b/sympy/polys/tests/test_polytools.py
@@ -2444,6 +2444,11 @@ def test_factor():
 
     assert factor(sqrt(x**2)) == sqrt(x**2)
 
+    # issue 13149
+    assert factor(expand((0.5*x+1)*(0.5*y+1))) == Mul(1.0, 0.5*x + 1.0,
+        0.5*y + 1.0, evaluate = False)
+    assert factor(expand((0.5*x+0.5)**2)) == 0.25*(1.0*x + 1.0)**2
+
 
 def test_factor_large():
     f = (x**2 + 4*x + 4)**10000000*(x**2 + 1)*(x**2 + 2*x + 1)**1234567
diff --git a/sympy/simplify/tests/test_combsimp.py b/sympy/simplify/tests/test_combsimp.py
--- a/sympy/simplify/tests/test_combsimp.py
+++ b/sympy/simplify/tests/test_combsimp.py
@@ -1,7 +1,7 @@
 from sympy import (
     Rational, combsimp, factorial, gamma, binomial, Symbol, pi, S,
     sin, exp, powsimp, sqrt, sympify, FallingFactorial, RisingFactorial,
-    simplify, symbols, cos, rf)
+    simplify, symbols, cos, rf, Mul)
 
 from sympy.abc import x, y, z, t, a, b, c, d, e, f, g, h, i, k
 
@@ -28,7 +28,8 @@ def test_combsimp():
     assert combsimp(binomial(n + 2, k + S(1)/2)) == 4*((n + 1)*(n + 2) *
         binomial(n, k + S(1)/2))/((2*k - 2*n - 1)*(2*k - 2*n - 3))
     assert combsimp(binomial(n + 2, k + 2.0)) == \
-        -((1.0*n + 2.0)*binomial(n + 1.0, k + 2.0))/(k - n)
+        Mul(-2.0, 0.5*n + 1.0, binomial(n + 1.0, k + 2.0),
+        evaluate = False)/(k - n)
 
     # coverage tests
     assert combsimp(factorial(n*(1 + n) - n**2 - n)) == 1