# 修复代码生成提示词（实例ID：django__django-12734）
## 代码仓库
django/django

## 原始问题描述
Migration doesn't detect precision changes in fields that ManyToMany points to.
Description
	
In my case was:
models.py:
class Vulnerability(models.Model):
	cve_id = models.CharField(max_length=15, primary_key=True)
	app = models.ManyToManyField(AppVersion)
	class Meta:
		managed = True
Later, i changed cve_id max_length to 100 and did migration:
operations = [
		migrations.AlterField(
			model_name='vulnerability',
			name='cve_id',
			field=models.CharField(max_length=100, primary_key=True, serialize=False),
		),
	]
In result:
cve_id field length was changed, but vulnerability_id field length in table vulnerability_app remain unchanged


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py
--- a/tests/migrations/test_operations.py
+++ b/tests/migrations/test_operations.py
@@ -3,7 +3,6 @@
     IntegrityError, connection, migrations, models, transaction,
 )
 from django.db.migrations.migration import Migration
-from django.db.migrations.operations import CreateModel
 from django.db.migrations.operations.fields import FieldOperation
 from django.db.migrations.state import ModelState, ProjectState
 from django.db.transaction import atomic
@@ -1276,6 +1275,16 @@ def test_alter_field_pk_fk(self):
         Tests the AlterField operation on primary keys changes any FKs pointing to it.
         """
         project_state = self.set_up_test_model("test_alflpkfk", related_model=True)
+        project_state = self.apply_operations('test_alflpkfk', project_state, [
+            migrations.CreateModel('Stable', fields=[
+                ('ponies', models.ManyToManyField('Pony')),
+            ]),
+            migrations.AddField(
+                'Pony',
+                'stables',
+                models.ManyToManyField('Stable'),
+            ),
+        ])
         # Test the state alteration
         operation = migrations.AlterField("Pony", "id", models.FloatField(primary_key=True))
         new_state = project_state.clone()
@@ -1295,8 +1304,26 @@ def assertIdTypeEqualsFkType():
                     for c in connection.introspection.get_table_description(cursor, "test_alflpkfk_rider")
                     if c.name == "pony_id"
                 ][0]
+                m2m_fk_type, m2m_fk_null = [
+                    (c.type_code, c.null_ok)
+                    for c in connection.introspection.get_table_description(
+                        cursor,
+                        'test_alflpkfk_pony_stables',
+                    ) if c.name == 'pony_id'
+                ][0]
+                remote_m2m_fk_type, remote_m2m_fk_null = [
+                    (c.type_code, c.null_ok)
+                    for c in connection.introspection.get_table_description(
+                        cursor,
+                        'test_alflpkfk_stable_ponies',
+                    ) if c.name == 'pony_id'
+                ][0]
             self.assertEqual(id_type, fk_type)
+            self.assertEqual(id_type, m2m_fk_type)
+            self.assertEqual(id_type, remote_m2m_fk_type)
             self.assertEqual(id_null, fk_null)
+            self.assertEqual(id_null, m2m_fk_null)
+            self.assertEqual(id_null, remote_m2m_fk_null)
 
         assertIdTypeEqualsFkType()
         # Test the database alteration
@@ -1314,7 +1341,7 @@ def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):
         project_state = self.apply_operations(app_label, ProjectState(), operations=[
             migrations.CreateModel('Rider', fields=[
                 ('id', models.AutoField(primary_key=True)),
-                ('code', models.PositiveIntegerField(unique=True)),
+                ('code', models.IntegerField(unique=True)),
             ]),
             migrations.CreateModel('Pony', fields=[
                 ('id', models.AutoField(primary_key=True)),
@@ -1327,6 +1354,18 @@ def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):
             models.CharField(max_length=100, unique=True),
         )
         self.apply_operations(app_label, project_state, operations=[operation])
+        id_type, id_null = [
+            (c.type_code, c.null_ok)
+            for c in self.get_table_description('%s_rider' % app_label)
+            if c.name == 'code'
+        ][0]
+        fk_type, fk_null = [
+            (c.type_code, c.null_ok)
+            for c in self.get_table_description('%s_pony' % app_label)
+            if c.name == 'rider_id'
+        ][0]
+        self.assertEqual(id_type, fk_type)
+        self.assertEqual(id_null, fk_null)
 
     @skipUnlessDBFeature('supports_foreign_keys')
     def test_alter_field_reloads_state_on_fk_with_to_field_related_name_target_type_change(self):
@@ -1754,7 +1793,7 @@ def test_add_constraint(self):
     def test_add_constraint_percent_escaping(self):
         app_label = 'add_constraint_string_quoting'
         operations = [
-            CreateModel(
+            migrations.CreateModel(
                 'Author',
                 fields=[
                     ('id', models.AutoField(primary_key=True)),
@@ -1820,7 +1859,7 @@ def test_add_or_constraint(self):
     def test_add_constraint_combinable(self):
         app_label = 'test_addconstraint_combinable'
         operations = [
-            CreateModel(
+            migrations.CreateModel(
                 'Book',
                 fields=[
                     ('id', models.AutoField(primary_key=True)),
@@ -2917,7 +2956,11 @@ def test_indexes_ignore_swapped(self):
 class TestCreateModel(SimpleTestCase):
 
     def test_references_model_mixin(self):
-        CreateModel('name', [], bases=(Mixin, models.Model)).references_model('other_model', 'migrations')
+        migrations.CreateModel(
+            'name',
+            fields=[],
+            bases=(Mixin, models.Model),
+        ).references_model('other_model', 'migrations')
 
 
 class FieldOperationTests(SimpleTestCase):