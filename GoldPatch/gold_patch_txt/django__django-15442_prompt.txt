# 修复代码生成提示词（实例ID：django__django-15442）
## 代码仓库
django/django

## 原始问题描述
django.utils.safestring.mark_safe forces evaluation of lazy objects
Description
	
Consider the following example:
from django.utils.safestring import mark_safe
from django.utils.translation import activate, ugettext_lazy as _
s = mark_safe(_("username"))
tpl = Template('{{ s }}')
activate('fr')
print(tpl.render(Context({'s': s})))
I would expect this to output nom d'utilisateur (which is the french translation of username) but what happens instead is that it outputs username.
The reason for this is that mark_safe will force the evaluation of the lazy string provided by ugettext_lazy when it's called.
Unfortunately, the solution to this it trickier than simply wrapping mark_safe with django.utils.functional.allow_lazy, because mark_safe can operate both on bytes and text (and allow_lazy needs to know the type of object return by the wrapped function).
I wrote some tests and a proposed solution on my branch: ​https://github.com/bmispelon/django/compare/lazy-safedata


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/utils_tests/test_safestring.py b/tests/utils_tests/test_safestring.py
--- a/tests/utils_tests/test_safestring.py
+++ b/tests/utils_tests/test_safestring.py
@@ -1,8 +1,9 @@
 from django.template import Context, Template
 from django.test import SimpleTestCase
-from django.utils import html
-from django.utils.functional import lazy, lazystr
+from django.utils import html, translation
+from django.utils.functional import Promise, lazy, lazystr
 from django.utils.safestring import SafeData, SafeString, mark_safe
+from django.utils.translation import gettext_lazy
 
 
 class customescape(str):
@@ -40,10 +41,17 @@ def test_mark_safe_object_implementing_dunder_html(self):
         self.assertRenderEqual("{{ s|force_escape }}", "&lt;a&amp;b&gt;", s=s)
 
     def test_mark_safe_lazy(self):
-        s = lazystr("a&b")
+        safe_s = mark_safe(lazystr("a&b"))
 
-        self.assertIsInstance(mark_safe(s), SafeData)
-        self.assertRenderEqual("{{ s }}", "a&b", s=mark_safe(s))
+        self.assertIsInstance(safe_s, Promise)
+        self.assertRenderEqual("{{ s }}", "a&b", s=safe_s)
+        self.assertIsInstance(str(safe_s), SafeData)
+
+    def test_mark_safe_lazy_i18n(self):
+        s = mark_safe(gettext_lazy("name"))
+        tpl = Template("{{ s }}")
+        with translation.override("fr"):
+            self.assertEqual(tpl.render(Context({"s": s})), "nom")
 
     def test_mark_safe_object_implementing_dunder_str(self):
         class Obj: