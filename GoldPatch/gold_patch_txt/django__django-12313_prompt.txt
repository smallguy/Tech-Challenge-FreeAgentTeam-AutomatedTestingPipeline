# 修复代码生成提示词（实例ID：django__django-12313）
## 代码仓库
django/django

## 原始问题描述
makemigrations does not detect/like model name case changes
Description
	
Starting with 
class Evidence(models.Model):
	rubrictype = models.ForeignKey('Rubrictype')
class Rubrictype(models.Model):
	type_code = models.CharField(max_length=1)
Make the initial migration:
$ ./manage.py makemigrations
Migrations for 'as_migrations':
 0001_initial.py:
	- Create model Evidence
	- Create model Rubrictype
	- Add field rubrictype to evidence
Change the name of Rubrictype to RubricType:
class Evidence(models.Model):
	rubrictype = models.ForeignKey('RubricType')
class RubricType(models.Model):
	type_code = models.CharField(max_length=1)
Generate the migration:
$ ./manage.py makemigrations
Migrations for 'as_migrations':
 0002_auto_20141125_1930.py:
	- Alter field rubrictype on evidence
Django does not detect the name change on the RubricType model itself. No confirmation is requested for the name change and no operation is generated. The problem is that any subsequent makemigrations run will generate the same operation ad infinitum:
$ ./manage.py makemigrations
Migrations for 'as_migrations':
 0003_auto_20141125_1930.py:
	- Alter field rubrictype on evidence
If instead the name is changed to RubricXype:
class Evidence(models.Model):
	rubrictype = models.ForeignKey('RubricXype')
class RubricXype(models.Model):
	type_code = models.CharField(max_length=1)
the corresponding migration becomes
$ ./manage.py makemigrations
Did you rename the as_migrations.Rubrictype model to RubricXype? [y/N] y
Migrations for 'as_migrations':
 0002_auto_20141125_1956.py:
	- Rename model Rubrictype to RubricXype
This migration generates a RenameModel operation only and any subsequent makemigrations runs will properly report "No changes detected". So it appears the change detector does not pick up on capitalization changes in model names.
Trying to work around by adding a 
migrations.RenameModel(
	old_name='Rubrictype',
	new_name='RubricType',
)
to the auto generated operations results in a ValueError exception when makemigrations is run again:
$ ./manage.py makemigrations
Traceback (most recent call last):
 File "manage.py", line 10, in <module>
	execute_from_command_line(sys.argv)
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/core/management/__init__.py", line 385, in execute_from_command_line
	utility.execute()
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/core/management/__init__.py", line 377, in execute
	self.fetch_command(subcommand).run_from_argv(self.argv)
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/core/management/base.py", line 288, in run_from_argv
	self.execute(*args, **options.__dict__)
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/core/management/base.py", line 338, in execute
	output = self.handle(*args, **options)
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/core/management/commands/makemigrations.py", line 111, in handle
	convert_apps=app_labels or None,
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/db/migrations/autodetector.py", line 42, in changes
	changes = self._detect_changes(convert_apps, graph)
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/db/migrations/autodetector.py", line 109, in _detect_changes
	self.old_apps = self.from_state.render(ignore_swappable=True)
 File "/home/svencoenye/developer/django_test/lib/python2.7/site-packages/django/db/migrations/state.py", line 89, in render
	model=lookup_model,
ValueError: Lookup failed for model referenced by field as_migrations.Evidence.rubrictype: as_migrations.RubricType
The sequence of the operations does not matter. Neither does substituting the RenameModel operation for the AlterField operation.
(Looking at the next to last entry in the traceback, the autodetector seems to be looking for the new name in the old_apps state?)
It is possible, however, to go the long way around and use two separate migrations: Rubrictype -> RubricXype. RubricXype -> RubricType works without getting the migration state stuck and does not throw an exception.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/field_deconstruction/tests.py b/tests/field_deconstruction/tests.py
--- a/tests/field_deconstruction/tests.py
+++ b/tests/field_deconstruction/tests.py
@@ -202,39 +202,39 @@ def test_foreign_key(self):
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "on_delete": models.CASCADE})
         self.assertFalse(hasattr(kwargs['to'], "setting_name"))
         # Test swap detection for swappable model
         field = models.ForeignKey("auth.User", models.CASCADE)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.User", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.user", "on_delete": models.CASCADE})
         self.assertEqual(kwargs['to'].setting_name, "AUTH_USER_MODEL")
         # Test nonexistent (for now) model
         field = models.ForeignKey("something.Else", models.CASCADE)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "something.Else", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "something.else", "on_delete": models.CASCADE})
         # Test on_delete
         field = models.ForeignKey("auth.User", models.SET_NULL)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.User", "on_delete": models.SET_NULL})
+        self.assertEqual(kwargs, {"to": "auth.user", "on_delete": models.SET_NULL})
         # Test to_field preservation
         field = models.ForeignKey("auth.Permission", models.CASCADE, to_field="foobar")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "to_field": "foobar", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "to_field": "foobar", "on_delete": models.CASCADE})
         # Test related_name preservation
         field = models.ForeignKey("auth.Permission", models.CASCADE, related_name="foobar")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "related_name": "foobar", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "related_name": "foobar", "on_delete": models.CASCADE})
         # Test related_query_name
         field = models.ForeignKey("auth.Permission", models.CASCADE, related_query_name="foobar")
         name, path, args, kwargs = field.deconstruct()
@@ -242,7 +242,7 @@ def test_foreign_key(self):
         self.assertEqual(args, [])
         self.assertEqual(
             kwargs,
-            {"to": "auth.Permission", "related_query_name": "foobar", "on_delete": models.CASCADE}
+            {"to": "auth.permission", "related_query_name": "foobar", "on_delete": models.CASCADE}
         )
         # Test limit_choices_to
         field = models.ForeignKey("auth.Permission", models.CASCADE, limit_choices_to={'foo': 'bar'})
@@ -251,14 +251,14 @@ def test_foreign_key(self):
         self.assertEqual(args, [])
         self.assertEqual(
             kwargs,
-            {"to": "auth.Permission", "limit_choices_to": {'foo': 'bar'}, "on_delete": models.CASCADE}
+            {"to": "auth.permission", "limit_choices_to": {'foo': 'bar'}, "on_delete": models.CASCADE}
         )
         # Test unique
         field = models.ForeignKey("auth.Permission", models.CASCADE, unique=True)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "unique": True, "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "unique": True, "on_delete": models.CASCADE})
 
     @override_settings(AUTH_USER_MODEL="auth.Permission")
     def test_foreign_key_swapped(self):
@@ -270,7 +270,7 @@ def test_foreign_key_swapped(self):
 
         self.assertEqual(path, "django.db.models.ForeignKey")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "on_delete": models.CASCADE})
         self.assertEqual(kwargs['to'].setting_name, "AUTH_USER_MODEL")
 
     def test_one_to_one(self):
@@ -282,39 +282,39 @@ def test_one_to_one(self):
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "on_delete": models.CASCADE})
         self.assertFalse(hasattr(kwargs['to'], "setting_name"))
         # Test swap detection for swappable model
         field = models.OneToOneField("auth.User", models.CASCADE)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.User", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.user", "on_delete": models.CASCADE})
         self.assertEqual(kwargs['to'].setting_name, "AUTH_USER_MODEL")
         # Test nonexistent (for now) model
         field = models.OneToOneField("something.Else", models.CASCADE)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "something.Else", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "something.else", "on_delete": models.CASCADE})
         # Test on_delete
         field = models.OneToOneField("auth.User", models.SET_NULL)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.User", "on_delete": models.SET_NULL})
+        self.assertEqual(kwargs, {"to": "auth.user", "on_delete": models.SET_NULL})
         # Test to_field
         field = models.OneToOneField("auth.Permission", models.CASCADE, to_field="foobar")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "to_field": "foobar", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "to_field": "foobar", "on_delete": models.CASCADE})
         # Test related_name
         field = models.OneToOneField("auth.Permission", models.CASCADE, related_name="foobar")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "related_name": "foobar", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "related_name": "foobar", "on_delete": models.CASCADE})
         # Test related_query_name
         field = models.OneToOneField("auth.Permission", models.CASCADE, related_query_name="foobar")
         name, path, args, kwargs = field.deconstruct()
@@ -322,7 +322,7 @@ def test_one_to_one(self):
         self.assertEqual(args, [])
         self.assertEqual(
             kwargs,
-            {"to": "auth.Permission", "related_query_name": "foobar", "on_delete": models.CASCADE}
+            {"to": "auth.permission", "related_query_name": "foobar", "on_delete": models.CASCADE}
         )
         # Test limit_choices_to
         field = models.OneToOneField("auth.Permission", models.CASCADE, limit_choices_to={'foo': 'bar'})
@@ -331,14 +331,14 @@ def test_one_to_one(self):
         self.assertEqual(args, [])
         self.assertEqual(
             kwargs,
-            {"to": "auth.Permission", "limit_choices_to": {'foo': 'bar'}, "on_delete": models.CASCADE}
+            {"to": "auth.permission", "limit_choices_to": {'foo': 'bar'}, "on_delete": models.CASCADE}
         )
         # Test unique
         field = models.OneToOneField("auth.Permission", models.CASCADE, unique=True)
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.OneToOneField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "on_delete": models.CASCADE})
+        self.assertEqual(kwargs, {"to": "auth.permission", "on_delete": models.CASCADE})
 
     def test_image_field(self):
         field = models.ImageField(upload_to="foo/barness", width_field="width", height_field="height")
diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py
--- a/tests/migrations/test_autodetector.py
+++ b/tests/migrations/test_autodetector.py
@@ -1014,7 +1014,7 @@ def test_rename_related_field_preserved_db_column(self):
             'renamed_foo',
             'django.db.models.ForeignKey',
             [],
-            {'to': 'app.Foo', 'on_delete': models.CASCADE, 'db_column': 'foo_id'},
+            {'to': 'app.foo', 'on_delete': models.CASCADE, 'db_column': 'foo_id'},
         ))
 
     def test_rename_model(self):
@@ -1032,6 +1032,22 @@ def test_rename_model(self):
         # no AlterField for the related field.
         self.assertNumberMigrations(changes, 'otherapp', 0)
 
+    def test_rename_model_case(self):
+        """
+        Model name is case-insensitive. Changing case doesn't lead to any
+        autodetected operations.
+        """
+        author_renamed = ModelState('testapp', 'author', [
+            ('id', models.AutoField(primary_key=True)),
+        ])
+        changes = self.get_changes(
+            [self.author_empty, self.book],
+            [author_renamed, self.book],
+            questioner=MigrationQuestioner({'ask_rename_model': True}),
+        )
+        self.assertNumberMigrations(changes, 'testapp', 0)
+        self.assertNumberMigrations(changes, 'otherapp', 0)
+
     def test_rename_m2m_through_model(self):
         """
         Tests autodetection of renamed models that are used in M2M relations as