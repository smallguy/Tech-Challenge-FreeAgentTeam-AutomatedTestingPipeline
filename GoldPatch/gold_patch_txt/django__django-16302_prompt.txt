# 修复代码生成提示词（实例ID：django__django-16302）
## 代码仓库
django/django

## 原始问题描述
Cannot define CharField with unlimited length
Description
	
Model validation throws an error on CharField with a null max_length:
class Test(Model):
	char_field = CharField(max_length=None)
One or more models did not validate:
test.test: "char_field": CharFields require a "max_length" attribute that is a positive integer.
CharField should allow max_length=None, which intuitively means there is no maximum length. This is a perfectly valid use case. Postgres, for example, supports varchar/text columns without a length limit, but Django appears to have no way to define such a column in a model class.
The model validation code looks like this (​django/core/management/validation.py:40):
	if isinstance(f, models.CharField):
		try:
			max_length = int(f.max_length)
			if max_length <= 0:
				e.add(opts, '"%s": CharFields require a "max_length" attribute that is a positive integer.' % f.name)
		except (ValueError, TypeError):
			e.add(opts, '"%s": CharFields require a "max_length" attribute that is a positive integer.' % f.name)
It should be changed to something this:
	if isinstance(f, models.CharField) and f.max_length is not None:
		...
The FileField does not happen to throw this error because it is not a derivative of CharField. However, the SQL generated for FileField is not correct when max_length=None, so that would need to be addressed as well.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/admin_docs/test_views.py b/tests/admin_docs/test_views.py
--- a/tests/admin_docs/test_views.py
+++ b/tests/admin_docs/test_views.py
@@ -447,6 +447,16 @@ def test_builtin_fields(self):
             "Boolean (Either True or False)",
         )
 
+    def test_char_fields(self):
+        self.assertEqual(
+            views.get_readable_field_data_type(fields.CharField(max_length=255)),
+            "String (up to 255)",
+        )
+        self.assertEqual(
+            views.get_readable_field_data_type(fields.CharField()),
+            "String (unlimited)",
+        )
+
     def test_custom_fields(self):
         self.assertEqual(
             views.get_readable_field_data_type(CustomField()), "A custom field type"
diff --git a/tests/inspectdb/models.py b/tests/inspectdb/models.py
--- a/tests/inspectdb/models.py
+++ b/tests/inspectdb/models.py
@@ -106,6 +106,13 @@ class Meta:
         required_db_features = {"supports_collation_on_textfield"}
 
 
+class CharFieldUnlimited(models.Model):
+    char_field = models.CharField(max_length=None)
+
+    class Meta:
+        required_db_features = {"supports_unlimited_charfield"}
+
+
 class UniqueTogether(models.Model):
     field1 = models.IntegerField()
     field2 = models.CharField(max_length=10)
diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py
--- a/tests/inspectdb/tests.py
+++ b/tests/inspectdb/tests.py
@@ -184,6 +184,13 @@ def test_text_field_db_collation(self):
                 output,
             )
 
+    @skipUnlessDBFeature("supports_unlimited_charfield")
+    def test_char_field_unlimited(self):
+        out = StringIO()
+        call_command("inspectdb", "inspectdb_charfieldunlimited", stdout=out)
+        output = out.getvalue()
+        self.assertIn("char_field = models.CharField()", output)
+
     def test_number_field_types(self):
         """Test introspection of various Django field types"""
         assertFieldType = self.make_field_type_asserter()
diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py
--- a/tests/invalid_models_tests/test_ordinary_fields.py
+++ b/tests/invalid_models_tests/test_ordinary_fields.py
@@ -112,16 +112,18 @@ class Model(models.Model):
             field = models.CharField()
 
         field = Model._meta.get_field("field")
-        self.assertEqual(
-            field.check(),
-            [
+        expected = (
+            []
+            if connection.features.supports_unlimited_charfield
+            else [
                 Error(
                     "CharFields must define a 'max_length' attribute.",
                     obj=field,
                     id="fields.E120",
                 ),
-            ],
+            ]
         )
+        self.assertEqual(field.check(), expected)
 
     def test_negative_max_length(self):
         class Model(models.Model):
diff --git a/tests/postgres_tests/test_array.py b/tests/postgres_tests/test_array.py
--- a/tests/postgres_tests/test_array.py
+++ b/tests/postgres_tests/test_array.py
@@ -776,12 +776,12 @@ def test_exact_tags(self):
 class TestChecks(PostgreSQLSimpleTestCase):
     def test_field_checks(self):
         class MyModel(PostgreSQLModel):
-            field = ArrayField(models.CharField())
+            field = ArrayField(models.CharField(max_length=-1))
 
         model = MyModel()
         errors = model.check()
         self.assertEqual(len(errors), 1)
-        # The inner CharField is missing a max_length.
+        # The inner CharField has a non-positive max_length.
         self.assertEqual(errors[0].id, "postgres.E001")
         self.assertIn("max_length", errors[0].msg)
 
@@ -837,12 +837,12 @@ def test_nested_field_checks(self):
         """
 
         class MyModel(PostgreSQLModel):
-            field = ArrayField(ArrayField(models.CharField()))
+            field = ArrayField(ArrayField(models.CharField(max_length=-1)))
 
         model = MyModel()
         errors = model.check()
         self.assertEqual(len(errors), 1)
-        # The inner CharField is missing a max_length.
+        # The inner CharField has a non-positive max_length.
         self.assertEqual(errors[0].id, "postgres.E001")
         self.assertIn("max_length", errors[0].msg)