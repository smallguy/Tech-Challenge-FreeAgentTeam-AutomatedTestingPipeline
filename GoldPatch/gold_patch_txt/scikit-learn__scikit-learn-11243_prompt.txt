# 修复代码生成提示词（实例ID：scikit-learn__scikit-learn-11243）
## 代码仓库
scikit-learn/scikit-learn

## 原始问题描述
minmax_scale does not ignore NaNs
The class `MinMaxScaler` ignore NaNs. Its counterpart function does not.

The `check_array` needs to add the option `force_all_finite='allow-nan'`.
#11206 implement the tests and this fix. However, it should be done in another proper PR.


## 参考黄金补丁（正确的修复方案）
diff --git a/sklearn/preprocessing/tests/test_common.py b/sklearn/preprocessing/tests/test_common.py
--- a/sklearn/preprocessing/tests/test_common.py
+++ b/sklearn/preprocessing/tests/test_common.py
@@ -8,8 +8,11 @@
 
 from sklearn.base import clone
 
-from sklearn.preprocessing import QuantileTransformer
+from sklearn.preprocessing import minmax_scale
+from sklearn.preprocessing import quantile_transform
+
 from sklearn.preprocessing import MinMaxScaler
+from sklearn.preprocessing import QuantileTransformer
 
 from sklearn.utils.testing import assert_array_equal
 from sklearn.utils.testing import assert_allclose
@@ -23,11 +26,11 @@ def _get_valid_samples_by_column(X, col):
 
 
 @pytest.mark.parametrize(
-    "est, support_sparse",
-    [(MinMaxScaler(), False),
-     (QuantileTransformer(n_quantiles=10, random_state=42), True)]
+    "est, func, support_sparse",
+    [(MinMaxScaler(), minmax_scale, False),
+     (QuantileTransformer(n_quantiles=10), quantile_transform, True)]
 )
-def test_missing_value_handling(est, support_sparse):
+def test_missing_value_handling(est, func, support_sparse):
     # check that the preprocessing method let pass nan
     rng = np.random.RandomState(42)
     X = iris.data.copy()
@@ -45,6 +48,12 @@ def test_missing_value_handling(est, support_sparse):
     # missing values should still be missing, and only them
     assert_array_equal(np.isnan(Xt), np.isnan(X_test))
 
+    # check that the function leads to the same results as the class
+    Xt_class = est.transform(X_train)
+    Xt_func = func(X_train, **est.get_params())
+    assert_array_equal(np.isnan(Xt_func), np.isnan(Xt_class))
+    assert_allclose(Xt_func[~np.isnan(Xt_func)], Xt_class[~np.isnan(Xt_class)])
+
     # check that the inverse transform keep NaN
     Xt_inv = est.inverse_transform(Xt)
     assert_array_equal(np.isnan(Xt_inv), np.isnan(X_test))