# 修复代码生成提示词（实例ID：django__django-16143）
## 代码仓库
django/django

## 原始问题描述
TransactionManagmentError isn't helpful for tracking down cause
Description
	
The error: "TransactionManagementError: An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block." thrown from django/db/backends/init.py", line 372, in validate_no_broken_transaction doesn't provide enough information to help track down the problem.
The exception is thrown if self.needs_rollback is True, but the underlying reason that self.needs_rollback has been set True has been lost, since it could have happened a long time previously.
Transactions should keep track of why needs_rollback has been set, and use that to provide a more helpful error.
Background: I'm seeing this error being thrown when a task is run on a Celery queue, but not when run manually. Since it's via Celery, dropping into the debugger is impossible, and thus I'm back to trying to dump useful debug info.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/basic/tests.py b/tests/basic/tests.py
--- a/tests/basic/tests.py
+++ b/tests/basic/tests.py
@@ -805,8 +805,9 @@ def _update(self, *args, **kwargs):
                 "An error occurred in the current transaction. You can't "
                 "execute queries until the end of the 'atomic' block."
             )
-            with self.assertRaisesMessage(DatabaseError, msg):
+            with self.assertRaisesMessage(DatabaseError, msg) as cm:
                 asos.save(update_fields=["pub_date"])
+            self.assertIsInstance(cm.exception.__cause__, DatabaseError)
         finally:
             Article._base_manager._queryset_class = orig_class
 
diff --git a/tests/transactions/tests.py b/tests/transactions/tests.py
--- a/tests/transactions/tests.py
+++ b/tests/transactions/tests.py
@@ -339,8 +339,11 @@ def test_atomic_prevents_queries_in_broken_transaction(self):
                 "An error occurred in the current transaction. You can't "
                 "execute queries until the end of the 'atomic' block."
             )
-            with self.assertRaisesMessage(transaction.TransactionManagementError, msg):
+            with self.assertRaisesMessage(
+                transaction.TransactionManagementError, msg
+            ) as cm:
                 r2.save(force_update=True)
+        self.assertIsInstance(cm.exception.__cause__, IntegrityError)
         self.assertEqual(Reporter.objects.get(pk=r1.pk).last_name, "Haddock")
 
     @skipIfDBFeature("atomic_transactions")