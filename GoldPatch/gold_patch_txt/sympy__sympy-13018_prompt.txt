# 修复代码生成提示词（实例ID：sympy__sympy-13018）
## 代码仓库
sympy/sympy

## 原始问题描述
Wrong/surprising result from noncommutative Pow.subs
The following behavior in Sympy seems surprising:
```
>>> import sympy
>>> sympy.__version__
'1.1'
>>> x = sympy.Symbol('x', commutative=False)
>>> (x*x*x).subs({x*x: 1})   # !!!
1
```
I would have expected this produces `x`.

The issue appears to be that `Pow._eval_subs` uses fractional powers in the substitution. This then raises questions on what noncommutative symbols in Sympy actually mean mathematically. At least in my use cases for them, certainly `x**2 == 1` does not imply `x**3 == 1`.

I would suggest something like the following:
```
--- a/sympy/core/power.py
+++ b/sympy/core/power.py
@@ -591,6 +591,11 @@ def _check(ct1, ct2, old):
         if old == self.base:
             return new**self.exp._subs(old, new)

+        if not old.is_commutative:
+            # The logic here does not work for noncommutative objects.
+            # x*x == 1 should not imply x == 1.
+            return False, None
+
         # issue 10829: (4**x - 3*y + 2).subs(2**x, y) -> y**2 - 3*y + 2
         if old.func is self.func and self.exp == old.exp:
             l = log(self.base, old.base)
```


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py
--- a/sympy/core/tests/test_subs.py
+++ b/sympy/core/tests/test_subs.py
@@ -292,6 +292,8 @@ def test_subs_commutative():
 
 def test_subs_noncommutative():
     w, x, y, z, L = symbols('w x y z L', commutative=False)
+    alpha = symbols('alpha', commutative=True)
+    someint = symbols('someint', commutative=True, integer=True)
 
     assert (x*y).subs(x*y, L) == L
     assert (w*y*x).subs(x*y, L) == w*y*x
@@ -306,6 +308,61 @@ def test_subs_noncommutative():
     assert (w*x*y*z*x*y).subs(x*y*z, L) == w*L*x*y
     assert (w*x*y*y*w*x*x*y*x*y*y*x*y).subs(x*y, L) == w*L*y*w*x*L**2*y*L
 
+    # Check fractional power substitutions. It should not do
+    # substitutions that choose a value for noncommutative log,
+    # or inverses that don't already appear in the expressions.
+    assert (x*x*x).subs(x*x, L) == L*x
+    assert (x*x*x*y*x*x*x*x).subs(x*x, L) == L*x*y*L**2
+    for p in range(1, 5):
+        for k in range(10):
+            assert (y * x**k).subs(x**p, L) == y * L**(k//p) * x**(k % p)
+    assert (x**(3/2)).subs(x**(1/2), L) == x**(3/2)
+    assert (x**(1/2)).subs(x**(1/2), L) == L
+    assert (x**(-1/2)).subs(x**(1/2), L) == x**(-1/2)
+    assert (x**(-1/2)).subs(x**(-1/2), L) == L
+
+    assert (x**(2*someint)).subs(x**someint, L) == L**2
+    assert (x**(2*someint + 3)).subs(x**someint, L) == L**2*x**3
+    assert (x**(3*someint + 3)).subs(x**someint, L) == L**3*x**3
+    assert (x**(3*someint)).subs(x**(2*someint), L) == L * x**someint
+    assert (x**(4*someint)).subs(x**(2*someint), L) == L**2
+    assert (x**(4*someint + 1)).subs(x**(2*someint), L) == L**2 * x
+    assert (x**(4*someint)).subs(x**(3*someint), L) == L * x**someint
+    assert (x**(4*someint + 1)).subs(x**(3*someint), L) == L * x**(someint + 1)
+
+    assert (x**(2*alpha)).subs(x**alpha, L) == x**(2*alpha)
+    assert (x**(2*alpha + 2)).subs(x**2, L) == x**(2*alpha + 2)
+    assert ((2*z)**alpha).subs(z**alpha, y) == (2*z)**alpha
+    assert (x**(2*someint*alpha)).subs(x**someint, L) == x**(2*someint*alpha)
+    assert (x**(2*someint + alpha)).subs(x**someint, L) == x**(2*someint + alpha)
+
+    # This could in principle be substituted, but is not currently
+    # because it requires recognizing that someint**2 is divisible by
+    # someint.
+    assert (x**(someint**2 + 3)).subs(x**someint, L) == x**(someint**2 + 3)
+
+    # alpha**z := exp(log(alpha) z) is usually well-defined
+    assert (4**z).subs(2**z, y) == y**2
+
+    # Negative powers
+    assert (x**(-1)).subs(x**3, L) == x**(-1)
+    assert (x**(-2)).subs(x**3, L) == x**(-2)
+    assert (x**(-3)).subs(x**3, L) == L**(-1)
+    assert (x**(-4)).subs(x**3, L) == L**(-1) * x**(-1)
+    assert (x**(-5)).subs(x**3, L) == L**(-1) * x**(-2)
+
+    assert (x**(-1)).subs(x**(-3), L) == x**(-1)
+    assert (x**(-2)).subs(x**(-3), L) == x**(-2)
+    assert (x**(-3)).subs(x**(-3), L) == L
+    assert (x**(-4)).subs(x**(-3), L) == L * x**(-1)
+    assert (x**(-5)).subs(x**(-3), L) == L * x**(-2)
+
+    assert (x**1).subs(x**(-3), L) == x
+    assert (x**2).subs(x**(-3), L) == x**2
+    assert (x**3).subs(x**(-3), L) == L**(-1)
+    assert (x**4).subs(x**(-3), L) == L**(-1) * x
+    assert (x**5).subs(x**(-3), L) == L**(-1) * x**2
+
 
 def test_subs_basic_funcs():
     a, b, c, d, K = symbols('a b c d K', commutative=True)