# 修复代码生成提示词（实例ID：django__django-15108）
## 代码仓库
django/django

## 原始问题描述
Window(order_by) should allow usage of descending string syntax to be used
Description
	 
		(last modified by Simon Charette)
	 
The QuerySet.order_by and ​some aggregates ordering kwarg allows for the leading dash syntax to be used but Window.order_by doesn't as it solely wraps the provided order_by in ExpressionList(expressions=order_by).
This makes for an inconsistent API so I suggest we reuse the logic in OrderableAggMixin.__init__ in Window.__init__
As a related note it seems most of the logic of OrderableAggMixin could be simplified by using ExpressionList.
It's a shame that we used ordering and not order_by as a kwarg for OrderableAggMixin as it's now inconsistent. Also not sure how much of a public API the OrderBy expression is but I wish it was initially named Sort (or Ordering?) so that we could define
class OrderBy(ExpressionList):
	template = 'ORDER BY %(expressions)s'
	def __init__(self, *expressions, *extra):
		expressions = [
			(Sort(F(expr[1:]), descending=True) if isinstance(expr, str) and expr[0] == '-' else expr)
			for expr in expressions
		]
		super().__init__(*expressions, **extra)
And then simply use this abstraction in Window and Postgres orderable aggregates.
Assigning to myself as I plan to have a look at this in next few days.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/expressions_window/tests.py b/tests/expressions_window/tests.py
--- a/tests/expressions_window/tests.py
+++ b/tests/expressions_window/tests.py
@@ -51,6 +51,7 @@ def test_dense_rank(self):
         tests = [
             ExtractYear(F('hire_date')).asc(),
             F('hire_date__year').asc(),
+            'hire_date__year',
         ]
         for order_by in tests:
             with self.subTest(order_by=order_by):
@@ -473,7 +474,7 @@ def test_ntile(self):
         """
         qs = Employee.objects.annotate(ntile=Window(
             expression=Ntile(num_buckets=4),
-            order_by=F('salary').desc(),
+            order_by='-salary',
         )).order_by('ntile', '-salary', 'name')
         self.assertQuerysetEqual(qs, [
             ('Miller', 'Management', 100000, 1),
@@ -875,7 +876,7 @@ def test_window_repr(self):
         )
         self.assertEqual(
             repr(Window(expression=Avg('salary'), order_by=F('department').asc())),
-            '<Window: Avg(F(salary)) OVER (ORDER BY OrderBy(F(department), descending=False))>'
+            '<Window: Avg(F(salary)) OVER (OrderByList(OrderBy(F(department), descending=False)))>'
         )
 
     def test_window_frame_repr(self):
@@ -942,9 +943,12 @@ def test_conditional_annotation(self):
             qs.filter(equal=True)
 
     def test_invalid_order_by(self):
-        msg = 'order_by must be either an Expression or a sequence of expressions'
+        msg = (
+            'Window.order_by must be either a string reference to a field, an '
+            'expression, or a list or tuple of them.'
+        )
         with self.assertRaisesMessage(ValueError, msg):
-            Window(expression=Sum('power'), order_by='-horse')
+            Window(expression=Sum('power'), order_by={'-horse'})
 
     def test_invalid_source_expression(self):
         msg = "Expression 'Upper' isn't compatible with OVER clauses."