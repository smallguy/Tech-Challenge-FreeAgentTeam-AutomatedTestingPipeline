# 修复代码生成提示词（实例ID：django__django-11177）
## 代码仓库
django/django

## 原始问题描述
Django 2.2 autoreloader is failing intermittently (not using watchman)
Description
	
Since upgrading to Django 2.2 the autoreloader is working differently and is not always picking up changes to .py files to reload runserver. It seems to work consistently once on a file, but multiple changes to the same file will not necessarily trigger a reload. It's definitely a change in the behavior to previous versions of Django (up to 2.1.7)
I'm not using watchman.
I'm running runserver in a python 3.7 slim docker container like ./manage.py runserver 0.0.0.0:8001
As a workaround I have tried to add an edit a different .py -- that doesn't seem to help consistently. I've also noticed that the problem seems to sometimes go away by itself -- perhaps there is some change to the timing of the autoreloader which is not clear? For example and ignore interval of a certain duration.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py
--- a/tests/utils_tests/test_autoreload.py
+++ b/tests/utils_tests/test_autoreload.py
@@ -255,7 +255,7 @@ def test_starts_thread_with_args(self, mocked_check_errors, mocked_thread):
         self.assertEqual(mocked_thread.call_count, 1)
         self.assertEqual(
             mocked_thread.call_args[1],
-            {'target': fake_main_func, 'args': (123,), 'kwargs': {'abc': 123}}
+            {'target': fake_main_func, 'args': (123,), 'kwargs': {'abc': 123}, 'name': 'django-main-thread'}
         )
         self.assertSequenceEqual(fake_thread.setDaemon.call_args[0], [True])
         self.assertTrue(fake_thread.start.called)
@@ -376,26 +376,6 @@ def test_file(self, mocked_modules, notify_mock):
         self.assertEqual(notify_mock.call_count, 1)
         self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])
 
-    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
-    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
-    def test_nonexistent_file(self, mocked_modules, notify_mock):
-        self.reloader.watch_file(self.nonexistent_file)
-        with self.tick_twice():
-            self.ensure_file(self.nonexistent_file)
-        self.assertEqual(notify_mock.call_count, 1)
-        self.assertCountEqual(notify_mock.call_args[0], [self.nonexistent_file])
-
-    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
-    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
-    def test_nonexistent_file_in_non_existing_directory(self, mocked_modules, notify_mock):
-        non_existing_directory = self.tempdir / 'non_existing_dir'
-        nonexistent_file = non_existing_directory / 'test'
-        self.reloader.watch_file(nonexistent_file)
-        with self.tick_twice():
-            self.ensure_file(nonexistent_file)
-        self.assertEqual(notify_mock.call_count, 1)
-        self.assertCountEqual(notify_mock.call_args[0], [nonexistent_file])
-
     @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
     @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
     def test_glob(self, mocked_modules, notify_mock):
@@ -407,18 +387,6 @@ def test_glob(self, mocked_modules, notify_mock):
         self.assertEqual(notify_mock.call_count, 1)
         self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])
 
-    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
-    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
-    def test_glob_non_existing_directory(self, mocked_modules, notify_mock):
-        non_existing_directory = self.tempdir / 'does_not_exist'
-        nonexistent_file = non_existing_directory / 'test.py'
-        self.reloader.watch_dir(non_existing_directory, '*.py')
-        with self.tick_twice():
-            self.ensure_file(nonexistent_file)
-            self.set_mtime(nonexistent_file, time.time())
-        self.assertEqual(notify_mock.call_count, 1)
-        self.assertCountEqual(notify_mock.call_args[0], [nonexistent_file])
-
     @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
     @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
     def test_multiple_globs(self, mocked_modules, notify_mock):
@@ -669,28 +637,8 @@ def test_snapshot_files_updates(self):
             snapshot2 = dict(self.reloader.snapshot_files())
             self.assertNotEqual(snapshot1[self.existing_file], snapshot2[self.existing_file])
 
-    def test_does_not_fire_without_changes(self):
-        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]), \
-                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:
-            mtime = self.existing_file.stat().st_mtime
-            initial_snapshot = {self.existing_file: mtime}
-            second_snapshot = self.reloader.loop_files(initial_snapshot, time.time())
-            self.assertEqual(second_snapshot, {})
-            notifier.assert_not_called()
-
-    def test_fires_when_created(self):
-        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.nonexistent_file]), \
-                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:
-            self.nonexistent_file.touch()
-            mtime = self.nonexistent_file.stat().st_mtime
-            second_snapshot = self.reloader.loop_files({}, mtime - 1)
-            self.assertCountEqual(second_snapshot.keys(), [self.nonexistent_file])
-            notifier.assert_called_once_with(self.nonexistent_file)
-
-    def test_fires_with_changes(self):
-        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]), \
-                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:
-            initial_snapshot = {self.existing_file: 1}
-            second_snapshot = self.reloader.loop_files(initial_snapshot, time.time())
-            notifier.assert_called_once_with(self.existing_file)
-            self.assertCountEqual(second_snapshot.keys(), [self.existing_file])
+    def test_snapshot_files_with_duplicates(self):
+        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file, self.existing_file]):
+            snapshot = list(self.reloader.snapshot_files())
+            self.assertEqual(len(snapshot), 1)
+            self.assertEqual(snapshot[0][0], self.existing_file)