# 修复代码生成提示词（实例ID：django__django-10643）
## 代码仓库
django/django

## 原始问题描述
Allow icontains lookup to accept uuids with or without dashes
Description
	
We have Django 2.1 project with model admin which includes an UUIDField in list_display and search_fields. The UUID is displayed with dashes on changelist (e.g. "245ba2eb-6852-47be-82be-7dc07327cf9e") and if the user cut'n'paste it to the search field, I would expect admin to find it.
This works however only on Postgres but fails on Oracle. I can understand why this happens (Oracle backend stores uuid as string) and I believe I can workaround it by customizing get_search_results but I think should be internal thing that Django handles gracefully - search should be possible by the value as displayed in admin.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/model_fields/test_uuid.py b/tests/model_fields/test_uuid.py
--- a/tests/model_fields/test_uuid.py
+++ b/tests/model_fields/test_uuid.py
@@ -2,7 +2,9 @@
 import uuid
 
 from django.core import exceptions, serializers
-from django.db import IntegrityError, models
+from django.db import IntegrityError, connection, models
+from django.db.models import CharField, F, Value
+from django.db.models.functions import Concat, Repeat
 from django.test import (
     SimpleTestCase, TestCase, TransactionTestCase, skipUnlessDBFeature,
 )
@@ -90,11 +92,41 @@ def setUpTestData(cls):
             NullableUUIDModel.objects.create(field=None),
         ]
 
+    def assertSequenceEqualWithoutHyphens(self, qs, result):
+        """
+        Backends with a native datatype for UUID don't support fragment lookups
+        without hyphens because they store values with them.
+        """
+        self.assertSequenceEqual(
+            qs,
+            [] if connection.features.has_native_uuid_field else result,
+        )
+
     def test_exact(self):
         self.assertSequenceEqual(
             NullableUUIDModel.objects.filter(field__exact='550e8400e29b41d4a716446655440000'),
             [self.objs[1]]
         )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(
+                field__exact='550e8400-e29b-41d4-a716-446655440000'
+            ),
+            [self.objs[1]],
+        )
+
+    def test_iexact(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(
+                field__iexact='550E8400E29B41D4A716446655440000'
+            ),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(
+                field__iexact='550E8400-E29B-41D4-A716-446655440000'
+            ),
+            [self.objs[1]],
+        )
 
     def test_isnull(self):
         self.assertSequenceEqual(
@@ -102,6 +134,86 @@ def test_isnull(self):
             [self.objs[2]]
         )
 
+    def test_contains(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(field__contains='8400e29b'),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(field__contains='8400-e29b'),
+            [self.objs[1]],
+        )
+
+    def test_icontains(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(field__icontains='8400E29B'),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(field__icontains='8400-E29B'),
+            [self.objs[1]],
+        )
+
+    def test_startswith(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(field__startswith='550e8400e29b4'),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(field__startswith='550e8400-e29b-4'),
+            [self.objs[1]],
+        )
+
+    def test_istartswith(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(field__istartswith='550E8400E29B4'),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(field__istartswith='550E8400-E29B-4'),
+            [self.objs[1]],
+        )
+
+    def test_endswith(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(field__endswith='a716446655440000'),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(field__endswith='a716-446655440000'),
+            [self.objs[1]],
+        )
+
+    def test_iendswith(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.filter(field__iendswith='A716446655440000'),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.filter(field__iendswith='A716-446655440000'),
+            [self.objs[1]],
+        )
+
+    def test_filter_with_expr(self):
+        self.assertSequenceEqualWithoutHyphens(
+            NullableUUIDModel.objects.annotate(
+                value=Concat(Value('8400'), Value('e29b'), output_field=CharField()),
+            ).filter(field__contains=F('value')),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.annotate(
+                value=Concat(Value('8400'), Value('-'), Value('e29b'), output_field=CharField()),
+            ).filter(field__contains=F('value')),
+            [self.objs[1]],
+        )
+        self.assertSequenceEqual(
+            NullableUUIDModel.objects.annotate(
+                value=Repeat(Value('0'), 4, output_field=CharField()),
+            ).filter(field__contains=F('value')),
+            [self.objs[1]],
+        )
+
 
 class TestSerialization(SimpleTestCase):
     test_data = (