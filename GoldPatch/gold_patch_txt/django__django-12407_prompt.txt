# 修复代码生成提示词（实例ID：django__django-12407）
## 代码仓库
django/django

## 原始问题描述
{% include %} uses get_template where it could select_template
Description
	
It'd be nice if the Include template tag was sensible enough to allow fallbacks by selecting the most appropriate template, as things like render/render_to_response/render_to_string do. It's tripped me up on more than one occasion, and it seems a trivial feature to support, from my limited testing.
>>> from django.template import Template, Context
>>> tmpl = Template('{% include var %}')
>>> ctx = Context({'var':'admin/base.html'})
>>> ctx
[{'var': 'admin/base.html'}]
>>> tmpl.render(ctx)
... some HTML output ...
>>> ctx.update({'var':['admin/base.html', 'admin/fail.html']})
{'var': ['admin/base.html', 'admin/fail.html']}
>>> tmpl.render(ctx)
Traceback (most recent call last):
 File "<console>", line 1, in <module>
 File "/path/django/template/base.py", line 140, in render
	return self._render(context)
 File "/path/django/template/base.py", line 134, in _render
	return self.nodelist.render(context)
 File "/path/django/template/base.py", line 823, in render
	bit = self.render_node(node, context)
 File "/path/django/template/debug.py", line 74, in render_node
	return node.render(context)
 File "/path/django/template/loader_tags.py", line 165, in render
	template = get_template(template_name)
 File "/path/django/template/loader.py", line 145, in get_template
	template, origin = find_template(template_name)
 File "/path/django/template/loader.py", line 138, in find_template
	raise TemplateDoesNotExist(name)
TemplateDoesNotExist: ['admin/base.html', 'admin/fail.html']
The 'fix' is to change ​this line from get_template to select_template, though this might now be slightly complicated by the recent changes in 5cdacbda034af928f5033c9afc7b50ee0b13f75c to allow for rendering of Template instances.
Changing to select_template on 1.4 yields the results I'd expect:
>>> from django.template import Template, Context 
>>> tmpl = Template('{% include var %}')
>>> ctx = Context({'var':['admin/base.html', 'admin/fail.html']})
>>> tmpl.render(ctx)
... some HTML output ...
Both the above shell sessions assume django.contrib.admin is in INSTALLED_APPS.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/template_tests/syntax_tests/test_include.py b/tests/template_tests/syntax_tests/test_include.py
--- a/tests/template_tests/syntax_tests/test_include.py
+++ b/tests/template_tests/syntax_tests/test_include.py
@@ -243,6 +243,26 @@ def test_include_template_argument(self):
         output = outer_tmpl.render(ctx)
         self.assertEqual(output, 'This worked!')
 
+    def test_include_template_iterable(self):
+        engine = Engine.get_default()
+        outer_temp = engine.from_string('{% include var %}')
+        tests = [
+            ('admin/fail.html', 'index.html'),
+            ['admin/fail.html', 'index.html'],
+        ]
+        for template_names in tests:
+            with self.subTest(template_names):
+                output = outer_temp.render(Context({'var': template_names}))
+                self.assertEqual(output, 'index\n')
+
+    def test_include_template_none(self):
+        engine = Engine.get_default()
+        outer_temp = engine.from_string('{% include var %}')
+        ctx = Context({'var': None})
+        msg = 'No template names provided'
+        with self.assertRaisesMessage(TemplateDoesNotExist, msg):
+            outer_temp.render(ctx)
+
     def test_include_from_loader_get_template(self):
         tmpl = loader.get_template('include_tpl.html')  # {% include tmpl %}
         output = tmpl.render({'tmpl': loader.get_template('index.html')})