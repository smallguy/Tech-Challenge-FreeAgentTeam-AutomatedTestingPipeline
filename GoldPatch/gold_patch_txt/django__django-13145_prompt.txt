# 修复代码生成提示词（实例ID：django__django-13145）
## 代码仓库
django/django

## 原始问题描述
timesince 'depth' parameter
Description
	 
		(last modified by Toby Such)
	 
Discussed ​here. The timesince function is a bit limiting as it is right now. A depth parameter should be added to configure how many values are shown. The depth parameter should be defaulted to 2 as this is how the current implementation behaves. The existing rule of values having to be adjacent to one another should still remain.
The logic for calculating the time since, before formatting should also be pulled out of the function and placed in its own so that custom implementations can be created.
For example: 
With a depth of one it should always display as "1 week" or "3 years" etc. 
With a depth of two: "1 week, 3 days" or "3 years, 7 months"
With a depth of three: "1 week, 3 days, 5 hours" or "3 years, 7 months, 2 weeks"


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/utils_tests/test_timesince.py b/tests/utils_tests/test_timesince.py
--- a/tests/utils_tests/test_timesince.py
+++ b/tests/utils_tests/test_timesince.py
@@ -1,13 +1,13 @@
 import datetime
-import unittest
 
+from django.test import TestCase
 from django.test.utils import requires_tz_support
 from django.utils import timezone, translation
 from django.utils.timesince import timesince, timeuntil
 from django.utils.translation import npgettext_lazy
 
 
-class TimesinceTests(unittest.TestCase):
+class TimesinceTests(TestCase):
 
     def setUp(self):
         self.t = datetime.datetime(2007, 8, 14, 13, 46, 0)
@@ -140,3 +140,31 @@ def test_thousand_years_ago(self):
         t = datetime.datetime(1007, 8, 14, 13, 46, 0)
         self.assertEqual(timesince(t, self.t), '1000\xa0years')
         self.assertEqual(timeuntil(self.t, t), '1000\xa0years')
+
+    def test_depth(self):
+        t = self.t + self.oneyear + self.onemonth + self.oneweek + self.oneday + self.onehour
+        tests = [
+            (t, 1, '1\xa0year'),
+            (t, 2, '1\xa0year, 1\xa0month'),
+            (t, 3, '1\xa0year, 1\xa0month, 1\xa0week'),
+            (t, 4, '1\xa0year, 1\xa0month, 1\xa0week, 1\xa0day'),
+            (t, 5, '1\xa0year, 1\xa0month, 1\xa0week, 1\xa0day, 1\xa0hour'),
+            (t, 6, '1\xa0year, 1\xa0month, 1\xa0week, 1\xa0day, 1\xa0hour'),
+            (self.t + self.onehour, 5, '1\xa0hour'),
+            (self.t + (4 * self.oneminute), 3, '4\xa0minutes'),
+            (self.t + self.onehour + self.oneminute, 1, '1\xa0hour'),
+            (self.t + self.oneday + self.onehour, 1, '1\xa0day'),
+            (self.t + self.oneweek + self.oneday, 1, '1\xa0week'),
+            (self.t + self.onemonth + self.oneweek, 1, '1\xa0month'),
+            (self.t + self.oneyear + self.onemonth, 1, '1\xa0year'),
+            (self.t + self.oneyear + self.oneweek + self.oneday, 3, '1\xa0year'),
+        ]
+        for value, depth, expected in tests:
+            with self.subTest():
+                self.assertEqual(timesince(self.t, value, depth=depth), expected)
+                self.assertEqual(timeuntil(value, self.t, depth=depth), expected)
+
+    def test_depth_invalid(self):
+        msg = 'depth must be greater than 0.'
+        with self.assertRaisesMessage(ValueError, msg):
+            timesince(self.t, self.t, depth=0)