# 修复代码生成提示词（实例ID：django__django-14309）
## 代码仓库
django/django

## 原始问题描述
Combining an empty Q with a negated Exists un-negates the Exists lookup
Description
	
The following test case fails in Django 3.2 and main:
class TestEmptyQExistsCombination(TestCase):
	def test_combine(self):
		q = Q() & Exists(Book.objects.all())
		self.assertFalse(q.negated) # passes
	def test_combine_negated(self):
		q = Q() & ~Exists(Book.objects.all())
		self.assertTrue(q.negated) # fails
I noticed this issue trying to work around issue #32651/ #32548.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py
--- a/tests/queries/test_q.py
+++ b/tests/queries/test_q.py
@@ -1,4 +1,5 @@
-from django.db.models import Exists, F, OuterRef, Q
+from django.db.models import BooleanField, Exists, F, OuterRef, Q
+from django.db.models.expressions import RawSQL
 from django.test import SimpleTestCase
 
 from .models import Tag
@@ -26,6 +27,19 @@ def test_combine_or_empty(self):
         self.assertEqual(q | Q(), q)
         self.assertEqual(Q() | q, q)
 
+    def test_combine_empty_copy(self):
+        base_q = Q(x=1)
+        tests = [
+            base_q | Q(),
+            Q() | base_q,
+            base_q & Q(),
+            Q() & base_q,
+        ]
+        for i, q in enumerate(tests):
+            with self.subTest(i=i):
+                self.assertEqual(q, base_q)
+                self.assertIsNot(q, base_q)
+
     def test_combine_or_both_empty(self):
         self.assertEqual(Q() | Q(), Q())
 
@@ -37,6 +51,16 @@ def test_combine_not_q_object(self):
         with self.assertRaisesMessage(TypeError, str(obj)):
             q & obj
 
+    def test_combine_negated_boolean_expression(self):
+        tagged = Tag.objects.filter(category=OuterRef('pk'))
+        tests = [
+            Q() & ~Exists(tagged),
+            Q() | ~Exists(tagged),
+        ]
+        for q in tests:
+            with self.subTest(q=q):
+                self.assertIs(q.negated, True)
+
     def test_deconstruct(self):
         q = Q(price__gt=F('discounted_price'))
         path, args, kwargs = q.deconstruct()
@@ -88,10 +112,10 @@ def test_deconstruct_nested(self):
         self.assertEqual(kwargs, {})
 
     def test_deconstruct_boolean_expression(self):
-        tagged = Tag.objects.filter(category=OuterRef('pk'))
-        q = Q(Exists(tagged))
+        expr = RawSQL('1 = 1', BooleanField())
+        q = Q(expr)
         _, args, kwargs = q.deconstruct()
-        self.assertEqual(args, (Exists(tagged),))
+        self.assertEqual(args, (expr,))
         self.assertEqual(kwargs, {})
 
     def test_reconstruct(self):
diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py
--- a/tests/queries/test_query.py
+++ b/tests/queries/test_query.py
@@ -150,31 +150,3 @@ def test_filter_non_conditional(self):
         msg = 'Cannot filter against a non-conditional expression.'
         with self.assertRaisesMessage(TypeError, msg):
             query.build_where(Func(output_field=CharField()))
-
-    def test_equality(self):
-        self.assertNotEqual(
-            Author.objects.all().query,
-            Author.objects.filter(item__name='foo').query,
-        )
-        self.assertEqual(
-            Author.objects.filter(item__name='foo').query,
-            Author.objects.filter(item__name='foo').query,
-        )
-        self.assertEqual(
-            Author.objects.filter(item__name='foo').query,
-            Author.objects.filter(Q(item__name='foo')).query,
-        )
-
-    def test_hash(self):
-        self.assertNotEqual(
-            hash(Author.objects.all().query),
-            hash(Author.objects.filter(item__name='foo').query)
-        )
-        self.assertEqual(
-            hash(Author.objects.filter(item__name='foo').query),
-            hash(Author.objects.filter(item__name='foo').query),
-        )
-        self.assertEqual(
-            hash(Author.objects.filter(item__name='foo').query),
-            hash(Author.objects.filter(Q(item__name='foo')).query),
-        )