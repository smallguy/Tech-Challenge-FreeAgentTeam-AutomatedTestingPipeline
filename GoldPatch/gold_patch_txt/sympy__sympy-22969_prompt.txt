# 修复代码生成提示词（实例ID：sympy__sympy-22969）
## 代码仓库
sympy/sympy

## 原始问题描述
Gaussian Optics / Refractive index not considered
Dear sympy maintainers,

please correct me, if I am wrong, but I fear that the beam waist in 

class sympy.physics.optics.gaussopt.BeamParameter

is not correctly computed.

From the source:

def w_0(self):
        """
        The beam waist (minimal radius).

        See Also
        ========

        w : the beam radius at `1/e^2` intensity

        Examples
        ========

        >>> from sympy.physics.optics import BeamParameter
        >>> p = BeamParameter(530e-9, 1, w=1e-3)
        >>> p.w_0
        0.00100000000000000
        """
        return sqrt(self.z_r/pi*self.wavelen)

After  transmission through a surface with the refractive index changing, the Rayleigh length z_r would change, while wavelength stays the same. According to this implementation, w_0 changes, which is not physical.

If I might help to solve this, I would be happy to contribute. 
However, I have not a very good understanding of sympy, and this code is interfaced of course with sympy.

Best regards,
Lukas
Gaussian Optics / Refractive index not considered
Dear sympy maintainers,

please correct me, if I am wrong, but I fear that the beam waist in 

class sympy.physics.optics.gaussopt.BeamParameter

is not correctly computed.

From the source:

def w_0(self):
        """
        The beam waist (minimal radius).

        See Also
        ========

        w : the beam radius at `1/e^2` intensity

        Examples
        ========

        >>> from sympy.physics.optics import BeamParameter
        >>> p = BeamParameter(530e-9, 1, w=1e-3)
        >>> p.w_0
        0.00100000000000000
        """
        return sqrt(self.z_r/pi*self.wavelen)

After  transmission through a surface with the refractive index changing, the Rayleigh length z_r would change, while wavelength stays the same. According to this implementation, w_0 changes, which is not physical.

If I might help to solve this, I would be happy to contribute. 
However, I have not a very good understanding of sympy, and this code is interfaced of course with sympy.

Best regards,
Lukas


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_args.py b/sympy/core/tests/test_args.py
--- a/sympy/core/tests/test_args.py
+++ b/sympy/core/tests/test_args.py
@@ -4912,7 +4912,7 @@ def test_sympy__physics__optics__waves__TWave():
 
 def test_sympy__physics__optics__gaussopt__BeamParameter():
     from sympy.physics.optics import BeamParameter
-    assert _test_args(BeamParameter(530e-9, 1, w=1e-3))
+    assert _test_args(BeamParameter(530e-9, 1, w=1e-3, n=1))
 
 
 def test_sympy__physics__optics__medium__Medium():
diff --git a/sympy/physics/optics/tests/test_gaussopt.py b/sympy/physics/optics/tests/test_gaussopt.py
--- a/sympy/physics/optics/tests/test_gaussopt.py
+++ b/sympy/physics/optics/tests/test_gaussopt.py
@@ -87,11 +87,16 @@ def test_gauss_opt():
         w_i**2/w_o**2 - sqrt(w_i**2/w_o**2 - pi**2*w_i**4/(f**2*l**2)))/w_i**2
     assert conjugate_gauss_beams(l, w_i, w_o, f=f)[2] == f
 
-    z, l, w = symbols('z l r', positive=True)
-    p = BeamParameter(l, z, w=w)
-    assert p.radius == z*(pi**2*w**4/(l**2*z**2) + 1)
-    assert p.w == w*sqrt(l**2*z**2/(pi**2*w**4) + 1)
-    assert p.w_0 == w
-    assert p.divergence == l/(pi*w)
-    assert p.gouy == atan2(z, pi*w**2/l)
+    z, l, w_0 = symbols('z l w_0', positive=True)
+    p = BeamParameter(l, z, w=w_0)
+    assert p.radius == z*(pi**2*w_0**4/(l**2*z**2) + 1)
+    assert p.w == w_0*sqrt(l**2*z**2/(pi**2*w_0**4) + 1)
+    assert p.w_0 == w_0
+    assert p.divergence == l/(pi*w_0)
+    assert p.gouy == atan2(z, pi*w_0**2/l)
     assert p.waist_approximation_limit == 2*l/pi
+
+    p = BeamParameter(530e-9, 1, w=1e-3, n=2)
+    assert streq(p.q, 1 + 3.77358490566038*I*pi)
+    assert streq(N(p.z_r), Float(11.8550666173200))
+    assert streq(N(p.w_0), Float(0.00100000000000000))