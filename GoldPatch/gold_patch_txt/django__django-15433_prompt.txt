# 修复代码生成提示词（实例ID：django__django-15433）
## 代码仓库
django/django

## 原始问题描述
ManyToManyField to lowercased swappable setting causes generating infinite migrations.
Description
	
If I create a custom user model that extends AbstractUser and then try to add a ManyToManyField that references this custom User model, django keeps making the same AlterField migration over and over again unnecessarily. I've attached a Git repository that I used to reproduce this issue with very simple code. You can see the two erroneous migrations after the initial migration. If I use the built in user, there is no issue. It seems to appear once I extend AbstractUser.
Git repository: ​https://github.com/SentientClee/django-bug-reproduction
Here is the accounts app model.py code.
from django.conf import settings
from django.contrib.auth.models import AbstractUser
from django.db import models
class User(AbstractUser):
	pass
class Test(models.Model):
	members = models.ManyToManyField(settings.AUTH_USER_MODEL)
Here is one of the erroneous migrations. Notice it depends on 0002_alter_test_members which is an erroneous migrations file that looks just like this one.
# Generated by Django 4.0.2 on 2022-02-15 01:33
from django.conf import settings
from django.db import migrations, models
class Migration(migrations.Migration):
	dependencies = [
		('accounts', '0002_alter_test_members'),
	]
	operations = [
		migrations.AlterField(
			model_name='test',
			name='members',
			field=models.ManyToManyField(to=settings.AUTH_USER_MODEL),
		),
	]


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/field_deconstruction/tests.py b/tests/field_deconstruction/tests.py
--- a/tests/field_deconstruction/tests.py
+++ b/tests/field_deconstruction/tests.py
@@ -475,34 +475,34 @@ def test_many_to_many_field(self):
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission"})
+        self.assertEqual(kwargs, {"to": "auth.permission"})
         self.assertFalse(hasattr(kwargs["to"], "setting_name"))
         # Test swappable
         field = models.ManyToManyField("auth.User")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.User"})
+        self.assertEqual(kwargs, {"to": "auth.user"})
         self.assertEqual(kwargs["to"].setting_name, "AUTH_USER_MODEL")
         # Test through
         field = models.ManyToManyField("auth.Permission", through="auth.Group")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "through": "auth.Group"})
+        self.assertEqual(kwargs, {"to": "auth.permission", "through": "auth.Group"})
         # Test custom db_table
         field = models.ManyToManyField("auth.Permission", db_table="custom_table")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission", "db_table": "custom_table"})
+        self.assertEqual(kwargs, {"to": "auth.permission", "db_table": "custom_table"})
         # Test related_name
         field = models.ManyToManyField("auth.Permission", related_name="custom_table")
         name, path, args, kwargs = field.deconstruct()
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
         self.assertEqual(
-            kwargs, {"to": "auth.Permission", "related_name": "custom_table"}
+            kwargs, {"to": "auth.permission", "related_name": "custom_table"}
         )
         # Test related_query_name
         field = models.ManyToManyField("auth.Permission", related_query_name="foobar")
@@ -510,7 +510,7 @@ def test_many_to_many_field(self):
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
         self.assertEqual(
-            kwargs, {"to": "auth.Permission", "related_query_name": "foobar"}
+            kwargs, {"to": "auth.permission", "related_query_name": "foobar"}
         )
         # Test limit_choices_to
         field = models.ManyToManyField(
@@ -520,7 +520,7 @@ def test_many_to_many_field(self):
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
         self.assertEqual(
-            kwargs, {"to": "auth.Permission", "limit_choices_to": {"foo": "bar"}}
+            kwargs, {"to": "auth.permission", "limit_choices_to": {"foo": "bar"}}
         )
 
     @override_settings(AUTH_USER_MODEL="auth.Permission")
@@ -533,7 +533,7 @@ def test_many_to_many_field_swapped(self):
 
         self.assertEqual(path, "django.db.models.ManyToManyField")
         self.assertEqual(args, [])
-        self.assertEqual(kwargs, {"to": "auth.Permission"})
+        self.assertEqual(kwargs, {"to": "auth.permission"})
         self.assertEqual(kwargs["to"].setting_name, "AUTH_USER_MODEL")
 
     def test_many_to_many_field_related_name(self):
@@ -551,7 +551,7 @@ class MyModel(models.Model):
         self.assertEqual(args, [])
         # deconstruct() should not include attributes which were not passed to
         # the field during initialization.
-        self.assertEqual(kwargs, {"to": "field_deconstruction.MyModel"})
+        self.assertEqual(kwargs, {"to": "field_deconstruction.mymodel"})
         # Passed attributes.
         name, path, args, kwargs = MyModel.m2m_related_name.field.deconstruct()
         self.assertEqual(path, "django.db.models.ManyToManyField")
@@ -559,7 +559,7 @@ class MyModel(models.Model):
         self.assertEqual(
             kwargs,
             {
-                "to": "field_deconstruction.MyModel",
+                "to": "field_deconstruction.mymodel",
                 "related_query_name": "custom_query_name",
                 "limit_choices_to": {"flag": True},
             },
diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py
--- a/tests/migrations/test_autodetector.py
+++ b/tests/migrations/test_autodetector.py
@@ -3279,6 +3279,31 @@ def test_swappable_lowercase(self):
             [("__setting__", "AUTH_USER_MODEL")],
         )
 
+    @override_settings(AUTH_USER_MODEL="thirdapp.CustomUser")
+    def test_swappable_many_to_many_model_case(self):
+        document_lowercase = ModelState(
+            "testapp",
+            "Document",
+            [
+                ("id", models.AutoField(primary_key=True)),
+                ("owners", models.ManyToManyField(settings.AUTH_USER_MODEL.lower())),
+            ],
+        )
+        document = ModelState(
+            "testapp",
+            "Document",
+            [
+                ("id", models.AutoField(primary_key=True)),
+                ("owners", models.ManyToManyField(settings.AUTH_USER_MODEL)),
+            ],
+        )
+        with isolate_lru_cache(apps.get_swappable_settings_name):
+            changes = self.get_changes(
+                [self.custom_user, document_lowercase],
+                [self.custom_user, document],
+            )
+        self.assertEqual(len(changes), 0)
+
     def test_swappable_changed(self):
         with isolate_lru_cache(apps.get_swappable_settings_name):
             before = self.make_project_state([self.custom_user, self.author_with_user])