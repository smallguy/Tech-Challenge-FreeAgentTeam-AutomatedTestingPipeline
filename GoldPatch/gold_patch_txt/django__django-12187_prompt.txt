# 修复代码生成提示词（实例ID：django__django-12187）
## 代码仓库
django/django

## 原始问题描述
Allow configuration of where to save staticfiles manifest.
Description
	
A standard Django deploy has all staticfiles accessible to all users. This is understandable, if undesirable. By itself this is not a huge problem since those on the public Internet don't know the filenames of all of the files a deployment has, and fuskering the entire possible namespace isn't feasible and is also detectable.
However, deployments that make use of ManifestStaticFilesStorage will most likely expose a master list of all static files to anyone who wants to look. It's not a huge security risk because you shouldn't be depending on security through obscurity, but there's certainly a leg up given when there's a master list of all files. Due to the way ManifestStaticFilesStorage is setup, the manifest ends up in the directory of publicly served files. If the files are stored locally this can be fixed by blacklisting the file from webserver access and only letting Django itself read the file off the local filesystem. This is the approach I've taken once I discovered the issue - I have a server deployment running Apache serving files on the local filesystem, but have CloudFront in front of that which fetches from Apache if the cache misses. I've since blacklisted the staticfiles manifest and invalidated any cached copies in CloudFront.
Here's what I consider the risks of having a publicly exposed staticfiles manifest:
Easily find trade secrets in JavaScript files meant to be used only internally by staff users
Find hardcoded secrets in internal files - anything in the static tree gets listed here, even pre-processed files like coffee or less if the developers use django-compressor
Find potential attack vectors by finding normally unlisted files that are exploitable which could be used to form URLs in phishing emails
Possible novel way to fingerprint Django versions using the easy master list of files, could be used to quickly identify potentially vulnerable Django servers
All that said, I don't have a great solution to the problem that Django itself could implement. Currently Django writes the manifest to the staticfiles root so it's always going to be readable unless you take extra steps. The real stickler is deployments that use something like ​S3BotoStorage which in effect needs Django to be able to access the manifest remotely. My understanding of that setup (I don't use it) would be that on load Django is going to read the manifest from S3, so it needs to be accessible over the web by default. Further steps could be taken to make it only accessible to Django itself, but that requires user action.
Potential solutions:
Encrypt the manifest on disk, decrypt on load into memory - loses human readability for debugging purposes but hides it from prying eyes by default
Fast-track ticket #26029 to make staticfiles storage configuration allow passing options to storage - use options to change manifest path somewhere non-public or configure a secret header to use with S3 to only give Django access to the file.
On a related note, this discovery has made me extra paranoid about the exposure of internal files meant for staff only and now I'm looking at a way to formalize restricted access to the files. With the exposure of the staticfiles manifest it's clear much of the business logic we use (in JavaScript under admin) is by default visible to the Web if you know the URL.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py
--- a/tests/staticfiles_tests/test_storage.py
+++ b/tests/staticfiles_tests/test_storage.py
@@ -1,3 +1,4 @@
+import json
 import os
 import shutil
 import sys
@@ -13,7 +14,7 @@
     Command as CollectstaticCommand,
 )
 from django.core.management import call_command
-from django.test import override_settings
+from django.test import SimpleTestCase, override_settings
 
 from .cases import CollectionTestCase
 from .settings import TEST_ROOT
@@ -499,6 +500,55 @@ def test_template_tag_simple_content(self):
             self.assertIn(b"other.deploy12345.css", content)
 
 
+class CustomManifestStorage(storage.ManifestStaticFilesStorage):
+    def __init__(self, *args, manifest_storage=None, **kwargs):
+        manifest_storage = storage.StaticFilesStorage(
+            location=kwargs.pop('manifest_location'),
+        )
+        super().__init__(*args, manifest_storage=manifest_storage, **kwargs)
+
+
+class TestCustomManifestStorage(SimpleTestCase):
+    def setUp(self):
+        self.manifest_path = Path(tempfile.mkdtemp())
+        self.addCleanup(shutil.rmtree, self.manifest_path)
+
+        self.staticfiles_storage = CustomManifestStorage(
+            manifest_location=self.manifest_path,
+        )
+        self.manifest_file = self.manifest_path / self.staticfiles_storage.manifest_name
+        # Manifest without paths.
+        self.manifest = {'version': self.staticfiles_storage.manifest_version}
+        with self.manifest_file.open('w') as manifest_file:
+            json.dump(self.manifest, manifest_file)
+
+    def test_read_manifest(self):
+        self.assertEqual(
+            self.staticfiles_storage.read_manifest(),
+            json.dumps(self.manifest),
+        )
+
+    def test_read_manifest_nonexistent(self):
+        os.remove(self.manifest_file)
+        self.assertIsNone(self.staticfiles_storage.read_manifest())
+
+    def test_save_manifest_override(self):
+        self.assertIs(self.manifest_file.exists(), True)
+        self.staticfiles_storage.save_manifest()
+        self.assertIs(self.manifest_file.exists(), True)
+        new_manifest = json.loads(self.staticfiles_storage.read_manifest())
+        self.assertIn('paths', new_manifest)
+        self.assertNotEqual(new_manifest, self.manifest)
+
+    def test_save_manifest_create(self):
+        os.remove(self.manifest_file)
+        self.staticfiles_storage.save_manifest()
+        self.assertIs(self.manifest_file.exists(), True)
+        new_manifest = json.loads(self.staticfiles_storage.read_manifest())
+        self.assertIn('paths', new_manifest)
+        self.assertNotEqual(new_manifest, self.manifest)
+
+
 class CustomStaticFilesStorage(storage.StaticFilesStorage):
     """
     Used in TestStaticFilePermissions