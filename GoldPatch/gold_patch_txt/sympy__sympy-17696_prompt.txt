# 修复代码生成提示词（实例ID：sympy__sympy-17696）
## 代码仓库
sympy/sympy

## 原始问题描述
Refine with sign
Consider the following code:
```
from sympy import *
x = Symbol('x', real = True)

expr = sign(x)
expr2 = refine(expr, Q.positive(x))
expr3 = refine(expr, Q.positive(x) & Q.nonzero(x))
expr4 = refine(expr, Q.positive(x + 1))
```
All the returned expression are `sign(x)`. However, at least for `expr3` and `expr4`, the results should be `1`. This probably is due to the lack of capabilities for `refine`. A PR similar to #17019 should fix this behaviour. 

Related issues: #8326 and #17052.


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py
--- a/sympy/assumptions/tests/test_refine.py
+++ b/sympy/assumptions/tests/test_refine.py
@@ -1,8 +1,10 @@
 from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,
-                   atan, atan2, nan, Symbol, re, im)
+                   atan, atan2, nan, Symbol, re, im, sign)
 from sympy.abc import w, x, y, z
 from sympy.core.relational import Eq, Ne
 from sympy.functions.elementary.piecewise import Piecewise
+from sympy.utilities.pytest import slow
+from sympy.core import S
 
 
 def test_Abs():
@@ -170,6 +172,23 @@ def test_complex():
         & Q.real(z)) == w*z + x*y
 
 
+def test_sign():
+    x = Symbol('x', real = True)
+    assert refine(sign(x), Q.positive(x)) == 1
+    assert refine(sign(x), Q.negative(x)) == -1
+    assert refine(sign(x), Q.zero(x)) == 0
+    assert refine(sign(x), True) == sign(x)
+    assert refine(sign(Abs(x)), Q.nonzero(x)) == 1
+
+    x = Symbol('x', imaginary=True)
+    assert refine(sign(x), Q.positive(im(x))) == S.ImaginaryUnit
+    assert refine(sign(x), Q.negative(im(x))) == -S.ImaginaryUnit
+    assert refine(sign(x), True) == sign(x)
+
+    x = Symbol('x', complex=True)
+    assert refine(sign(x), Q.zero(x)) == 0
+
+
 def test_func_args():
     class MyClass(Expr):
         # A class with nontrivial .func