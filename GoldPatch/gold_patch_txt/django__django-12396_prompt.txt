# 修复代码生成提示词（实例ID：django__django-12396）
## 代码仓库
django/django

## 原始问题描述
Omits test_ prefix from database name when running subset of tests
Description
	 
		(last modified by Matthijs Kooijman)
	 
While debugging some test framework issues wrt mysql, I noticed a problem where the test runner would try to access the test database without prefixing test_, leading to an access denied error (because my permissions are set up tightly).
What I suspect happens is that this subset of tests only uses the default database, so only that one is set up by DisoveryRunner.setup_databases. This is confirmed by using a debugger, which shows ​databases only contains 'default'. Then, it runs the check management command, which looks at settings.DATABASES, which still contains the settings for default and other. This in turn causes a connection to the other database to be made, but since the name of that database is not modified by ​create_test_db, that still refers to the original name, and the connection fails.
To reproduce, I have a clean master (c33eb6dcd0c211f8f02b2976fe3b3463f0a54498), with the following tests/test_mysql.py:
DATABASES = {																										 
	'default': {																										
		'ENGINE': 'django.db.backends.mysql',																		 
		'HOST': 'localhost',																							
		'USER': 'test_django',																						 
		'PASSWORD': 'XXX',																				 
		# Django prepends test_ to this name...																		 
		'NAME': 'django_main',																						 
	},																												 
	'other': {																										 
		'ENGINE': 'django.db.backends.mysql',																		 
		'HOST': 'localhost',																							
		'USER': 'test_django',																						 
		'PASSWORD': 'XXX',																				 
		# Django prepends test_ to this name...																		 
		'NAME': 'django_other',																						 
	}																												 
}																													 
																														
SECRET_KEY = "django_tests_secret_key"																				 
																														
# Use a fast hasher to speed up tests.																				 
PASSWORD_HASHERS = [																									
	'django.contrib.auth.hashers.MD5PasswordHasher',																	
]
Then inside tests, I run:
 ./runtests.py --settings test_mysql --parallel 1 timezones 
I think the --parallel 1 is not strictly needed, but might make things easier to debug. With the above, I get:
Creating test database for alias 'default'...
Destroying test database for alias 'default'...
Testing against Django installed in '/home/matthijs/docs/src/upstream/django/django'
Traceback (most recent call last):
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 220, in ensure_connection
	self.connect()
 File "/home/matthijs/docs/src/upstream/django/django/utils/asyncio.py", line 24, in inner
	return func(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 197, in connect
	self.connection = self.get_new_connection(conn_params)
 File "/home/matthijs/docs/src/upstream/django/django/utils/asyncio.py", line 24, in inner
	return func(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/mysql/base.py", line 233, in get_new_connection
	return Database.connect(**conn_params)
 File "/home/matthijs/docs/src/upstream/django/venv/lib/python3.7/site-packages/MySQLdb/__init__.py", line 84, in Connect
	return Connection(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/venv/lib/python3.7/site-packages/MySQLdb/connections.py", line 179, in __init__
	super(Connection, self).__init__(*args, **kwargs2)
MySQLdb._exceptions.OperationalError: (1044, "Access denied for user 'test_django'@'localhost' to database 'django_other'")
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
 File "./runtests.py", line 566, in <module>
	options.start_at, options.start_after, options.pdb,
 File "./runtests.py", line 308, in django_tests
	extra_tests=extra_tests,
 File "/home/matthijs/docs/src/upstream/django/django/test/runner.py", line 687, in run_tests
	self.run_checks()
 File "/home/matthijs/docs/src/upstream/django/django/test/runner.py", line 625, in run_checks
	call_command('check', verbosity=self.verbosity)
 File "/home/matthijs/docs/src/upstream/django/django/core/management/__init__.py", line 168, in call_command
	return command.execute(*args, **defaults)
 File "/home/matthijs/docs/src/upstream/django/django/core/management/base.py", line 369, in execute
	output = self.handle(*args, **options)
 File "/home/matthijs/docs/src/upstream/django/django/core/management/commands/check.py", line 64, in handle
	fail_level=getattr(checks, options['fail_level']),
 File "/home/matthijs/docs/src/upstream/django/django/core/management/base.py", line 395, in check
	include_deployment_checks=include_deployment_checks,
 File "/home/matthijs/docs/src/upstream/django/django/core/management/base.py", line 382, in _run_checks
	return checks.run_checks(**kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/core/checks/registry.py", line 72, in run_checks
	new_errors = check(app_configs=app_configs)
 File "/home/matthijs/docs/src/upstream/django/django/core/checks/model_checks.py", line 34, in check_all_models
	errors.extend(model.check(**kwargs))
 File "/home/matthijs/docs/src/upstream/django/django/db/models/base.py", line 1276, in check
	*cls._check_constraints(),
 File "/home/matthijs/docs/src/upstream/django/django/db/models/base.py", line 1842, in _check_constraints
	connection.features.supports_table_check_constraints or
 File "/home/matthijs/docs/src/upstream/django/django/utils/functional.py", line 48, in __get__
	res = instance.__dict__[self.name] = self.func(instance)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/mysql/features.py", line 97, in supports_column_check_constraints
	if self.connection.mysql_is_mariadb:
 File "/home/matthijs/docs/src/upstream/django/django/utils/functional.py", line 48, in __get__
	res = instance.__dict__[self.name] = self.func(instance)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/mysql/base.py", line 364, in mysql_is_mariadb
	return 'mariadb' in self.mysql_server_info.lower()
 File "/home/matthijs/docs/src/upstream/django/django/utils/functional.py", line 48, in __get__
	res = instance.__dict__[self.name] = self.func(instance)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/mysql/base.py", line 351, in mysql_server_info
	with self.temporary_connection() as cursor:
 File "/usr/lib/python3.7/contextlib.py", line 112, in __enter__
	return next(self.gen)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 604, in temporary_connection
	with self.cursor() as cursor:
 File "/home/matthijs/docs/src/upstream/django/django/utils/asyncio.py", line 24, in inner
	return func(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 260, in cursor
	return self._cursor()
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 236, in _cursor
	self.ensure_connection()
 File "/home/matthijs/docs/src/upstream/django/django/utils/asyncio.py", line 24, in inner
	return func(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 220, in ensure_connection
	self.connect()
 File "/home/matthijs/docs/src/upstream/django/django/db/utils.py", line 90, in __exit__
	raise dj_exc_value.with_traceback(traceback) from exc_value
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 220, in ensure_connection
	self.connect()
 File "/home/matthijs/docs/src/upstream/django/django/utils/asyncio.py", line 24, in inner
	return func(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/base/base.py", line 197, in connect
	self.connection = self.get_new_connection(conn_params)
 File "/home/matthijs/docs/src/upstream/django/django/utils/asyncio.py", line 24, in inner
	return func(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/django/db/backends/mysql/base.py", line 233, in get_new_connection
	return Database.connect(**conn_params)
 File "/home/matthijs/docs/src/upstream/django/venv/lib/python3.7/site-packages/MySQLdb/__init__.py", line 84, in Connect
	return Connection(*args, **kwargs)
 File "/home/matthijs/docs/src/upstream/django/venv/lib/python3.7/site-packages/MySQLdb/connections.py", line 179, in __init__
	super(Connection, self).__init__(*args, **kwargs2)
django.db.utils.OperationalError: (1044, "Access denied for user 'test_django'@'localhost' to database 'django_other'")
I am not quite familiar with this code, and this is already a distraction from a distraction from a distraction from the actual project I was working on, so I'm going to leave this here for others to fix :-)


## 参考黄金补丁（正确的修复方案）
diff --git a/django/test/runner.py b/django/test/runner.py
--- a/django/test/runner.py
+++ b/django/test/runner.py
@@ -630,10 +630,10 @@ def get_test_runner_kwargs(self):
             'buffer': self.buffer,
         }
 
-    def run_checks(self):
+    def run_checks(self, databases):
         # Checks are run after database creation since some checks require
         # database access.
-        call_command('check', verbosity=self.verbosity)
+        call_command('check', verbosity=self.verbosity, databases=databases)
 
     def run_suite(self, suite, **kwargs):
         kwargs = self.get_test_runner_kwargs()
@@ -695,7 +695,7 @@ def run_tests(self, test_labels, extra_tests=None, **kwargs):
         old_config = self.setup_databases(aliases=databases)
         run_failed = False
         try:
-            self.run_checks()
+            self.run_checks(databases)
             result = self.run_suite(suite)
         except Exception:
             run_failed = True
diff --git a/tests/check_framework/test_database.py b/tests/check_framework/test_database.py
--- a/tests/check_framework/test_database.py
+++ b/tests/check_framework/test_database.py
@@ -1,8 +1,7 @@
 import unittest
 from unittest import mock
 
-from django.core.checks import Tags, run_checks
-from django.core.checks.registry import CheckRegistry
+from django.core.checks.database import check_database_backends
 from django.db import connection
 from django.test import TestCase
 
@@ -10,30 +9,12 @@
 class DatabaseCheckTests(TestCase):
     databases = {'default', 'other'}
 
-    @property
-    def func(self):
-        from django.core.checks.database import check_database_backends
-        return check_database_backends
-
-    def test_database_checks_not_run_by_default(self):
-        """
-        `database` checks are only run when their tag is specified.
-        """
-        def f1(**kwargs):
-            return [5]
-
-        registry = CheckRegistry()
-        registry.register(Tags.database)(f1)
-        errors = registry.run_checks()
-        self.assertEqual(errors, [])
-
-        errors2 = registry.run_checks(tags=[Tags.database])
-        self.assertEqual(errors2, [5])
-
-    def test_database_checks_called(self):
-        with mock.patch('django.db.backends.base.validation.BaseDatabaseValidation.check') as mocked_check:
-            run_checks(tags=[Tags.database])
-            self.assertTrue(mocked_check.called)
+    @mock.patch('django.db.backends.base.validation.BaseDatabaseValidation.check')
+    def test_database_checks_called(self, mocked_check):
+        check_database_backends()
+        self.assertFalse(mocked_check.called)
+        check_database_backends(databases=self.databases)
+        self.assertTrue(mocked_check.called)
 
     @unittest.skipUnless(connection.vendor == 'mysql', 'Test only for MySQL')
     def test_mysql_strict_mode(self):
@@ -47,7 +28,7 @@ def test_mysql_strict_mode(self):
                 'django.db.backends.utils.CursorWrapper.fetchone', create=True,
                 return_value=(response,)
             ):
-                self.assertEqual(self.func(None), [])
+                self.assertEqual(check_database_backends(databases=self.databases), [])
 
         bad_sql_modes = ['', 'WHATEVER']
         for response in bad_sql_modes:
@@ -56,6 +37,6 @@ def test_mysql_strict_mode(self):
                 return_value=(response,)
             ):
                 # One warning for each database alias
-                result = self.func(None)
+                result = check_database_backends(databases=self.databases)
                 self.assertEqual(len(result), 2)
                 self.assertEqual([r.id for r in result], ['mysql.W002', 'mysql.W002'])
diff --git a/tests/check_framework/tests.py b/tests/check_framework/tests.py
--- a/tests/check_framework/tests.py
+++ b/tests/check_framework/tests.py
@@ -160,22 +160,22 @@ def tearDown(self):
     @override_system_checks([simple_system_check, tagged_system_check])
     def test_simple_call(self):
         call_command('check')
-        self.assertEqual(simple_system_check.kwargs, {'app_configs': None})
-        self.assertEqual(tagged_system_check.kwargs, {'app_configs': None})
+        self.assertEqual(simple_system_check.kwargs, {'app_configs': None, 'databases': None})
+        self.assertEqual(tagged_system_check.kwargs, {'app_configs': None, 'databases': None})
 
     @override_system_checks([simple_system_check, tagged_system_check])
     def test_given_app(self):
         call_command('check', 'auth', 'admin')
         auth_config = apps.get_app_config('auth')
         admin_config = apps.get_app_config('admin')
-        self.assertEqual(simple_system_check.kwargs, {'app_configs': [auth_config, admin_config]})
-        self.assertEqual(tagged_system_check.kwargs, {'app_configs': [auth_config, admin_config]})
+        self.assertEqual(simple_system_check.kwargs, {'app_configs': [auth_config, admin_config], 'databases': None})
+        self.assertEqual(tagged_system_check.kwargs, {'app_configs': [auth_config, admin_config], 'databases': None})
 
     @override_system_checks([simple_system_check, tagged_system_check])
     def test_given_tag(self):
         call_command('check', tags=['simpletag'])
         self.assertIsNone(simple_system_check.kwargs)
-        self.assertEqual(tagged_system_check.kwargs, {'app_configs': None})
+        self.assertEqual(tagged_system_check.kwargs, {'app_configs': None, 'databases': None})
 
     @override_system_checks([simple_system_check, tagged_system_check])
     def test_invalid_tag(self):
diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py
--- a/tests/invalid_models_tests/test_models.py
+++ b/tests/invalid_models_tests/test_models.py
@@ -6,7 +6,7 @@
 from django.db import connection, connections, models
 from django.db.models.functions import Lower
 from django.db.models.signals import post_init
-from django.test import SimpleTestCase
+from django.test import SimpleTestCase, TestCase
 from django.test.utils import isolate_apps, override_settings, register_lookup
 
 
@@ -1212,7 +1212,7 @@ def dummy_function(*args, **kwargs):
 
 
 @isolate_apps('invalid_models_tests')
-class ConstraintsTests(SimpleTestCase):
+class ConstraintsTests(TestCase):
     def test_check_constraints(self):
         class Model(models.Model):
             age = models.IntegerField()
@@ -1220,7 +1220,7 @@ class Model(models.Model):
             class Meta:
                 constraints = [models.CheckConstraint(check=models.Q(age__gte=18), name='is_adult')]
 
-        errors = Model.check()
+        errors = Model.check(databases=self.databases)
         warn = Warning(
             '%s does not support check constraints.' % connection.display_name,
             hint=(
@@ -1230,7 +1230,7 @@ class Meta:
             obj=Model,
             id='models.W027',
         )
-        expected = [] if connection.features.supports_table_check_constraints else [warn, warn]
+        expected = [] if connection.features.supports_table_check_constraints else [warn]
         self.assertCountEqual(errors, expected)
 
     def test_check_constraints_required_db_features(self):