# 修复代码生成提示词（实例ID：sympy__sympy-12144）
## 代码仓库
sympy/sympy

## 原始问题描述
Dummy fails when is re-evaluated in S and srepr
Hi all!

Well, i found this little problem, Dummy is a nice function but in the way is implemented exist this:
```
>>> alpha = Dummy("alpha")
>>> i = Integral(1/sqrt(1 - sin(alpha)**2), (alpha, 0, pi/2))
>>> N(i)
0.e+2
>>> i = S(srepr(i))
>>> N(i)
Integral(1/sqrt(-sin(_alpha)**2 + 1), (_alpha, 0, pi/2))
```
Basically, if you works with Dummy, and you get the expression with srepr or similar, when you eval it every Dummy will be interpreted as a new Dummy, so it fails, in the example you can see we can't eval the second expression because the 2 Dummy expression are interpreted as differents, other ex:
```
>>> m=Dummy("m")
>>> a=Matrix([m, m])
>>> a[0]==a[1]
True
>>> b=S(srepr(a))
>>> b[0]==b[1]
False
```

So thinking a solution can be use a hash or similar function, like:
```
>>> m=Dummy("m")
>>> srepr(m)
"Dummy('m', hash=987654321)"
>>> m=Dummy("m")
>>> srepr(m)
"Dummy('m', hash=754619474)"
```
Always will exist the hash collision, but at least to cover all possible can be sympy check the existents Dummy expressions and check the hash never by equal to other, the probability of the hash collision, to be equal, in the same context, with the same name, and in the same expression, i think is very low.

Maybe instead use a hash can be a random expression, with chars like ```8waerfn23jb89a```, that can help to avoid hash collision.

Thx. Cya. 


## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py
--- a/sympy/core/tests/test_symbol.py
+++ b/sympy/core/tests/test_symbol.py
@@ -30,10 +30,18 @@ def test_Symbol():
 
 def test_Dummy():
     assert Dummy() != Dummy()
-    Dummy._count = 0
-    d1 = Dummy()
-    Dummy._count = 0
-    assert d1 == Dummy()
+
+
+def test_Dummy_force_dummy_index():
+    raises(AssertionError, lambda: Dummy(dummy_index=1))
+    assert Dummy('d', dummy_index=2) == Dummy('d', dummy_index=2)
+    assert Dummy('d1', dummy_index=2) != Dummy('d2', dummy_index=2)
+    d1 = Dummy('d', dummy_index=3)
+    d2 = Dummy('d')
+    # not only unlikely, in fact impossible (b/c we keep a list of dummy_index)
+    assert d1 != d2
+    d3 = Dummy('d', dummy_index=3)
+    assert d1 == d3
 
 
 def test_as_dummy():
diff --git a/sympy/printing/tests/test_repr.py b/sympy/printing/tests/test_repr.py
--- a/sympy/printing/tests/test_repr.py
+++ b/sympy/printing/tests/test_repr.py
@@ -137,16 +137,25 @@ def test_Wild():
 
 
 def test_Dummy():
-    # cannot use sT here
+    d = Dummy('d')
+    sT(d, "Dummy('d', dummy_index=%s)" % str(d.dummy_index))
+
+
+def test_Dummy_assumption():
     d = Dummy('d', nonzero=True)
-    assert srepr(d) == "Dummy('d', nonzero=True)"
+    assert d == eval(srepr(d))
+    s1 = "Dummy('d', dummy_index=%s, nonzero=True)" % str(d.dummy_index)
+    s2 = "Dummy('d', nonzero=True, dummy_index=%s)" % str(d.dummy_index)
+    assert srepr(d) in (s1, s2)
 
 
 def test_Dummy_from_Symbol():
     # should not get the full dictionary of assumptions
     n = Symbol('n', integer=True)
     d = n.as_dummy()
-    assert srepr(d) == "Dummy('n', integer=True)"
+    s1 = "Dummy('n', dummy_index=%s, integer=True)" % str(d.dummy_index)
+    s2 = "Dummy('n', integer=True, dummy_index=%s)" % str(d.dummy_index)
+    assert srepr(d) in (s1, s2)
 
 
 def test_tuple():