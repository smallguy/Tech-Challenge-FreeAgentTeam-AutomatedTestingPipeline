# 修复代码生成提示词（实例ID：django__django-12477）
## 代码仓库
django/django

## 原始问题描述
fields.E310-E311 should take into account UniqueConstraints without conditions.
Description
	
Hello, 
I'm trying to create migration with this kind of model.
class AppUsers(models.Model):
	name = models.CharField(...)
	uid = models.CharField(...)
	source = models.ForeignKey(...)
	class Meta:
		constraints = [models.UniqueConstraint(fields=['uid', 'source'], name='appusers_uniqueness')]
When I start makemigrations command in manage.py I've faced fields.E310 ​https://docs.djangoproject.com/en/2.2/ref/checks/#related-fields error 
It says that I should add unique_together field in Meta options:
app_name.AppUsers.field: (fields.E310) No subset of the fields 'uid', 'source' on model 'AppUsers' is unique.
HINT: Add unique=True on any of those fields or add at least a subset of them to a unique_together constraint.
If I change Meta options to unique_together constraint migration passes with no errors.
class AppUsers(models.Model):
	name = models.CharField(...)
	uid = models.CharField(...)
	source = models.ForeignKey(...)
	class Meta:
		unique_together = [['uid', 'source']]
As mentioned in docs ​https://docs.djangoproject.com/en/2.2/ref/models/options/#unique-together unique_together may be deprecated in the future. So I think nobody wants to face this issue when this will be deprecated :) 
Thanks,
Pavel


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py
--- a/tests/invalid_models_tests/test_relative_fields.py
+++ b/tests/invalid_models_tests/test_relative_fields.py
@@ -352,7 +352,11 @@ class Model(models.Model):
         field = Model._meta.get_field('foreign_key')
         self.assertEqual(field.check(), [
             Error(
-                "'Target.bad' must set unique=True because it is referenced by a foreign key.",
+                "'Target.bad' must be unique because it is referenced by a foreign key.",
+                hint=(
+                    'Add unique=True to this field or add a UniqueConstraint '
+                    '(without condition) in the model Meta.constraints.'
+                ),
                 obj=field,
                 id='fields.E311',
             ),
@@ -368,12 +372,64 @@ class Model(models.Model):
         field = Model._meta.get_field('field')
         self.assertEqual(field.check(), [
             Error(
-                "'Target.bad' must set unique=True because it is referenced by a foreign key.",
+                "'Target.bad' must be unique because it is referenced by a foreign key.",
+                hint=(
+                    'Add unique=True to this field or add a UniqueConstraint '
+                    '(without condition) in the model Meta.constraints.'
+                ),
                 obj=field,
                 id='fields.E311',
             ),
         ])
 
+    def test_foreign_key_to_partially_unique_field(self):
+        class Target(models.Model):
+            source = models.IntegerField()
+
+            class Meta:
+                constraints = [
+                    models.UniqueConstraint(
+                        fields=['source'],
+                        name='tfktpuf_partial_unique',
+                        condition=models.Q(pk__gt=2),
+                    ),
+                ]
+
+        class Model(models.Model):
+            field = models.ForeignKey(Target, models.CASCADE, to_field='source')
+
+        field = Model._meta.get_field('field')
+        self.assertEqual(field.check(), [
+            Error(
+                "'Target.source' must be unique because it is referenced by a "
+                "foreign key.",
+                hint=(
+                    'Add unique=True to this field or add a UniqueConstraint '
+                    '(without condition) in the model Meta.constraints.'
+                ),
+                obj=field,
+                id='fields.E311',
+            ),
+        ])
+
+    def test_foreign_key_to_unique_field_with_meta_constraint(self):
+        class Target(models.Model):
+            source = models.IntegerField()
+
+            class Meta:
+                constraints = [
+                    models.UniqueConstraint(
+                        fields=['source'],
+                        name='tfktufwmc_unique',
+                    ),
+                ]
+
+        class Model(models.Model):
+            field = models.ForeignKey(Target, models.CASCADE, to_field='source')
+
+        field = Model._meta.get_field('field')
+        self.assertEqual(field.check(), [])
+
     def test_foreign_object_to_non_unique_fields(self):
         class Person(models.Model):
             # Note that both fields are not unique.
@@ -396,14 +452,82 @@ class MMembership(models.Model):
             Error(
                 "No subset of the fields 'country_id', 'city_id' on model 'Person' is unique.",
                 hint=(
-                    "Add unique=True on any of those fields or add at least "
-                    "a subset of them to a unique_together constraint."
+                    'Mark a single field as unique=True or add a set of '
+                    'fields to a unique constraint (via unique_together or a '
+                    'UniqueConstraint (without condition) in the model '
+                    'Meta.constraints).'
                 ),
                 obj=field,
                 id='fields.E310',
             )
         ])
 
+    def test_foreign_object_to_partially_unique_field(self):
+        class Person(models.Model):
+            country_id = models.IntegerField()
+            city_id = models.IntegerField()
+
+            class Meta:
+                constraints = [
+                    models.UniqueConstraint(
+                        fields=['country_id', 'city_id'],
+                        name='tfotpuf_partial_unique',
+                        condition=models.Q(pk__gt=2),
+                    ),
+                ]
+
+        class MMembership(models.Model):
+            person_country_id = models.IntegerField()
+            person_city_id = models.IntegerField()
+            person = models.ForeignObject(
+                Person,
+                on_delete=models.CASCADE,
+                from_fields=['person_country_id', 'person_city_id'],
+                to_fields=['country_id', 'city_id'],
+            )
+
+        field = MMembership._meta.get_field('person')
+        self.assertEqual(field.check(), [
+            Error(
+                "No subset of the fields 'country_id', 'city_id' on model "
+                "'Person' is unique.",
+                hint=(
+                    'Mark a single field as unique=True or add a set of '
+                    'fields to a unique constraint (via unique_together or a '
+                    'UniqueConstraint (without condition) in the model '
+                    'Meta.constraints).'
+                ),
+                obj=field,
+                id='fields.E310',
+            ),
+        ])
+
+    def test_foreign_object_to_unique_field_with_meta_constraint(self):
+        class Person(models.Model):
+            country_id = models.IntegerField()
+            city_id = models.IntegerField()
+
+            class Meta:
+                constraints = [
+                    models.UniqueConstraint(
+                        fields=['country_id', 'city_id'],
+                        name='tfotpuf_unique',
+                    ),
+                ]
+
+        class MMembership(models.Model):
+            person_country_id = models.IntegerField()
+            person_city_id = models.IntegerField()
+            person = models.ForeignObject(
+                Person,
+                on_delete=models.CASCADE,
+                from_fields=['person_country_id', 'person_city_id'],
+                to_fields=['country_id', 'city_id'],
+            )
+
+        field = MMembership._meta.get_field('person')
+        self.assertEqual(field.check(), [])
+
     def test_on_delete_set_null_on_non_nullable_field(self):
         class Person(models.Model):
             pass
@@ -1453,8 +1577,10 @@ class Child(models.Model):
             Error(
                 "No subset of the fields 'a', 'b' on model 'Parent' is unique.",
                 hint=(
-                    "Add unique=True on any of those fields or add at least "
-                    "a subset of them to a unique_together constraint."
+                    'Mark a single field as unique=True or add a set of '
+                    'fields to a unique constraint (via unique_together or a '
+                    'UniqueConstraint (without condition) in the model '
+                    'Meta.constraints).'
                 ),
                 obj=field,
                 id='fields.E310',
@@ -1489,8 +1615,10 @@ class Child(models.Model):
             Error(
                 "No subset of the fields 'a', 'b', 'd' on model 'Parent' is unique.",
                 hint=(
-                    "Add unique=True on any of those fields or add at least "
-                    "a subset of them to a unique_together constraint."
+                    'Mark a single field as unique=True or add a set of '
+                    'fields to a unique constraint (via unique_together or a '
+                    'UniqueConstraint (without condition) in the model '
+                    'Meta.constraints).'
                 ),
                 obj=field,
                 id='fields.E310',