# 修复代码生成提示词（实例ID：scikit-learn__scikit-learn-13549）
## 代码仓库
scikit-learn/scikit-learn

## 原始问题描述
Stratified subsampler utility?
I have some data `X` and `y` that I want to subsample (i.e. only keep a subset of the samples) in a stratified way.


Using something like 

```py
_, X_sub, _, y_sub = train_test_split(
    X, y, stratify=stratify, train_size=None, test_size=n_samples_sub)
```

is almost what I need. But that will error if:

- I happen to want exactly `X.shape[0]` samples (`ValueError: test_size=60 should be either positive and smaller than the number of samples`)
- I want something close to `X.shape[0]` which is not enough to have a stratified test or train set (`ValueError: The train_size = 1 should be greater or equal to the number of classes = 2`)

----

~~Would it make sense to add a `subsample()` util?
Another option would be to add a `bypass_checks` to `train_test_split`~~

Basically what I need is a `stratify` option to `utils.resample`, that's probably the most appropriate place to introduce this.


## 参考黄金补丁（正确的修复方案）
diff --git a/sklearn/utils/tests/test_utils.py b/sklearn/utils/tests/test_utils.py
--- a/sklearn/utils/tests/test_utils.py
+++ b/sklearn/utils/tests/test_utils.py
@@ -93,6 +93,67 @@ def test_resample():
     assert_equal(len(resample([1, 2], n_samples=5)), 5)
 
 
+def test_resample_stratified():
+    # Make sure resample can stratify
+    rng = np.random.RandomState(0)
+    n_samples = 100
+    p = .9
+    X = rng.normal(size=(n_samples, 1))
+    y = rng.binomial(1, p, size=n_samples)
+
+    _, y_not_stratified = resample(X, y, n_samples=10, random_state=0,
+                                   stratify=None)
+    assert np.all(y_not_stratified == 1)
+
+    _, y_stratified = resample(X, y, n_samples=10, random_state=0, stratify=y)
+    assert not np.all(y_stratified == 1)
+    assert np.sum(y_stratified) == 9  # all 1s, one 0
+
+
+def test_resample_stratified_replace():
+    # Make sure stratified resampling supports the replace parameter
+    rng = np.random.RandomState(0)
+    n_samples = 100
+    X = rng.normal(size=(n_samples, 1))
+    y = rng.randint(0, 2, size=n_samples)
+
+    X_replace, _ = resample(X, y, replace=True, n_samples=50,
+                            random_state=rng, stratify=y)
+    X_no_replace, _ = resample(X, y, replace=False, n_samples=50,
+                               random_state=rng, stratify=y)
+    assert np.unique(X_replace).shape[0] < 50
+    assert np.unique(X_no_replace).shape[0] == 50
+
+    # make sure n_samples can be greater than X.shape[0] if we sample with
+    # replacement
+    X_replace, _ = resample(X, y, replace=True, n_samples=1000,
+                            random_state=rng, stratify=y)
+    assert X_replace.shape[0] == 1000
+    assert np.unique(X_replace).shape[0] == 100
+
+
+def test_resample_stratify_2dy():
+    # Make sure y can be 2d when stratifying
+    rng = np.random.RandomState(0)
+    n_samples = 100
+    X = rng.normal(size=(n_samples, 1))
+    y = rng.randint(0, 2, size=(n_samples, 2))
+    X, y = resample(X, y, n_samples=50, random_state=rng, stratify=y)
+    assert y.ndim == 2
+
+
+def test_resample_stratify_sparse_error():
+    # resample must be ndarray
+    rng = np.random.RandomState(0)
+    n_samples = 100
+    X = rng.normal(size=(n_samples, 2))
+    y = rng.randint(0, 2, size=n_samples)
+    stratify = sp.csr_matrix(y)
+    with pytest.raises(TypeError, match='A sparse matrix was passed'):
+        X, y = resample(X, y, n_samples=50, random_state=rng,
+                        stratify=stratify)
+
+
 def test_safe_mask():
     random_state = check_random_state(0)
     X = random_state.rand(5, 4)