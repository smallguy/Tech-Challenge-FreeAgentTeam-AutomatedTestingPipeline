# 修复代码生成提示词（实例ID：django__django-13585）
## 代码仓库
django/django

## 原始问题描述
Password reset token incompatibility.
Description
	
As noted here ​https://docs.djangoproject.com/en/3.1/releases/3.1/#django-contrib-auth the hashing for password reset tokens has changed between 3.0 and 3.1 and work has been done to ensure existing tokens will still work (at least until 4.0).
However the encoding of the token creation time has also changed. Specifically from days since 1/1/01 to seconds since 1/1/01. And it appears no work has been done to support tokens with the older values. So a token generated on Oct 1, 2020 will come through as 7213 days which will then get interpreted as 7213 seconds, aka 2am Jan 1, 2001.
So while exiting tokens in the wild will pass crypto validation they will all show as expired if your PASSWORD_RESET_TIMEOUT is less than ~20 years.
The code base I'm working on uses these tokens (perhaps unwisely) in some email links that are expected to have a 3 month lifetime and an upgrade from 3.0 to 3.1 looks likely to render all the tokens in the wild expired which is suboptimal.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py
--- a/tests/auth_tests/test_tokens.py
+++ b/tests/auth_tests/test_tokens.py
@@ -1,4 +1,4 @@
-from datetime import datetime, timedelta
+from datetime import date, datetime, timedelta
 
 from django.conf import settings
 from django.contrib.auth.models import User
@@ -86,6 +86,27 @@ def test_timeout(self):
             )
             self.assertIs(p4.check_token(user, tk1), False)
 
+    def test_legacy_days_timeout(self):
+        # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.
+        class LegacyPasswordResetTokenGenerator(MockedPasswordResetTokenGenerator):
+            """Pre-Django 3.1 tokens generator."""
+            def _num_seconds(self, dt):
+                # Pre-Django 3.1 tokens use days instead of seconds.
+                return (dt.date() - date(2001, 1, 1)).days
+
+        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')
+        now = datetime.now()
+        p0 = LegacyPasswordResetTokenGenerator(now)
+        tk1 = p0.make_token(user)
+        p1 = MockedPasswordResetTokenGenerator(
+            now + timedelta(seconds=settings.PASSWORD_RESET_TIMEOUT),
+        )
+        self.assertIs(p1.check_token(user, tk1), True)
+        p2 = MockedPasswordResetTokenGenerator(
+            now + timedelta(seconds=(settings.PASSWORD_RESET_TIMEOUT + 24 * 60 * 60)),
+        )
+        self.assertIs(p2.check_token(user, tk1), False)
+
     def test_check_token_with_nonexistent_token_and_user(self):
         user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')
         p0 = PasswordResetTokenGenerator()