# 修复代码生成提示词（实例ID：sympy__sympy-16088）
## 代码仓库
sympy/sympy

## 原始问题描述
Using Simplify in Integral will pull out the constant term
<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write "Fixes #NNNN" in that exact
format, e.g. "Fixes #1234". See
https://github.com/blog/1506-closing-issues-via-pull-requests . Please also
write a comment on that issue linking back to this pull request once it is
open. -->
Fixes##15965

#### Brief description of what is fixed or changed
Using simplify in `Sum `pulls out the constant term(independent term) outside the summation but this property is not present in `Integral` 
Example-
```
>>> Sum(x*y, (x, 1, n)).simplify()
    n    
   __    
   \ `   
y*  )   x
   /_,   
  x = 1  
>>> Integral(x*y, (x, 1, n)).simplify()
  n       
  /       
 |        
 |  x*y dx
 |        
/         
1
```
Now it is working -
```
In [4]: (Integral(x*y-z,x)).simplify()                                              
Out[4]: 
  ⌠          ⌠     
y⋅⎮ x dx - z⋅⎮ 1 dx
  ⌡          ⌡     

In [5]:  Integral(x*y, (x, 1, n)).simplify()                                        
Out[5]: 
  n     
  ⌠     
y⋅⎮ x dx
  ⌡     
  1   

```
#### Other comments
previous issue about this -#7971
and they talked about `doit`  by using simplify .
I don't have any idea about adding `doit`method in simplify.
#### Release Notes

<!-- Write the release notes for this release below. See
https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more `inIntegeralformation`
on how to write release notes. The bot will check your release notes
automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
- simplify
  -  simplify now pulls independent factors out of integrals
<!-- END RELEASE NOTES -->



## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/core/tests/test_exprtools.py b/sympy/core/tests/test_exprtools.py
--- a/sympy/core/tests/test_exprtools.py
+++ b/sympy/core/tests/test_exprtools.py
@@ -288,10 +288,11 @@ def test_factor_terms():
     assert factor_terms(e, sign=False) == e
     assert factor_terms(exp(-4*x - 2) - x) == -x + exp(Mul(-2, 2*x + 1, evaluate=False))
 
-    # sum tests
-    assert factor_terms(Sum(x, (y, 1, 10))) == x * Sum(1, (y, 1, 10))
-    assert factor_terms(Sum(x, (y, 1, 10)) + x) == x * (1 + Sum(1, (y, 1, 10)))
-    assert factor_terms(Sum(x*y + x*y**2, (y, 1, 10))) == x*Sum(y*(y + 1), (y, 1, 10))
+    # sum/integral tests
+    for F in (Sum, Integral):
+        assert factor_terms(F(x, (y, 1, 10))) == x * F(1, (y, 1, 10))
+        assert factor_terms(F(x, (y, 1, 10)) + x) == x * (1 + F(1, (y, 1, 10)))
+        assert factor_terms(F(x*y + x*y**2, (y, 1, 10))) == x*F(y*(y + 1), (y, 1, 10))
 
 
 def test_xreplace():
diff --git a/sympy/physics/continuum_mechanics/tests/test_beam.py b/sympy/physics/continuum_mechanics/tests/test_beam.py
--- a/sympy/physics/continuum_mechanics/tests/test_beam.py
+++ b/sympy/physics/continuum_mechanics/tests/test_beam.py
@@ -503,17 +503,14 @@ def test_Beam3D():
 
     assert b.shear_force() == [0, -q*x, 0]
     assert b.bending_moment() == [0, 0, -m*x + q*x**2/2]
-    expected_deflection = (-l**2*q*x**2/(12*E*I) + l**2*x**2*(A*G*l*(l*q - 2*m)
-            + 12*E*I*q)/(8*E*I*(A*G*l**2 + 12*E*I)) + l*m*x**2/(4*E*I)
-            - l*x**3*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(12*E*I*(A*G*l**2 + 12*E*I))
-            - m*x**3/(6*E*I) + q*x**4/(24*E*I)
-            + l*x*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(2*A*G*(A*G*l**2 + 12*E*I))
-            - q*x**2/(2*A*G)
-            )
+    expected_deflection = (x*(A*G*q*x**3/4 + A*G*x**2*(-l*(A*G*l*(l*q - 2*m) +
+        12*E*I*q)/(A*G*l**2 + 12*E*I)/2 - m) + 3*E*I*l*(A*G*l*(l*q - 2*m) +
+        12*E*I*q)/(A*G*l**2 + 12*E*I) + x*(-A*G*l**2*q/2 +
+        3*A*G*l**2*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(A*G*l**2 + 12*E*I)/4 +
+        3*A*G*l*m/2 - 3*E*I*q))/(6*A*E*G*I))
     dx, dy, dz = b.deflection()
     assert dx == dz == 0
-    assert simplify(dy - expected_deflection) == 0  # == doesn't work
-
+    assert dy == expected_deflection
 
     b2 = Beam3D(30, E, G, I, A, x)
     b2.apply_load(50, start=0, order=0, dir="y")
@@ -524,12 +521,12 @@ def test_Beam3D():
     assert b2.reaction_loads == {R1: -750, R2: -750}
 
     b2.solve_slope_deflection()
-    assert b2.slope() == [0, 0, 25*x**3/(3*E*I) - 375*x**2/(E*I) + 3750*x/(E*I)]
-    expected_deflection = (25*x**4/(12*E*I) - 125*x**3/(E*I) + 1875*x**2/(E*I)
-                        - 25*x**2/(A*G) + 750*x/(A*G))
+    assert b2.slope() == [0, 0, x**2*(50*x - 2250)/(6*E*I) + 3750*x/(E*I)]
+    expected_deflection = (x*(25*A*G*x**3/2 - 750*A*G*x**2 + 4500*E*I +
+        15*x*(750*A*G - 10*E*I))/(6*A*E*G*I))
     dx, dy, dz = b2.deflection()
     assert dx == dz == 0
-    assert simplify(dy - expected_deflection) == 0  # == doesn't work
+    assert dy == expected_deflection
 
     # Test for solve_for_reaction_loads
     b3 = Beam3D(30, E, G, I, A, x)
diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py
--- a/sympy/simplify/tests/test_simplify.py
+++ b/sympy/simplify/tests/test_simplify.py
@@ -793,3 +793,12 @@ def _check(expr, simplified, deep=True, matrix=True):
     assert nc_simplify(expr) == (1-c)**-1
     # commutative expressions should be returned without an error
     assert nc_simplify(2*x**2) == 2*x**2
+
+def test_issue_15965():
+    A = Sum(z*x**y, (x, 1, a))
+    anew = z*Sum(x**y, (x, 1, a))
+    B = Integral(x*y, x)
+    bnew = y*Integral(x, x)
+    assert simplify(A + B) == anew + bnew
+    assert simplify(A) == anew
+    assert simplify(B) == bnew