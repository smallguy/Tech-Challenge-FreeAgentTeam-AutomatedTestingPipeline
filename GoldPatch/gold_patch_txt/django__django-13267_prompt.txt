# 修复代码生成提示词（实例ID：django__django-13267）
## 代码仓库
django/django

## 原始问题描述
Instantiating an abstract model with a string ForeignKey fails with TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types
Description
	
Trying to instantiate an abstract model with a foreign key worked without throwing any warnings in Django 1.8. In Django 1.9.8, this code:
class UserProfile(Model):
	user = models.ForeignKey('auth.user')
	class Meta(object):
		app_label = 'core'
		abstract = True
UserProfile()
raises this exception:
Traceback (most recent call last):
 File "<ipython-input-7-5fa4dfdf1ad9>", line 2, in <module>
	UserProfile()
 File ".../.venv/lib/python2.7/site-packages/django/db/models/base.py", line 432, in __init__
	val = field.get_default()
 File ".../.venv/lib/python2.7/site-packages/django/db/models/fields/related.py", line 905, in get_default
	if isinstance(field_default, self.remote_field.model):
TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types
While the code mentions that abstract models can not be instantiated [1], I couldn't find mention of this in the docs. Abstract models without foreign keys can still be instantiated perfectly fine.
I couldn't find any description of this change in the Release Notes, so not sure if I missed it there or if this is maybe an undocumented backwards-incompatible change.
[1] ​https://github.com/django/django/blob/026574e03c6b6fd20a45f97b0470afb70e41fda4/django/db/models/base.py#L284


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/auth_tests/test_models.py b/tests/auth_tests/test_models.py
--- a/tests/auth_tests/test_models.py
+++ b/tests/auth_tests/test_models.py
@@ -6,7 +6,7 @@
 from django.contrib.auth.base_user import AbstractBaseUser
 from django.contrib.auth.hashers import get_hasher
 from django.contrib.auth.models import (
-    AbstractUser, AnonymousUser, Group, Permission, User, UserManager,
+    AnonymousUser, Group, Permission, User, UserManager,
 )
 from django.contrib.contenttypes.models import ContentType
 from django.core import mail
@@ -215,8 +215,7 @@ def test_clean_normalize_username(self):
                 self.assertEqual(username, 'iamtheΩ')  # U+03A9 GREEK CAPITAL LETTER OMEGA
 
     def test_default_email(self):
-        user = AbstractBaseUser()
-        self.assertEqual(user.get_email_field_name(), 'email')
+        self.assertEqual(AbstractBaseUser.get_email_field_name(), 'email')
 
     def test_custom_email(self):
         user = CustomEmailField()
@@ -233,8 +232,8 @@ def test_email_user(self):
             "connection": None,
             "html_message": None,
         }
-        abstract_user = AbstractUser(email='foo@bar.com')
-        abstract_user.email_user(
+        user = User(email='foo@bar.com')
+        user.email_user(
             subject="Subject here",
             message="This is a message",
             from_email="from@domain.com",
@@ -245,7 +244,7 @@ def test_email_user(self):
         self.assertEqual(message.subject, "Subject here")
         self.assertEqual(message.body, "This is a message")
         self.assertEqual(message.from_email, "from@domain.com")
-        self.assertEqual(message.to, [abstract_user.email])
+        self.assertEqual(message.to, [user.email])
 
     def test_last_login_default(self):
         user1 = User.objects.create(username='user1')
diff --git a/tests/model_meta/tests.py b/tests/model_meta/tests.py
--- a/tests/model_meta/tests.py
+++ b/tests/model_meta/tests.py
@@ -279,10 +279,19 @@ def test_get_parent_list(self):
 class PropertyNamesTests(SimpleTestCase):
     def test_person(self):
         # Instance only descriptors don't appear in _property_names.
-        self.assertEqual(AbstractPerson().test_instance_only_descriptor, 1)
+        self.assertEqual(BasePerson().test_instance_only_descriptor, 1)
+        with self.assertRaisesMessage(AttributeError, 'Instance only'):
+            AbstractPerson.test_instance_only_descriptor
         self.assertEqual(AbstractPerson._meta._property_names, frozenset(['pk', 'test_property']))
 
 
 class ReturningFieldsTests(SimpleTestCase):
     def test_pk(self):
         self.assertEqual(Relation._meta.db_returning_fields, [Relation._meta.pk])
+
+
+class AbstractModelTests(SimpleTestCase):
+    def test_abstract_model_not_instantiated(self):
+        msg = 'Abstract models cannot be instantiated.'
+        with self.assertRaisesMessage(TypeError, msg):
+            AbstractPerson()