# 修复代码生成提示词（实例ID：sympy__sympy-21476）
## 代码仓库
sympy/sympy

## 原始问题描述
diffgeom.CoordSystem.transform with indirect relation raises KeyError
Below code is a minimal example for an indirect transform via a temporary intermediate coordinate system. `parabolic2D.transform(poloidal)` raises a KeyError.

MWE:
```
"""
2D manifold coordinate systems
"""
import sympy
import sympy.diffgeom

CARTESIAN2D = "cartesian2D"
POLOIDAL = "poloidal"
PARABOLIC2D = "parabolic2D"

m = sympy.diffgeom.Manifold("M", 2)
p = sympy.diffgeom.Patch("P", m)
RELATIONS = {}

# #########
# cartesian
# #########
x, y = sympy.symbols("x y")

# #########
# poloidal
# #########
r, theta = sympy.symbols("r theta", nonnegative=True)
RELATIONS[(CARTESIAN2D, POLOIDAL)] = sympy.Lambda(
    (x, y),
    sympy.Matrix(
        [
            sympy.sqrt(x ** 2 + y ** 2),
            sympy.atan2(y, x)
        ]
    )
)
RELATIONS[(POLOIDAL, CARTESIAN2D)] = sympy.Lambda(
    (r, theta),
    sympy.Matrix(
        [
            r * sympy.cos(theta),
            r * sympy.sin(theta)
        ]
    )
)

# #########
# parabolic
# #########
sigma, tau = sympy.symbols("sigma tau")
RELATIONS[(PARABOLIC2D, CARTESIAN2D)] = sympy.Lambda(
    (sigma, tau),
    sympy.Matrix(
        [
            sigma * tau,
            1 / 2 * (tau**2 - sigma**2)
        ]
    )
)

cartesian2D = sympy.diffgeom.CoordSystem(CARTESIAN2D, p, [x, y], RELATIONS)
poloidal = sympy.diffgeom.CoordSystem(POLOIDAL, p, [r, theta], RELATIONS)
parabolic2D = sympy.diffgeom.CoordSystem(PARABOLIC2D, p, [sigma, tau], RELATIONS)


if __name__ == "__main__":
    print(parabolic2D.transform(poloidal))  # raises a KeyError
    print(poloidal.transform(parabolic2D))  # raises a KeyError
```

This raises a KeyError.

> Traceback (most recent call last):
>   File "/opt/anaconda/envs/py38/lib/python3.8/pdb.py", line 1703, in main
>     pdb._runscript(mainpyfile)
>   File "/opt/anaconda/envs/py38/lib/python3.8/pdb.py", line 1572, in _runscript
>     self.run(statement)
>   File "/opt/anaconda/envs/py38/lib/python3.8/bdb.py", line 580, in run
>     exec(cmd, globals, locals)
>   File "<string>", line 1, in <module>
>   File "/home/IPP-HGW/dboe/git/tfields/tfields/bases/manifold_2.py", line 1, in <module>
>     """
>   File "/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py", line 480, in transform
>     transf = self.transformation(sys)
>   File "/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py", line 354, in transformation
>     return self._indirect_transformation(self, sys)
>   File "/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/core/cache.py", line 72, in wrapper
>     retval = cfunc(*args, **kwargs)
>   File "/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py", line 376, in _indirect_transformation
>     path = cls._dijkstra(sys1, sys2)
>   File "/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py", line 414, in _dijkstra
>     visit(sys1)
>   File "/opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py", line 406, in visit
>     path_dict[sys][2] = 1
> KeyError: parabolic2D
> 

I think I found the reson already: In dijkstra routing the comparison is done between a CoordSystem and sympy.Str
DEBUGGING:

```
Uncaught exception. Entering post mortem debugging
Running 'cont' or 'step' will restart the program
> /opt/anaconda/envs/py38/lib/python3.8/site-packages/sympy/diffgeom/diffgeom.py(406)visit()
-> path_dict[sys][2] = 1
(Pdb) path_dict
{cartesian2D: [0, [], 0], poloidal: [0, [], 0], parabolic2D: [0, [], 0]}
(Pdb) sys
parabolic2D
(Pdb) hash(sys)
-2150956724454717966
(Pdb) [hash(k) for k in path_dict]
[6233656281303402583, 5480353473597806494, -1340528192013030397]
(Pdb) type(sys)
<class 'sympy.diffgeom.diffgeom.CoordSystem'>
(Pdb) [type(k) for k in path_dict]
[<class 'sympy.core.symbol.Str'>, <class 'sympy.core.symbol.Str'>, <class 'sympy.core.symbol.Str'>]
```



## 参考黄金补丁（正确的修复方案）
diff --git a/sympy/diffgeom/tests/test_diffgeom.py b/sympy/diffgeom/tests/test_diffgeom.py
--- a/sympy/diffgeom/tests/test_diffgeom.py
+++ b/sympy/diffgeom/tests/test_diffgeom.py
@@ -1,10 +1,10 @@
+from sympy.core import Lambda, Symbol, symbols
 from sympy.diffgeom.rn import R2, R2_p, R2_r, R3_r, R3_c, R3_s, R2_origin
 from sympy.diffgeom import (CoordSystem, Commutator, Differential, TensorProduct,
         WedgeProduct, BaseCovarDerivativeOp, CovarDerivativeOp, LieDerivative,
         covariant_order, contravariant_order, twoform_to_matrix, metric_to_Christoffel_1st,
         metric_to_Christoffel_2nd, metric_to_Riemann_components,
         metric_to_Ricci_components, intcurve_diffequ, intcurve_series)
-from sympy.core import Symbol, symbols
 from sympy.simplify import trigsimp, simplify
 from sympy.functions import sqrt, atan2, sin
 from sympy.matrices import Matrix
@@ -14,6 +14,78 @@
 TP = TensorProduct
 
 
+def test_coordsys_transform():
+    # test inverse transforms
+    p, q, r, s = symbols('p q r s')
+    rel = {('first', 'second'): [(p, q), (q, -p)]}
+    R2_pq = CoordSystem('first', R2_origin, [p, q], rel)
+    R2_rs = CoordSystem('second', R2_origin, [r, s], rel)
+    r, s = R2_rs.symbols
+    assert R2_rs.transform(R2_pq) == Matrix([[-s], [r]])
+
+    # inverse transform impossible case
+    a, b = symbols('a b', positive=True)
+    rel = {('first', 'second'): [(a,), (-a,)]}
+    R2_a = CoordSystem('first', R2_origin, [a], rel)
+    R2_b = CoordSystem('second', R2_origin, [b], rel)
+    # This transformation is uninvertible because there is no positive a, b satisfying a = -b
+    with raises(NotImplementedError):
+        R2_b.transform(R2_a)
+
+    # inverse transform ambiguous case
+    c, d = symbols('c d')
+    rel = {('first', 'second'): [(c,), (c**2,)]}
+    R2_c = CoordSystem('first', R2_origin, [c], rel)
+    R2_d = CoordSystem('second', R2_origin, [d], rel)
+    # The transform method should throw if it finds multiple inverses for a coordinate transformation.
+    with raises(ValueError):
+        R2_d.transform(R2_c)
+
+    # test indirect transformation
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    rel = {('C1', 'C2'): [(a, b), (2*a, 3*b)],
+        ('C2', 'C3'): [(c, d), (3*c, 2*d)]}
+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)
+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)
+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)
+    a, b = C1.symbols
+    c, d = C2.symbols
+    e, f = C3.symbols
+    assert C2.transform(C1) == Matrix([c/2, d/3])
+    assert C1.transform(C3) == Matrix([6*a, 6*b])
+    assert C3.transform(C1) == Matrix([e/6, f/6])
+    assert C3.transform(C2) == Matrix([e/3, f/2])
+
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    rel = {('C1', 'C2'): [(a, b), (2*a, 3*b + 1)],
+        ('C3', 'C2'): [(e, f), (-e - 2, 2*f)]}
+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)
+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)
+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)
+    a, b = C1.symbols
+    c, d = C2.symbols
+    e, f = C3.symbols
+    assert C2.transform(C1) == Matrix([c/2, (d - 1)/3])
+    assert C1.transform(C3) == Matrix([-2*a - 2, (3*b + 1)/2])
+    assert C3.transform(C1) == Matrix([-e/2 - 1, (2*f - 1)/3])
+    assert C3.transform(C2) == Matrix([-e - 2, 2*f])
+
+    # old signature uses Lambda
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    rel = {('C1', 'C2'): Lambda((a, b), (2*a, 3*b + 1)),
+        ('C3', 'C2'): Lambda((e, f), (-e - 2, 2*f))}
+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)
+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)
+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)
+    a, b = C1.symbols
+    c, d = C2.symbols
+    e, f = C3.symbols
+    assert C2.transform(C1) == Matrix([c/2, (d - 1)/3])
+    assert C1.transform(C3) == Matrix([-2*a - 2, (3*b + 1)/2])
+    assert C3.transform(C1) == Matrix([-e/2 - 1, (2*f - 1)/3])
+    assert C3.transform(C2) == Matrix([-e - 2, 2*f])
+
+
 def test_R2():
     x0, y0, r0, theta0 = symbols('x0, y0, r0, theta0', real=True)
     point_r = R2_r.point([x0, y0])
@@ -37,45 +109,6 @@ def test_R2():
             R2_r, R2_r.coord_tuple_transform_to(R2_p, m)).applyfunc(simplify)
 
 
-def test_inverse_transformations():
-    p, q, r, s = symbols('p q r s')
-
-    relations_quarter_rotation = {
-        ('first', 'second'): (q, -p)
-    }
-
-    R2_pq = CoordSystem('first', R2_origin, [p, q], relations_quarter_rotation)
-    R2_rs = CoordSystem('second', R2_origin, [r, s], relations_quarter_rotation)
-
-    # The transform method should derive the inverse transformation if not given explicitly
-    assert R2_rs.transform(R2_pq) == Matrix([[-R2_rs.symbols[1]], [R2_rs.symbols[0]]])
-
-    a, b = symbols('a b', positive=True)
-    relations_uninvertible_transformation = {
-        ('first', 'second'): (-a,)
-    }
-
-    R2_a = CoordSystem('first', R2_origin, [a], relations_uninvertible_transformation)
-    R2_b = CoordSystem('second', R2_origin, [b], relations_uninvertible_transformation)
-
-    # The transform method should throw if it cannot invert the coordinate transformation.
-    # This transformation is uninvertible because there is no positive a, b satisfying a = -b
-    with raises(NotImplementedError):
-        R2_b.transform(R2_a)
-
-    c, d = symbols('c d')
-    relations_ambiguous_inverse = {
-        ('first', 'second'): (c**2,)
-    }
-
-    R2_c = CoordSystem('first', R2_origin, [c], relations_ambiguous_inverse)
-    R2_d = CoordSystem('second', R2_origin, [d], relations_ambiguous_inverse)
-
-    # The transform method should throw if it finds multiple inverses for a coordinate transformation.
-    with raises(ValueError):
-        R2_d.transform(R2_c)
-
-
 def test_R3():
     a, b, c = symbols('a b c', positive=True)
     m = Matrix([[a], [b], [c]])