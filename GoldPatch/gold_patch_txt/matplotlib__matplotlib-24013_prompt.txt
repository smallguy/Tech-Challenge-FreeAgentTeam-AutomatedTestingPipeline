# 修复代码生成提示词（实例ID：matplotlib__matplotlib-24013）
## 代码仓库
matplotlib/matplotlib

## 原始问题描述
function shadowing their own definition modules
I'm not sure if this is really a "bug" report but more of an unexpected interaction. The short reason for this is that I'm working on improving the documentation in IPython and need a bijection object <-> fully qualified name which is made difficult by the following. I take the example of tripcolor, but this is not the only object that shadow it's module definition.

### Bug report

`matplotlib.tri.tripcolor` refer either as a module or function depending on context:

```
>>> from matplotlib.tri.tripcolor import tripcolor
>>> tripcolor.__module__
'matplotlib.tri.tripcolor'
```
Therefore those two lines confort us that `matplotlib.tri.tripcolor` is a module.

Though

```
>>> matplotlib.tri.tripcolor is tripcolor
True
```

This is not too shocking for the advanced pythonista, as `tri/__init__.py:` contains
```
...
from .tripcolor import * 
```

Though it makes it hard to get access to the tripcolor module, though still possible via `importlib.import_module`, but make getting the object from it's fully qualified name difficult:

```
In [6]: qualname = tripcolor.__module__+ '.' + tripcolor.__name__
   ...: obj = matplotlib
   ...: for k in qualname.split('.')[1:]:
   ...:     obj = getattr(obj, k)
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-25-8f431e6ed783> in <module>
      2 obj = matplotlib
      3 for k in qualname.split('.')[1:]:
----> 4     obj = getattr(obj, k)

AttributeError: 'function' object has no attribute 'tripcolor'
```

I'd like to suggest to rename the tripcolor submodule to _tripcolor, or anything else which is different than the name of the function so that the function and module where it is defined have non-clashing fully-qualified names. 

Note that this is not completely API-compatible, as the shown above `from matplotlib.tri.tripcolor import tripcolor` would not work – though the correct import form is `from matplotlib.tri import tripcolor` that should still work.

Is that a general concern in the matplotlib codebase and is there a desire that `obj.__module__+'.'+obj.__name__` should allow to get the fully qualified name of the object and should allow recursive call to getattr/import in order to access the object?


## 参考黄金补丁（正确的修复方案）
diff --git a/lib/matplotlib/tests/test_triangulation.py b/lib/matplotlib/tests/test_triangulation.py
--- a/lib/matplotlib/tests/test_triangulation.py
+++ b/lib/matplotlib/tests/test_triangulation.py
@@ -614,15 +614,15 @@ def poisson_sparse_matrix(n, m):
 
     # Instantiating a sparse Poisson matrix of size 48 x 48:
     (n, m) = (12, 4)
-    mat = mtri.triinterpolate._Sparse_Matrix_coo(*poisson_sparse_matrix(n, m))
+    mat = mtri._triinterpolate._Sparse_Matrix_coo(*poisson_sparse_matrix(n, m))
     mat.compress_csc()
     mat_dense = mat.to_dense()
     # Testing a sparse solve for all 48 basis vector
     for itest in range(n*m):
         b = np.zeros(n*m, dtype=np.float64)
         b[itest] = 1.
-        x, _ = mtri.triinterpolate._cg(A=mat, b=b, x0=np.zeros(n*m),
-                                       tol=1.e-10)
+        x, _ = mtri._triinterpolate._cg(A=mat, b=b, x0=np.zeros(n*m),
+                                        tol=1.e-10)
         assert_array_almost_equal(np.dot(mat_dense, x), b)
 
     # 2) Same matrix with inserting 2 rows - cols with null diag terms
@@ -635,16 +635,16 @@ def poisson_sparse_matrix(n, m):
     rows = np.concatenate([rows, [i_zero, i_zero-1, j_zero, j_zero-1]])
     cols = np.concatenate([cols, [i_zero-1, i_zero, j_zero-1, j_zero]])
     vals = np.concatenate([vals, [1., 1., 1., 1.]])
-    mat = mtri.triinterpolate._Sparse_Matrix_coo(vals, rows, cols,
-                                                 (n*m + 2, n*m + 2))
+    mat = mtri._triinterpolate._Sparse_Matrix_coo(vals, rows, cols,
+                                                  (n*m + 2, n*m + 2))
     mat.compress_csc()
     mat_dense = mat.to_dense()
     # Testing a sparse solve for all 50 basis vec
     for itest in range(n*m + 2):
         b = np.zeros(n*m + 2, dtype=np.float64)
         b[itest] = 1.
-        x, _ = mtri.triinterpolate._cg(A=mat, b=b, x0=np.ones(n*m + 2),
-                                       tol=1.e-10)
+        x, _ = mtri._triinterpolate._cg(A=mat, b=b, x0=np.ones(n * m + 2),
+                                        tol=1.e-10)
         assert_array_almost_equal(np.dot(mat_dense, x), b)
 
     # 3) Now a simple test that summation of duplicate (i.e. with same rows,
@@ -655,7 +655,7 @@ def poisson_sparse_matrix(n, m):
     cols = np.array([0, 1, 2, 1, 1, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],
                     dtype=np.int32)
     dim = (3, 3)
-    mat = mtri.triinterpolate._Sparse_Matrix_coo(vals, rows, cols, dim)
+    mat = mtri._triinterpolate._Sparse_Matrix_coo(vals, rows, cols, dim)
     mat.compress_csc()
     mat_dense = mat.to_dense()
     assert_array_almost_equal(mat_dense, np.array([
@@ -678,7 +678,7 @@ def test_triinterpcubic_geom_weights():
         y_rot = -np.sin(theta)*x + np.cos(theta)*y
         triang = mtri.Triangulation(x_rot, y_rot, triangles)
         cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')
-        dof_estimator = mtri.triinterpolate._DOF_estimator_geom(cubic_geom)
+        dof_estimator = mtri._triinterpolate._DOF_estimator_geom(cubic_geom)
         weights = dof_estimator.compute_geom_weights()
         # Testing for the 4 possibilities...
         sum_w[0, :] = np.sum(weights, 1) - 1