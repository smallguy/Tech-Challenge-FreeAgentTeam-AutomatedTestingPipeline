# 修复代码生成提示词（实例ID：django__django-14508）
## 代码仓库
django/django

## 原始问题描述
Overwriting a property with field during model inheritance.
Description
	
Documentation says (in ​https://docs.djangoproject.com/en/1.3/topics/db/models/#field-name-hiding-is-not-permitted paragraph) that:
This restriction only applies to attributes which are Field instances. Normal Python attributes can be overridden if you wish. It also only applies to the name of the attribute as Python sees it: if you are manually specifying the database column name, you can have the same column name appearing in both a child and an ancestor model for multi-table inheritance (they are columns in two different database tables).
However.. I came up today with setup like this:
 1 from django.db import models
 2 
 3 # Create your models here.
 4 
 5 class SomeTestModel(models.Model):
 6	 some_field = models.CharField(max_length=100)
 7 
 8	 class Meta:
 9		 abstract = True
10 
11	 @property																						 
12	 def other_field(self):
13		 return "[OTHER] %s" % self.some_field
14 
15 
16 
17 class OtherModel(SomeTestModel):
18	 other_field = models.CharField(max_length=100)
19 
20 
21 class AndMoreOther(SomeTestModel):
22	 not_important_field = models.CharField(max_length=100)
And then if you do:
>>> from testapp.models import *
>>> o = OtherModel()
Traceback (most recent call last):
 File "<console>", line 1, in <module>
 File "/home/arturstudio/PROJEKTY/tempdjango/inh/src/django/django/db/models/base.py", line 357, in __init__
	setattr(self, field.attname, val)
AttributeError: can't set attribute
Since my models where a lot bigger and more complicate, it took me almost all day to figure out that the problem was a @property from a base model, and my suggestion is that there should be at least a warning somewhere (during model's init perhaps) that could be more precise about why attribute couldn't been set. (or attribute to which object (either Model or Field).
I tried it on 1.2 and 1.4 pre-alpha SVN-16338
To reproduce you just need to put the models.py from above in some app.


## 参考黄金补丁（正确的修复方案）
diff --git a/tests/check_framework/tests.py b/tests/check_framework/tests.py
--- a/tests/check_framework/tests.py
+++ b/tests/check_framework/tests.py
@@ -314,6 +314,12 @@ class ModelWithDescriptorCalledCheck(models.Model):
                 obj=ModelWithAttributeCalledCheck,
                 id='models.E020'
             ),
+            Error(
+                "The 'ModelWithFieldCalledCheck.check()' class method is "
+                "currently overridden by %r." % ModelWithFieldCalledCheck.check,
+                obj=ModelWithFieldCalledCheck,
+                id='models.E020'
+            ),
             Error(
                 "The 'ModelWithRelatedManagerCalledCheck.check()' class method is "
                 "currently overridden by %r." % ModelWithRelatedManagerCalledCheck.check,
diff --git a/tests/defer/models.py b/tests/defer/models.py
--- a/tests/defer/models.py
+++ b/tests/defer/models.py
@@ -44,3 +44,16 @@ def refresh_from_db(self, using=None, fields=None, **kwargs):
             if fields.intersection(deferred_fields):
                 fields = fields.union(deferred_fields)
         super().refresh_from_db(using, fields, **kwargs)
+
+
+class ShadowParent(models.Model):
+    """
+    ShadowParent declares a scalar, rather than a field. When this is
+    overridden, the field value, rather than the scalar value must still be
+    used when the field is deferred.
+    """
+    name = 'aphrodite'
+
+
+class ShadowChild(ShadowParent):
+    name = models.CharField(default='adonis', max_length=6)
diff --git a/tests/defer/tests.py b/tests/defer/tests.py
--- a/tests/defer/tests.py
+++ b/tests/defer/tests.py
@@ -3,6 +3,7 @@
 
 from .models import (
     BigChild, Child, ChildProxy, Primary, RefreshPrimaryProxy, Secondary,
+    ShadowChild,
 )
 
 
@@ -165,6 +166,11 @@ def test_only_baseclass_when_subclass_has_no_added_fields(self):
         self.assertEqual(obj.name, "c1")
         self.assertEqual(obj.value, "foo")
 
+    def test_defer_of_overridden_scalar(self):
+        ShadowChild.objects.create()
+        obj = ShadowChild.objects.defer('name').get()
+        self.assertEqual(obj.name, 'adonis')
+
 
 class BigChildDeferTests(AssertionMixin, TestCase):
     @classmethod
diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py
--- a/tests/invalid_models_tests/test_models.py
+++ b/tests/invalid_models_tests/test_models.py
@@ -1212,9 +1212,8 @@ def test_property_and_related_field_accessor_clash(self):
         class Model(models.Model):
             fk = models.ForeignKey('self', models.CASCADE)
 
-            @property
-            def fk_id(self):
-                pass
+        # Override related field accessor.
+        Model.fk_id = property(lambda self: 'ERROR')
 
         self.assertEqual(Model.check(), [
             Error(
diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py
--- a/tests/model_inheritance/test_abstract_inheritance.py
+++ b/tests/model_inheritance/test_abstract_inheritance.py
@@ -34,7 +34,12 @@ class DerivedGrandChild(AbstractDescendant):
         self.assertEqual(DerivedChild._meta.get_field('name').max_length, 50)
         self.assertEqual(DerivedGrandChild._meta.get_field('name').max_length, 50)
 
-    def test_multiple_inheritance_cannot_shadow_inherited_field(self):
+    def test_multiple_inheritance_allows_inherited_field(self):
+        """
+        Single layer multiple inheritance is as expected, deriving the
+        inherited field from the first base.
+        """
+
         class ParentA(models.Model):
             name = models.CharField(max_length=255)
 
@@ -50,14 +55,76 @@ class Meta:
         class Child(ParentA, ParentB):
             pass
 
-        self.assertEqual(Child.check(), [
-            Error(
-                "The field 'name' clashes with the field 'name' from model "
-                "'model_inheritance.child'.",
-                obj=Child._meta.get_field('name'),
-                id='models.E006',
-            ),
-        ])
+        self.assertEqual(Child.check(), [])
+        inherited_field = Child._meta.get_field('name')
+        self.assertTrue(isinstance(inherited_field, models.CharField))
+        self.assertEqual(inherited_field.max_length, 255)
+
+    def test_diamond_shaped_multiple_inheritance_is_depth_first(self):
+        """
+        In contrast to standard Python MRO, resolution of inherited fields is
+        strictly depth-first, rather than breadth-first in diamond-shaped cases.
+
+        This is because a copy of the parent field descriptor is placed onto
+        the model class in ModelBase.__new__(), rather than the attribute
+        lookup going via bases. (It only **looks** like inheritance.)
+
+        Here, Child inherits name from Root, rather than ParentB.
+        """
+
+        class Root(models.Model):
+            name = models.CharField(max_length=255)
+
+            class Meta:
+                abstract = True
+
+        class ParentA(Root):
+            class Meta:
+                abstract = True
+
+        class ParentB(Root):
+            name = models.IntegerField()
+
+            class Meta:
+                abstract = True
+
+        class Child(ParentA, ParentB):
+            pass
+
+        self.assertEqual(Child.check(), [])
+        inherited_field = Child._meta.get_field('name')
+        self.assertTrue(isinstance(inherited_field, models.CharField))
+        self.assertEqual(inherited_field.max_length, 255)
+
+    def test_target_field_may_be_pushed_down(self):
+        """
+        Where the Child model needs to inherit a field from a different base
+        than that given by depth-first resolution, the target field can be
+        **pushed down** by being re-declared.
+        """
+
+        class Root(models.Model):
+            name = models.CharField(max_length=255)
+
+            class Meta:
+                abstract = True
+
+        class ParentA(Root):
+            class Meta:
+                abstract = True
+
+        class ParentB(Root):
+            name = models.IntegerField()
+
+            class Meta:
+                abstract = True
+
+        class Child(ParentA, ParentB):
+            name = models.IntegerField()
+
+        self.assertEqual(Child.check(), [])
+        inherited_field = Child._meta.get_field('name')
+        self.assertTrue(isinstance(inherited_field, models.IntegerField))
 
     def test_multiple_inheritance_cannot_shadow_concrete_inherited_field(self):
         class ConcreteParent(models.Model):
diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py
--- a/tests/model_inheritance/tests.py
+++ b/tests/model_inheritance/tests.py
@@ -2,6 +2,7 @@
 
 from django.core.exceptions import FieldError, ValidationError
 from django.db import connection, models
+from django.db.models.query_utils import DeferredAttribute
 from django.test import SimpleTestCase, TestCase
 from django.test.utils import CaptureQueriesContext, isolate_apps
 
@@ -222,6 +223,36 @@ def test_queryset_class_getitem(self):
         self.assertIs(models.QuerySet[Post, Post], models.QuerySet)
         self.assertIs(models.QuerySet[Post, int, str], models.QuerySet)
 
+    def test_shadow_parent_attribute_with_field(self):
+        class ScalarParent(models.Model):
+            foo = 1
+
+        class ScalarOverride(ScalarParent):
+            foo = models.IntegerField()
+
+        self.assertEqual(type(ScalarOverride.foo), DeferredAttribute)
+
+    def test_shadow_parent_property_with_field(self):
+        class PropertyParent(models.Model):
+            @property
+            def foo(self):
+                pass
+
+        class PropertyOverride(PropertyParent):
+            foo = models.IntegerField()
+
+        self.assertEqual(type(PropertyOverride.foo), DeferredAttribute)
+
+    def test_shadow_parent_method_with_field(self):
+        class MethodParent(models.Model):
+            def foo(self):
+                pass
+
+        class MethodOverride(MethodParent):
+            foo = models.IntegerField()
+
+        self.assertEqual(type(MethodOverride.foo), DeferredAttribute)
+
 
 class ModelInheritanceDataTests(TestCase):
     @classmethod